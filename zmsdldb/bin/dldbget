#!/usr/bin/env php
<?php

error_reporting(E_ALL);
ini_set('display_errors', 1);

require __DIR__ . '/../vendor/autoload.php';

require_once(__DIR__."/script_bootstrap.php");

use Garden\Cli\Cli;
use Httpful\Request;

require_once(__DIR__."/dldb-helpers.php");

$cli = new Cli();
$cli->description("Downloads JSON files from the official site, validates them, replaces the old files, and handles backups if changes are detected.")
    ->opt('output:o', 'Path to save files', true)
    ->opt('proxy:p', 'Proxy server like "proxy:3128"', false)
    ->opt('base:b', 'Base download url', true)
    ->opt('query:q', 'Query or environment setting to use', false); 
$args = $cli->parse($argv, true);

$destinationPath = $args->getOpt('output');
$backupPath = $destinationPath . '/backups';
$helpers = new DldbHelpers($destinationPath, $cli);

// Ensure the destination directory exists
if (!is_dir($destinationPath) && !mkdir($destinationPath, 0777, true) && !is_dir($destinationPath)) {
    print($cli->red("Failed to create the destination directory at $destinationPath\n\n"));
    exit(1);
}

$baseDomain = rtrim($args->getOpt('base'), '/'); // Remove trailing slash to avoid double slashes
$proxy = $args->getOpt('proxy') ?: getenv('HTTP_PROXY');
$client = Request::init()->withoutAutoParsing()->followRedirects()->timeout(30);

if ($proxy) {
    $client->useProxy($proxy);
}

Request::ini($client);



$rollbackDay = $helpers->getRollbackDay();
// If a rollback is requested, skip fetching new data and do not delete any backups
if ($rollbackDay !== "none") {
    $helpers->performRollback($rollbackDay);
} else {
    print("No rollback is requested fetching current...\n\n");
    $downloads = [
        [
            'url' => '/export/standorte/json/',
            'file' => 'locations_de.json',
        ],
        [
            'url' => '/export/standorte/json/en/',
            'file' => 'locations_en.json',
        ],
        [
            'url' => '/export/dienstleistungen/json/',
            'file' => 'services_de.json',
        ],
        [
            'url' => '/export/dienstleistungen/json/en/',
            'file' => 'services_en.json',
        ],
        [
            'url' => '/export/themen/json/',
            'file' => 'topic_de.json',
        ],
        [
            'url' => '/export/behoerden/json/',
            'file' => 'authority_de.json',
        ],
        [
            'url' => '/export/settings/json/',
            'file' => 'settings.json',
        ],
    ];
    
    $downloadedFiles = [];
    foreach ($downloads as $download) {
        $destFile = $destinationPath . '/' . $download['file'];
        $request = Request::get($baseDomain . $download['url'])->send();
        
        if ($request->code !== 200 || (isset($request->body->error) && $request->body->error)) {
            print($cli->red("Error: Failed to download or validate {$download['file']}\n\n"));
            continue;
        }
    
        $newContent = $request->raw_body;
        print("Download {$baseDomain}{$download['url']} to $destFile\n\n");
        file_put_contents($destFile, $newContent);
        $downloadedFiles[$download['file']] = $destFile;
    }
    
    // Check if backup is needed and perform backup
    $backupRequired = $helpers->checkAndCreateBackup($downloadedFiles);
    
    // Cleanup old backups
    $helpers->cleanupOldBackups();

}

print("Downloads and backups (if necessary) completed.\n\n");
