#!/usr/bin/env php
<?php
require 'vendor/autoload.php';

use Garden\Cli\Cli;
use Httpful\Request;
use BO\Zmsdb\Config as ConfigRepository;

// Assuming \App::$http->readGetResult returns an object with a getEntity() method that returns configuration settings
$config = (new ConfigRepository())->readEntity();

// Function to get the backup retention days
function getBackupRetentionDays($config) {
    $retentionSetting = getenv('ZMS_ENV'), explode(',', $config->getPreference('dldbBackup', 'setRetentionPeriodDays'));
    return !empty($retentionSetting) ? (int)reset($retentionSetting) : 7; // Default to 7 days if not set
}

// Function to determine if a rollback is requested
function getRollbackDay($config) {
    $rollbackDaySetting = getenv('ZMS_ENV'), explode(',', $config->getPreference('dldbBackup', 'setRollbackDay'));
    return !empty($rollbackDaySetting) ? (int)reset($rollbackDaySetting) : 0; // Default to 0 (no rollback) if not set
}

$cli = new Cli();
$cli->description("Downloads JSON files from the official site, validates them, replaces the old files, and handles backups if changes are detected.")
    ->opt('output:o', 'Path to save files', true)
    ->opt('proxy:p', 'Proxy server like "proxy:3128"', false)
    ->opt('base:b', 'Base download url', true);
$args = $cli->parse($argv, true);

$destinationPath = $args->getOpt('output');
$backupPath = $destinationPath . '/backups';

// Ensure the destination directory exists
if (!is_dir($destinationPath) && !mkdir($destinationPath, 0777, true) && !is_dir($destinationPath)) {
    echo $cli->red("Failed to create the destination directory at $destinationPath\n");
    exit(1);
}

$baseDomain = $args->getOpt('base');
$proxy = $args->getOpt('proxy') ?: getenv('HTTP_PROXY');
$client = Request::init()->withoutAutoParsing()->followRedirects()->timeout(30);

if ($proxy) {
    $client->useProxy($proxy);
}

Request::ini($client);

$rollbackDay = getRollbackDay($config);

// If a rollback is requested, skip fetching new data and do not delete any backups
if ($rollbackDay > 0) {
    echo "Rollback to day $rollbackDay is requested. Preparing to rollback...\n";

    // Find the specified backup directory
    $backupDirectories = glob($backupPath . '/*', GLOB_ONLYDIR);
    usort($backupDirectories, function($a, $b) {
        return filemtime($b) - filemtime($a);
    });

    if (isset($backupDirectories[$rollbackDay - 1])) {
        $rollbackDir = $backupDirectories[$rollbackDay - 1];
        echo "Rolling back using backup from: $rollbackDir\n";

        // Copy .json files from the specified backup directory to the data directory
        foreach (glob($rollbackDir . '/*.json') as $file) {
            $destFile = $destinationPath . '/' . basename($file);
            if (!copy($file, $destFile)) {
                echo $cli->red("Error: Failed to rollback $file to $destFile\n");
            } else {
                echo "Rolled back $file to $destFile\n";
            }
        }
    } else {
        echo $cli->red("Error: Specified rollback day $rollbackDay does not exist in backups.\n");
    }

} else {
    $downloads = [
        [
            'url' => '/export/standorte/json/',
            'file' => 'locations_de.json',
        ],
        [
            'url' => '/export/standorte/json/en/',
            'file' => 'locations_en.json',
        ],
        [
            'url' => '/export/dienstleistungen/json/',
            'file' => 'services_de.json',
        ],
        [
            'url' => '/export/dienstleistungen/json/en/',
            'file' => 'services_en.json',
        ],
        [
            'url' => '/export/themen/json/',
            'file' => 'topic_de.json',
        ],
        [
            'url' => '/export/behoerden/json/',
            'file' => 'authority_de.json',
        ],
        [
            'url' => '/export/settings/json/',
            'file' => 'settings.json',
        ],
    ];
    
    $backupRequired = false;
    foreach ($downloads as $download) {
        $destFile = $destinationPath . '/' . $download['file'];
        $request = Request::get($baseDomain . $download['url'])->send();
        
        if ($request->code !== 200 || (isset($request->body->error) && $request->body->error)) {
            echo $cli->red("Error: Failed to download or validate {$download['file']}\n");
            continue;
        }
    
        $newContent = $request->raw_body;
        if (file_exists($destFile) && md5_file($destFile) !== md5($newContent)) {
            $backupRequired = true;
        }
        
        file_put_contents($destFile, $newContent);
    }
    
    if ($backupRequired) {
        $timestamp = date('Y-m-d');
        $backupDir = $backupPath . '/' . $timestamp;
        
        if (!mkdir($backupDir, 0777, true) && !is_dir($backupDir)) {
            echo $cli->red("Failed to create backup directory at $backupDir\n");
            exit(1);
        }
        
        foreach (glob($destinationPath . '/*.json') as $file) {
            if (!copy($file, $backupDir . '/' . basename($file))) {
                echo $cli->red("Failed to backup $file\n");
            }
        }
    }
    
    // Deleting old backups according to retention settings
    $retentionDays = getBackupRetentionDays($config);
    $limitDate = time() - ($retentionDays * 24 * 60 * 60);
    foreach (glob($backupPath . '/*', GLOB_ONLYDIR) as $dir) {
        if (filemtime($dir) < $limitDate) {
            foreach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator($dir, FilesystemIterator::SKIP_DOTS), RecursiveIteratorIterator::CHILD_FIRST) as $item) {
                if ($item->isDir()) {
                    rmdir($item->getRealPath());
                } else {
                    unlink($item->getRealPath());
                }
            }
            rmdir($dir);
            echo "Deleted old backup: $dir\n";
        }
    }

}

echo "Downloads and backups (if necessary) completed.\n";
