#!/usr/bin/env bash
# Detect if script is being sourced (vs executed directly)
IS_SOURCED=false
if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
  IS_SOURCED=true
fi

# Only set strict mode if not sourced (to avoid closing terminal on errors)
if [[ "$IS_SOURCED" == false ]]; then
  set -euo pipefail
else
  # When sourced, disable all strict modes to prevent terminal from closing
  set +e  # Don't exit on error
  set +u  # Don't error on unset variables
  set +o pipefail  # Don't fail pipelines if any command fails
fi

# Configurable endpoints (override via env)
# When running on ddev network, use 'web' service name instead of 'zms.ddev.site'
# When running on podman, use 'zms-web' service name
# BASE_URI should include the full path prefix and be HTTP to avoid TLS trust issues inside container
BASE_URI="${BASE_URI:-}"
# CITIZEN_API_BASE_URI should include full path prefix; both APIs are served by the same site
CITIZEN_API_BASE_URI="${CITIZEN_API_BASE_URI:-}"

# Maven image and caches
MAVEN_IMAGE="maven:3.9-eclipse-temurin-17"
ALPINE_IMAGE="docker.io/library/alpine:3.20"
M2_CACHE_VOLUME="zmsautomation-cache"
TARGET_VOLUME="zmsautomation-target"
# Detect script directory - works with both ./script.sh and source script.sh
if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
  # Script is being sourced
  SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
else
  # Script is being executed
  SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
fi
WORKSPACE_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
PROJECT_ROOT="$WORKSPACE_ROOT"

# Temporary backup file inside host
BACKUP_FILE="/tmp/zms_backup_$(date +%s).sql.gz"
BASE_SQL_FILE="$PROJECT_ROOT/.resources/zms.sql"

require_cmd() {
  if ! command -v "$1" >/dev/null 2>&1; then
    echo "ERROR: '$1' is required but not installed." >&2
    if [[ "$IS_SOURCED" == true ]]; then
      return 1
    else
      exit 1
    fi
  fi
}

info() { echo "[INFO] $*"; }
warn() { echo "[WARN] $*"; }
section() { echo ""; echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"; echo "[SECTION] $*"; echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"; echo ""; }

# Detect if we're using Podman or DDEV
USE_PODMAN=false
if command -v podman >/dev/null 2>&1; then
  if podman ps --format "{{.Names}}" | grep -q "^zms-web$" && podman ps --format "{{.Names}}" | grep -q "^zms-db$"; then
    USE_PODMAN=true
    info "Using Podman containers (zms-web, zms-db)"
    # Set default endpoints for Podman
    BASE_URI="${BASE_URI:-http://zms-web/terminvereinbarung/api/2}"
    CITIZEN_API_BASE_URI="${CITIZEN_API_BASE_URI:-http://zms-web/terminvereinbarung/api/citizen}"
  fi
fi

if [[ "$USE_PODMAN" == false ]]; then
  require_cmd ddev
  info "Using DDEV"
  # Set default endpoints for DDEV
  BASE_URI="${BASE_URI:-http://web/terminvereinbarung/api/2}"
  CITIZEN_API_BASE_URI="${CITIZEN_API_BASE_URI:-http://web/terminvereinbarung/api/citizen}"
fi

require_cmd docker

restore_db() {
  if [[ -f "$BACKUP_FILE" ]]; then
    info "Restoring database from $BACKUP_FILE ..."
    if [[ "$USE_PODMAN" == true ]]; then
      gunzip < "$BACKUP_FILE" | podman exec -i zms-db mysql -u root -proot db >/dev/null
    else
      (cd "$PROJECT_ROOT" && ddev import-db -f "$BACKUP_FILE" >/dev/null)
    fi
    info "Database restored."
  else
    warn "No backup file found to restore."
  fi
}

# Cleanup function to clear zmsapi/data folder (preserve .gitignore)
cleanup_data_folder() {
  if [[ "$USE_PODMAN" == true ]]; then
    (cd "$PROJECT_ROOT" && podman exec zms-web bash -lc '
      if [ -d /var/www/html/zmsapi/data ]; then
        find /var/www/html/zmsapi/data -mindepth 1 -not -name ".gitignore" -delete || true;
        [ -f /var/www/html/zmsapi/data/.gitignore ] || printf "*\n!.gitignore\n" > /var/www/html/zmsapi/data/.gitignore;
      fi
    ' 2>/dev/null || true)
  else
    (cd "$PROJECT_ROOT" && ddev exec bash -lc '
      if [ -d /var/www/html/zmsapi/data ]; then
        find /var/www/html/zmsapi/data -mindepth 1 -not -name ".gitignore" -delete || true;
        [ -f /var/www/html/zmsapi/data/.gitignore ] || printf "*\n!.gitignore\n" > /var/www/html/zmsapi/data/.gitignore;
      fi
    ' 2>/dev/null || true)
  fi
}

# Function to clear application caches
clear_caches() {
  info "Clearing application caches (zmsapi, zmsdb, zmscitizenapi) using CACHE_DIR..."
  if [[ "$USE_PODMAN" == true ]]; then
    CACHE_DIR=$(cd "$PROJECT_ROOT" && podman exec zms-web bash -lc 'echo "$CACHE_DIR"' 2>/dev/null || echo "")
  else
    CACHE_DIR=$(cd "$PROJECT_ROOT" && ddev exec bash -lc 'echo "$CACHE_DIR"' 2>/dev/null || echo "")
  fi
  if [[ -n "$CACHE_DIR" ]]; then
    info "CACHE_DIR=$CACHE_DIR"
    for dir in zmsapi zmsdb zmscitizenapi; do
      if [[ "$USE_PODMAN" == true ]]; then
        (cd "$PROJECT_ROOT" && podman exec zms-web bash -lc "
          if [ -d \"$CACHE_DIR/$dir\" ]; then
            rm -rf \"$CACHE_DIR/$dir\"/* \"$CACHE_DIR/$dir\"/.[!.]* \"$CACHE_DIR/$dir\"/..?* 2>/dev/null || true
            echo \"[CACHE] cleared $CACHE_DIR/$dir\"
          fi
        " || true)
      else
        (cd "$PROJECT_ROOT" && ddev exec bash -lc "
          if [ -d \"$CACHE_DIR/$dir\" ]; then
            rm -rf \"$CACHE_DIR/$dir\"/* \"$CACHE_DIR/$dir\"/.[!.]* \"$CACHE_DIR/$dir\"/..?* 2>/dev/null || true
            echo \"[CACHE] cleared $CACHE_DIR/$dir\"
          fi
        ")
      fi
    done
    # Also clear host-side cache that corresponds to container path (\"/var/www/html\" maps to project root)
    HOST_CACHE_DIR="$CACHE_DIR"
    if [[ "$HOST_CACHE_DIR" == /var/www/html/* ]]; then
      HOST_CACHE_DIR="$PROJECT_ROOT${HOST_CACHE_DIR#/var/www/html}"
      if [[ -d "$HOST_CACHE_DIR" ]]; then
        rm -rf "$HOST_CACHE_DIR"/* "$HOST_CACHE_DIR"/.[!.]* "$HOST_CACHE_DIR"/..?* 2>/dev/null || true
        info "[CACHE][host] cleared $HOST_CACHE_DIR"
      fi
      for dir in zmsapi zmsdb zmscitizenapi; do
        if [[ -d "$HOST_CACHE_DIR/$dir" ]]; then
          rm -rf "$HOST_CACHE_DIR/$dir"/* "$HOST_CACHE_DIR/$dir"/.[!.]* "$HOST_CACHE_DIR/$dir"/..?* 2>/dev/null || true
          info "[CACHE][host] cleared $HOST_CACHE_DIR/$dir"
        fi
      done
    fi
  else
    if [[ "$USE_PODMAN" == true ]]; then
      warn "CACHE_DIR not found in podman container"
    else
      warn "CACHE_DIR not found in ddev container"
    fi
  fi
}

# ERR trap - restore DB on error
# When sourced, clear any existing ERR trap and don't set a new one
# This prevents the trap from affecting commands after the script finishes
if [[ "$IS_SOURCED" == false ]]; then
  trap 'warn "Failure detected, attempting DB restore..."; restore_db' ERR
  # Set up EXIT trap to cleanup caches and zmsapi/data folder on script exit (normal, error, or Ctrl+C)
  trap 'clear_caches; cleanup_data_folder' EXIT INT TERM
else
  # When sourced, clear any existing ERR trap to prevent it from affecting future commands
  trap - ERR
fi

# 1) Backup current DB
section "1. Database Backup"
info "Exporting current database to $BACKUP_FILE ..."
if [[ "$USE_PODMAN" == true ]]; then
  (cd "$PROJECT_ROOT" && podman exec -i zms-db mysqldump -u root -proot db | gzip > "$BACKUP_FILE")
else
  (cd "$PROJECT_ROOT" && ddev export-db -f "$BACKUP_FILE" >/dev/null)
fi
info "Backup completed."
echo ""

# 1.5) Clear application caches inside container (zmsapi, zmsdb, zmscitizenapi)
section "2. Cache Clearing"
clear_caches
echo ""

# 2) Drop all tables to ensure clean state (removes tables created by migrations from previous runs)
section "3. Database Tables Drop"
info "Dropping all existing tables to ensure clean state..."
drop_tables() {
  local client="$1" # podman or ddev
  local table_count

  if [[ "$client" == "podman" ]]; then
    table_count=$(cd "$PROJECT_ROOT" && podman exec -i zms-db mysql -N -B -u root -proot db -e "
      SELECT COUNT(*)
      FROM information_schema.tables
      WHERE table_schema = 'db' AND table_type = 'BASE TABLE';
    " 2>/dev/null | tr -d '\r')
  else
    table_count=$(cd "$PROJECT_ROOT" && ddev exec -T mysql -udb -pdb db -N -B -e "
      SELECT COUNT(*)
      FROM information_schema.tables
      WHERE table_schema = 'db' AND table_type = 'BASE TABLE';
    " 2>/dev/null | tr -d '\r')
  fi

  if [[ -z "$table_count" || "$table_count" == "0" ]]; then
    echo "No tables to drop or database is empty"
    return
  fi

  if [[ "$client" == "podman" ]]; then
    (cd "$PROJECT_ROOT" && podman exec -i zms-db mysql -u root -proot db <<'SQL'
SET FOREIGN_KEY_CHECKS = 0;
SET @tables = (SELECT GROUP_CONCAT(CONCAT('`', table_name, '`')) FROM information_schema.tables WHERE table_schema = 'db' AND table_type = 'BASE TABLE');
SET @sql = IF(@tables IS NULL OR @tables = '', 'DO 0', CONCAT('DROP TABLE IF EXISTS ', @tables));
PREPARE stmt FROM @sql;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
SET FOREIGN_KEY_CHECKS = 1;
SQL
    )
  else
    (cd "$PROJECT_ROOT" && ddev exec mysql -udb -pdb db <<'SQL'
SET FOREIGN_KEY_CHECKS = 0;
SET @tables = (SELECT GROUP_CONCAT(CONCAT('`', table_name, '`')) FROM information_schema.tables WHERE table_schema = 'db' AND table_type = 'BASE TABLE');
SET @sql = IF(@tables IS NULL OR @tables = '', 'DO 0', CONCAT('DROP TABLE IF EXISTS ', @tables));
PREPARE stmt FROM @sql;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
SET FOREIGN_KEY_CHECKS = 1;
SQL
    )
  fi
}

if [[ "$USE_PODMAN" == true ]]; then
  drop_tables "podman"
else
  drop_tables "ddev"
fi
info "Tables dropped (if any existed)."

# Log database tables after reset to confirm drop
info "Database tables after reset (should be empty):"
if [[ "$USE_PODMAN" == true ]]; then
  (cd "$PROJECT_ROOT" && podman exec -i zms-db mysql -u root -proot db -e "
  SELECT table_name AS 'Table Name', table_rows AS 'Row Count'
  FROM information_schema.tables
  WHERE table_schema = 'db'
  ORDER BY table_name;
" || true)
else
  (cd "$PROJECT_ROOT" && ddev exec mysql -udb -pdb db -e "
  SELECT table_name AS 'Table Name', table_rows AS 'Row Count'
  FROM information_schema.tables
  WHERE table_schema = 'db'
  ORDER BY table_name;
" || true)
fi
echo ""

# 3) Import base database
section "4. Base Database Import"
if [[ -f "$BASE_SQL_FILE" ]]; then
  info "Importing base database from $BASE_SQL_FILE ..."
  if [[ "$USE_PODMAN" == true ]]; then
    # Disable foreign key checks during import to avoid constraint errors
    (cd "$PROJECT_ROOT" && {
      echo "SET FOREIGN_KEY_CHECKS = 0;"
      cat "$BASE_SQL_FILE"
      echo "SET FOREIGN_KEY_CHECKS = 1;"
    } | podman exec -i zms-db mysql -u root -proot db >/dev/null)
  else
    (cd "$PROJECT_ROOT" && ddev import-db --file="$BASE_SQL_FILE" >/dev/null)
  fi
  info "Base database import completed."
  
  # Log database tables after initial import
  info "Database tables after initial SQL import:"
  if [[ "$USE_PODMAN" == true ]]; then
    (cd "$PROJECT_ROOT" && podman exec -i zms-db mysql -u root -proot db -e "
    SELECT table_name AS 'Table Name', table_rows AS 'Row Count'
    FROM information_schema.tables
    WHERE table_schema = 'db'
    ORDER BY table_name;
  " || true)
  else
    (cd "$PROJECT_ROOT" && ddev exec mysql -udb -pdb db -e "
    SELECT table_name AS 'Table Name', table_rows AS 'Row Count'
    FROM information_schema.tables
    WHERE table_schema = 'db'
    ORDER BY table_name;
  " || true)
  fi
  echo ""
else
  warn "Base SQL file not found at $BASE_SQL_FILE, skipping import."
  echo ""
fi

# 4) Flyway BEFORE PHP migrations
section "5. Flyway Migrations"
# Clear test data migrations from flyway_schema_history after import so they re-run
info "Clearing test data migrations from flyway_schema_history..."
if [[ "$USE_PODMAN" == true ]]; then
  (cd "$PROJECT_ROOT" && podman exec -i zms-db mysql -u root -proot db -e "
    DELETE FROM flyway_schema_history WHERE version > 1;
  " 2>/dev/null || true)
else
  (cd "$PROJECT_ROOT" && ddev exec mysql -udb -pdb db -e "
    DELETE FROM flyway_schema_history WHERE version > 1;
  " 2>/dev/null || true)
fi

info "Running Flyway migrations..."
if [[ "$USE_PODMAN" == true ]]; then
  # Discover the actual podman network used by zms-db
  PODMAN_NETWORK=$(podman inspect -f '{{range $k,$v := .NetworkSettings.Networks}}{{printf "%s" $k}}{{end}}' zms-db 2>/dev/null || true)
  if [[ -z "$PODMAN_NETWORK" ]]; then
    PODMAN_NETWORK="eappointment_devcontainer_default"
  fi

  # Wait for MySQL to be ready inside zms-db (max ~30s)
  info "Waiting for MySQL (zms-db) to become ready..."
  for i in {1..30}; do
    if (cd "$PROJECT_ROOT" && podman exec zms-db sh -lc 'mysqladmin ping -uroot -proot --silent' >/dev/null 2>&1); then
      break
    fi
    sleep 1
  done

  # Run Flyway in a podman container on the discovered network
  FLYWAY_DIR="$PROJECT_ROOT/zmsautomation/flyway"
  # Ensure we have an absolute path
  FLYWAY_DIR=$(cd "$FLYWAY_DIR" 2>/dev/null && pwd || echo "$FLYWAY_DIR")
  if [[ ! -d "$FLYWAY_DIR" ]]; then
    warn "Flyway directory not found: $FLYWAY_DIR"
    warn "Flyway (Podman) skipped; continuing."
  else
    info "Running Flyway via Podman on network ($PODMAN_NETWORK)..."
    podman run --rm \
      --network "$PODMAN_NETWORK" \
      -v "$FLYWAY_DIR:/flyway/sql:ro" \
      docker.io/flyway/flyway:9 \
      -url=jdbc:mysql://db:3306/db -user=root -password=root \
      -locations=filesystem:/flyway/sql \
      -baselineOnMigrate=true \
      migrate || warn "Flyway (Podman) failed; continuing."
  fi
else
  # Try ddev service 'flyway' first (if you add one); otherwise run Flyway via Docker
  if (cd "$PROJECT_ROOT" && ddev exec -s flyway flyway -v >/dev/null 2>&1); then
    info "Using ddev flyway service"
    (cd "$PROJECT_ROOT" && ddev exec -s flyway flyway \
      -url=jdbc:mysql://db:3306/db -user=db -password=db \
      -locations=filesystem:/var/www/html/zmsautomation/flyway \
      -baselineOnMigrate=true migrate)
  else
    # Get ddev network name
    DDEV_NETWORK=$(cd "$PROJECT_ROOT" && ddev describe -j 2>/dev/null | grep -o '"network": "[^"]*"' | cut -d '"' -f4 || echo "ddev_default")
    if [[ -z "$DDEV_NETWORK" ]]; then
      DDEV_NETWORK="ddev_default"
    fi
    
    # Run Flyway in a Docker container on the ddev network
    info "Running Flyway via Docker on ddev network ($DDEV_NETWORK)..."
    docker run --rm \
      --network "$DDEV_NETWORK" \
      -v "$PROJECT_ROOT/zmsautomation/flyway:/flyway/sql" \
      flyway/flyway:9 \
      -url=jdbc:mysql://db:3306/db -user=db -password=db \
      -locations=filesystem:/flyway/sql \
      -baselineOnMigrate=true \
      migrate || warn "Flyway (Docker on ddev network) failed; continuing."
  fi
fi

# Log database tables after Flyway
info "Database tables after Flyway (before PHP migrations):"
if [[ "$USE_PODMAN" == true ]]; then
  (cd "$PROJECT_ROOT" && podman exec -i zms-db mysql -u root -proot db -e "
  SELECT table_name AS 'Table Name', table_rows AS 'Row Count'
  FROM information_schema.tables
  WHERE table_schema = 'db'
  ORDER BY table_name;
" || true)
  else
    (cd "$PROJECT_ROOT" && ddev exec mysql -udb -pdb db -e "
  SELECT table_name AS 'Table Name', table_rows AS 'Row Count'
  FROM information_schema.tables
  WHERE table_schema = 'db'
  ORDER BY table_name;
" || true)
  fi
info "flyway_schema_history (post-flyway):"
if [[ "$USE_PODMAN" == true ]]; then
  (cd "$PROJECT_ROOT" && podman exec -i zms-db mysql -u root -proot db -e "
    SELECT installed_rank, version, description, type, installed_by, success, installed_on
    FROM flyway_schema_history
    ORDER BY installed_rank;
  " || true)
else
  (cd "$PROJECT_ROOT" && ddev exec mysql -udb -pdb db -e "
    SELECT installed_rank, version, description, type, installed_by, success, installed_on
    FROM flyway_schema_history
    ORDER BY installed_rank;
  " || true)
  fi
  echo ""

# 5) Run PHP migrations
section "6. PHP Migrations"
info "Running zmsapi PHP migrations..."
if [[ "$USE_PODMAN" == true ]]; then
  (cd "$PROJECT_ROOT" && podman exec zms-web bash -lc "cd zmsapi && vendor/bin/migrate --update")
else
  (cd "$PROJECT_ROOT" && ddev exec zmsapi/vendor/bin/migrate --update)
fi
info "PHP migrations completed."
echo ""

# Log database tables after PHP migrations
info "Database tables after PHP migrations:"
if [[ "$USE_PODMAN" == true ]]; then
  (cd "$PROJECT_ROOT" && podman exec -i zms-db mysql -u root -proot db -e "
  SELECT table_name AS 'Table Name', table_rows AS 'Row Count'
  FROM information_schema.tables
  WHERE table_schema = 'db'
  ORDER BY table_name;
" || true)
  else
    (cd "$PROJECT_ROOT" && ddev exec mysql -udb -pdb db -e "
  SELECT table_name AS 'Table Name', table_rows AS 'Row Count'
  FROM information_schema.tables
  WHERE table_schema = 'db'
  ORDER BY table_name;
" || true)
  fi
info "flyway_schema_history (post-php-migrations):"
if [[ "$USE_PODMAN" == true ]]; then
  (cd "$PROJECT_ROOT" && podman exec -i zms-db mysql -u root -proot db -e "
    SELECT installed_rank, version, description, type, installed_by, success, installed_on
    FROM flyway_schema_history
    ORDER BY installed_rank;
  " || true)
else
  (cd "$PROJECT_ROOT" && ddev exec mysql -udb -pdb db -e "
    SELECT installed_rank, version, description, type, installed_by, success, installed_on
    FROM flyway_schema_history
    ORDER BY installed_rank;
  " || true)
fi
echo ""

# 6) Run hourly (best-effort)
section "7. Hourly Cronjob"
info "Running hourly (best-effort)..."
if [[ "$USE_PODMAN" == true ]]; then
  if ! (cd "$PROJECT_ROOT" && podman exec zms-web bash -lc "zmsapi/cron/cronjob.hourly --city=munich"); then
    warn "Hourly command failed or not available; continuing."
  else
    info "Hourly command completed."
    
    # Log database tables after hourly
    info "Database tables after hourly cron:"
    (cd "$PROJECT_ROOT" && podman exec -i zms-db mysql -u root -proot db -e "
      SELECT table_name AS 'Table Name', table_rows AS 'Row Count'
      FROM information_schema.tables
      WHERE table_schema = 'db'
      ORDER BY table_name;
    " || true)
  fi
else
  if ! (cd "$PROJECT_ROOT" && ddev exec zmsapi/cron/cronjob.hourly --city=munich); then
    warn "Hourly command failed or not available; continuing."
  else
    info "Hourly command completed."
    
    # Log database tables after hourly
    info "Database tables after hourly cron:"
    (cd "$PROJECT_ROOT" && ddev exec mysql -udb -pdb db -e "
      SELECT table_name AS 'Table Name', table_rows AS 'Row Count'
      FROM information_schema.tables
      WHERE table_schema = 'db'
      ORDER BY table_name;
    " || true)
  fi
fi
echo ""

# 7) Pings for readiness
section "8. Health Checks"
if [[ "$USE_PODMAN" == true ]]; then
  # Note: These pings run from the host, so use localhost with port
  info "Pinging citizenapi: http://localhost:8090/terminvereinbarung/api/citizen/offices-and-services/"
  if curl -sf --max-time 10 "http://localhost:8090/terminvereinbarung/api/citizen/offices-and-services/" >/dev/null; then
    info "✓ citizenapi offices-and-services responding"
  else
    warn "✗ citizenapi offices-and-services NOT responding"
  fi

  info "Pinging zmsapi: http://localhost:8090/terminvereinbarung/api/2/status/"
  if curl -sf --max-time 10 "http://localhost:8090/terminvereinbarung/api/2/status/" >/dev/null; then
    info "✓ zmsapi status responding"
  else
    warn "✗ zmsapi status NOT responding"
  fi
else
  # Note: These pings run from the host, so use zms.ddev.site
  info "Pinging citizenapi: http://zms.ddev.site/terminvereinbarung/api/citizen/offices-and-services/"
  if curl -sf --max-time 10 "http://zms.ddev.site/terminvereinbarung/api/citizen/offices-and-services/" >/dev/null; then
    info "✓ citizenapi offices-and-services responding"
  else
    warn "✗ citizenapi offices-and-services NOT responding"
  fi

  info "Pinging zmsapi: http://zms.ddev.site/terminvereinbarung/api/2/status/"
  if curl -sf --max-time 10 "http://zms.ddev.site/terminvereinbarung/api/2/status/" >/dev/null; then
    info "✓ zmsapi status responding"
  else
    warn "✗ zmsapi status NOT responding"
  fi
fi
echo ""

# 8) Run tests (in a throwaway Maven container, using cached ~/.m2)
section "9. Running Tests"
info "Running REST-assured tests..."
if [[ "$USE_PODMAN" == true ]]; then
  podman volume create "$M2_CACHE_VOLUME" >/dev/null 2>&1 || true
  podman volume create "$TARGET_VOLUME" >/dev/null 2>&1 || true
else
  docker volume create "$M2_CACHE_VOLUME" >/dev/null 2>&1 || true
  docker volume create "$TARGET_VOLUME" >/dev/null 2>&1 || true
fi

if [[ "$USE_PODMAN" == true ]]; then
  # Discover the actual podman network used by zms-db (same logic as Flyway)
  PODMAN_NETWORK=$(podman inspect -f '{{range $k,$v := .NetworkSettings.Networks}}{{printf "%s" $k}}{{end}}' zms-db 2>/dev/null || true)
  if [[ -z "$PODMAN_NETWORK" ]]; then
    PODMAN_NETWORK="eappointment_devcontainer_default"
  fi
  
  # Run tests on podman network so container can reach podman services
  podman run --rm \
    --network "$PODMAN_NETWORK" \
    -e BASE_URI="$BASE_URI" \
    -e CITIZEN_API_BASE_URI="$CITIZEN_API_BASE_URI" \
    -v "$PROJECT_ROOT:/workspace:ro" \
    -v "$M2_CACHE_VOLUME:/root/.m2" \
    -v "$TARGET_VOLUME:/workspace/zmsautomation/target" \
    -w /workspace/zmsautomation \
    "$MAVEN_IMAGE" mvn -B -DtrimStackTrace=false test
else
  # Get ddev network name (same logic as Flyway)
  DDEV_NETWORK=$(cd "$PROJECT_ROOT" && ddev describe -j 2>/dev/null | grep -o '"network": "[^"]*"' | cut -d '"' -f4 || echo "ddev_default")
  if [[ -z "$DDEV_NETWORK" ]]; then
    DDEV_NETWORK="ddev_default"
  fi
  
  # Run tests on ddev network so container can reach ddev services
  docker run --rm \
    --network "$DDEV_NETWORK" \
    -e BASE_URI="$BASE_URI" \
    -e CITIZEN_API_BASE_URI="$CITIZEN_API_BASE_URI" \
    -v "$PROJECT_ROOT:/workspace:ro" \
    -v "$M2_CACHE_VOLUME:/root/.m2" \
    -v "$TARGET_VOLUME:/workspace/zmsautomation/target" \
    -w /workspace/zmsautomation \
    "$MAVEN_IMAGE" mvn -B -DtrimStackTrace=false test
fi

TEST_EXIT=$?
echo ""

# Print surefire reports (if any)
section "10. Test Results"
info "Collecting surefire reports..."
if [[ "$USE_PODMAN" == true ]]; then
  RUNTIME="podman"
else
  RUNTIME="docker"
fi
$RUNTIME run --rm -v "$TARGET_VOLUME:/t" "$ALPINE_IMAGE" sh -lc '
  if [ -d /t/surefire-reports ]; then
    ls -la /t/surefire-reports;
    for f in /t/surefire-reports/*.txt; do
      echo "==== $f ===="; cat "$f"; echo; done || true;
  else
    echo "No surefire-reports found";
  fi'
echo ""

# Clear caches after tests
section "11. Final Cache Clearing"
clear_caches
echo ""

# 9) Restore DB regardless of test result
section "12. Database Restore"
info "Restoring original database..."
restore_db

# Clear test data migrations from flyway_schema_history after restore to keep restored DB clean
info "Clearing test data migrations from flyway_schema_history after restore..."
if [[ "$USE_PODMAN" == true ]]; then
  (cd "$PROJECT_ROOT" && podman exec -i zms-db mysql -u root -proot db -e "
    DELETE FROM flyway_schema_history WHERE version > 1;
  " 2>/dev/null || true)
else
  (cd "$PROJECT_ROOT" && ddev exec mysql -udb -pdb db -e "
    DELETE FROM flyway_schema_history WHERE version > 1;
  " 2>/dev/null || true)
fi
echo ""

# Clean up zmsapi/data folder after tests (preserve .gitignore)
# Note: Cleanup also runs via EXIT trap on error or Ctrl+C
section "13. Cleanup"
info "Cleaning up zmsapi/data folder..."
cleanup_data_folder
info "Cleared zmsapi/data folder (preserved .gitignore)"
echo ""

if [[ $TEST_EXIT -eq 0 ]]; then
  info "Tests completed successfully."
else
  warn "Tests failed (exit $TEST_EXIT)."
fi

# Use return when sourced to avoid closing terminal, exit when executed directly
# Also clear ERR trap when sourced to prevent it from affecting future commands
if [[ "$IS_SOURCED" == true ]]; then
  trap - ERR  # Clear ERR trap to prevent it from affecting future commands
  return "$TEST_EXIT" 2>/dev/null || exit "$TEST_EXIT"
else
  exit "$TEST_EXIT"
fi

