{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","index.js","js/block/periodlist/index.js","js/block/warehousereport/index.js","js/index.js","js/lib/baseview.js","js/lib/bindHandler.js","js/lib/dialogHandler.js","js/lib/exceptionHandler.js","js/lib/utils.js","js/settings.js","node_modules/chart.js/node_modules/chartjs-color/index.js","node_modules/chart.js/node_modules/chartjs-color/node_modules/chartjs-color-string/color-string.js","node_modules/chart.js/node_modules/chartjs-color/node_modules/chartjs-color-string/node_modules/color-name/index.js","node_modules/chart.js/node_modules/chartjs-color/node_modules/color-convert/conversions.js","node_modules/chart.js/node_modules/chartjs-color/node_modules/color-convert/index.js","node_modules/chart.js/src/chart.js","node_modules/chart.js/src/charts/Chart.Bar.js","node_modules/chart.js/src/charts/Chart.Bubble.js","node_modules/chart.js/src/charts/Chart.Doughnut.js","node_modules/chart.js/src/charts/Chart.Line.js","node_modules/chart.js/src/charts/Chart.PolarArea.js","node_modules/chart.js/src/charts/Chart.Radar.js","node_modules/chart.js/src/charts/Chart.Scatter.js","node_modules/chart.js/src/controllers/controller.bar.js","node_modules/chart.js/src/controllers/controller.bubble.js","node_modules/chart.js/src/controllers/controller.doughnut.js","node_modules/chart.js/src/controllers/controller.line.js","node_modules/chart.js/src/controllers/controller.polarArea.js","node_modules/chart.js/src/controllers/controller.radar.js","node_modules/chart.js/src/controllers/controller.scatter.js","node_modules/chart.js/src/core/core.animation.js","node_modules/chart.js/src/core/core.controller.js","node_modules/chart.js/src/core/core.datasetController.js","node_modules/chart.js/src/core/core.defaults.js","node_modules/chart.js/src/core/core.element.js","node_modules/chart.js/src/core/core.helpers.js","node_modules/chart.js/src/core/core.interaction.js","node_modules/chart.js/src/core/core.js","node_modules/chart.js/src/core/core.layouts.js","node_modules/chart.js/src/core/core.plugins.js","node_modules/chart.js/src/core/core.scale.js","node_modules/chart.js/src/core/core.scaleService.js","node_modules/chart.js/src/core/core.ticks.js","node_modules/chart.js/src/core/core.tooltip.js","node_modules/chart.js/src/elements/element.arc.js","node_modules/chart.js/src/elements/element.line.js","node_modules/chart.js/src/elements/element.point.js","node_modules/chart.js/src/elements/element.rectangle.js","node_modules/chart.js/src/elements/index.js","node_modules/chart.js/src/helpers/helpers.canvas.js","node_modules/chart.js/src/helpers/helpers.core.js","node_modules/chart.js/src/helpers/helpers.easing.js","node_modules/chart.js/src/helpers/helpers.options.js","node_modules/chart.js/src/helpers/index.js","node_modules/chart.js/src/platforms/platform.basic.js","node_modules/chart.js/src/platforms/platform.dom.js","node_modules/chart.js/src/platforms/platform.js","node_modules/chart.js/src/plugins/index.js","node_modules/chart.js/src/plugins/plugin.filler.js","node_modules/chart.js/src/plugins/plugin.legend.js","node_modules/chart.js/src/plugins/plugin.title.js","node_modules/chart.js/src/scales/scale.category.js","node_modules/chart.js/src/scales/scale.linear.js","node_modules/chart.js/src/scales/scale.linearbase.js","node_modules/chart.js/src/scales/scale.logarithmic.js","node_modules/chart.js/src/scales/scale.radialLinear.js","node_modules/chart.js/src/scales/scale.time.js","node_modules/moment/locale/de.js","node_modules/moment/moment.js"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","_createClass","defineProperties","target","props","descriptor","key","protoProps","staticProps","_baseview","_baseview2","View","_BaseView","element","options","this","_this","getPrototypeOf","bindEvents","console","log","_this2","$main","off","on","ev","preventDefault","stopPropagation","find","hide","removeClass","../../lib/baseview","2","_chart","_chart2","$","text","data","JSON","parse","attr","renderChartjs","number","list","items","push","label","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","dictionary","Symbol","iterator","next","done","info","variable","err","getLabelInfo","reduce","reduceToField","position","visualization","ylabel","labels","getListByLabel","xlabel","datasets","colorlist","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","datalabel","dataset","description","borderColor","shift","fill","html","css","width","height","$canvas","canvascontext","getContext","type","legend","display","boxWidth","usePointStyle","tooltips","mode","chart.js","3","global","_window","window","_window2","_jquery","_jquery2","_moment","_moment2","_utils","_periodlist","_periodlist2","_warehousereport","_warehousereport2","locale","forceHttps","each","getDataAttributes","./block/periodlist","./block/warehousereport","./lib/utils","babel-polyfill","jquery","moment","moment/locale/de","4","_bindHandler","_bindHandler2","_exceptionHandler","_exceptionHandler2","_dialogHandler","_dialogHandler2","BaseView","_BindHandler","arguments","loadPromise","Promise","reject","noOp","url","method","spinner","loadCallStatic","get","parent","showSpinner","ajaxSettings","resolve","ajax","responseData","fail","isException","responseText","toLowerCase","includes","status","message","hideSpinner","response","_callback","callbackAsBackgroundAction","$container","$loader","loadCall","_lightbox","lightbox","destroyLightbox","lightboxContentElement","callback","loader","handleLightbox","./bindHandler","./dialogHandler","./exceptionHandler","./utils","5","BindHandler","object","_len","methods","Array","_key","forEach","bind","6","_settings","_settings2","DialogHandler","render","hideMessages","content","filter","outerHTML","instant","setTimeout","not","fadeOut","remove","hideMessageTime","../settings","7","ExceptionHandler","closeException","$message","$messageElement","first","prepend","$buttons","append","8","_defineProperty","getUrlParameters","tryJson","deepGet","range","timestampToFloat","timeToFloat","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","isArray","attributesToArray","time","momentTime","hours","minutes","timestamp","start","end","step","result","path","carry","current","attributes","slice","dataRegex","attribute","test","nodeName","map","name","replace","_ref","_ref2","input","lightboxHtml","parentElement","onBackgroundClick","lightboxElement","addClass","document","location","search","split","_current$split","_current$split2","assign","protocol","includeUrl","then","loadDialogStatic","href","substring","./baseview","9","10","convert","string","Color","valid","values","rgb","hsl","hsv","hwb","cmyk","alpha","vals","getRgba","setValues","getHsla","getHwb","red","l","lightness","v","w","whiteness","cyan","isValid","setSpace","rgbArray","hslArray","hsvArray","hwbArray","concat","cmykArray","rgbaArray","hslaArray","val","setChannel","green","blue","hue","saturation","saturationv","blackness","magenta","yellow","black","hexString","rgbString","rgbaString","percentString","hslString","hslaString","hwbString","keyword","rgbNumber","luminosity","lum","chan","Math","pow","contrast","color2","lum1","lum2","level","contrastRatio","dark","yiq","light","negate","lighten","ratio","darken","saturate","desaturate","whiten","blacken","greyscale","clearer","opaquer","rotate","degrees","mix","mixinColor","weight","color1","w1","w2","toJSON","clone","source","prop","hasOwnProperty","toString","error","spaces","maxes","getValues","space","charAt","chans","max","min","capped","round","sname","args","index","svalues","chartjs-color-string","color-convert","11","abbr","hex","rgba","per","match","parseInt","parseFloat","colorNames","scale","h","s","isNaN","b","getRgb","getHsl","hsla","getAlpha","hexDouble","percentaString","g","reverseNames","num","str","toUpperCase","color-name","12","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","blanchedalmond","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellowgreen","13","rgb2hsl","delta","rgb2hsv","rgb2hwb","rgb2cmyk","m","y","k","rgb2keyword","reverseKeywords","stringify","rgb2xyz","x","z","rgb2lab","xyz","rgb2lch","lab2lch","hsl2rgb","t1","t2","t3","hsl2hsv","sv","hsl2hwb","hsl2cmyk","hsl2keyword","hsv2rgb","hi","floor","q","hsv2hsl","sl","hsv2hwb","hsv2cmyk","hsv2keyword","hwb2rgb","wh","bl","hwb2hsl","hwb2hsv","hwb2cmyk","hwb2keyword","cmyk2rgb","cmyk2hsl","cmyk2hsv","cmyk2hwb","cmyk2keyword","xyz2rgb","xyz2lab","xyz2lch","lab2xyz","lab","y2","hr","atan2","PI","sqrt","lab2rgb","lch2lab","lch","cos","sin","lch2xyz","lch2rgb","keyword2rgb","cssKeywords","keyword2hsl","keyword2hsv","keyword2hwb","keyword2cmyk","keyword2lab","keyword2xyz","14","conversions","Converter","func","arg","pair","exec","from","to","convs","routeSpace","fspace","./conversions","15","Chart","helpers","defaults","Element","elements","Interaction","layouts","platform","plugins","Ticks","register","initialize","Legend","_element","Title","title","pluginService","PluginBase","extend","canvasHelpers","canvas","layoutService","./charts/Chart.Bar","./charts/Chart.Bubble","./charts/Chart.Doughnut","./charts/Chart.Line","./charts/Chart.PolarArea","./charts/Chart.Radar","./charts/Chart.Scatter","./controllers/controller.bar","./controllers/controller.bubble","./controllers/controller.doughnut","./controllers/controller.line","./controllers/controller.polarArea","./controllers/controller.radar","./controllers/controller.scatter","./core/core","./core/core.animation","./core/core.controller","./core/core.datasetController","./core/core.defaults","./core/core.element","./core/core.helpers","./core/core.interaction","./core/core.layouts","./core/core.plugins","./core/core.scale","./core/core.scaleService","./core/core.ticks","./core/core.tooltip","./elements/index","./helpers/index","./platforms/platform","./plugins","./scales/scale.category","./scales/scale.linear","./scales/scale.linearbase","./scales/scale.logarithmic","./scales/scale.radialLinear","./scales/scale.time","16","Bar","context","config","17","Bubble","18","Doughnut","19","Line","20","PolarArea","21","Radar","22","Scatter","23","computeMinSampleSize","pixels","prev","curr","ilen","isHorizontal","ticks","getTicks","getPixelForTick","computeFitCategoryTraits","ruler","size","thickness","barThickness","count","stackCount","isNullOrUndef","categoryPercentage","barPercentage","chunk","computeFlexCategoryTraits","percent","_set","hover","scales","xAxes","offset","gridLines","offsetGridLines","yAxes","axis","rectangle","borderSkipped","callbacks","item","yLabel","datasetLabel","datasetIndex","xLabel","controllers","bar","DatasetController","dataElementType","Rectangle","meta","me","apply","getMeta","stack","getDataset","update","reset","rects","_ruler","getRuler","updateElement","chart","custom","rectangleOptions","_xScale","getScaleForId","xAxisID","_yScale","yAxisID","_datasetIndex","_index","_model","backgroundColor","valueAtIndexOrDefault","borderWidth","updateElementGeometry","pivot","model","vscale","getValueScale","base","getBasePixel","horizontal","vpixels","calculateBarValuePixels","ipixels","calculateBarIndexPixels","head","center","getValueScaleId","getIndexScaleId","getIndexScale","_getStacks","last","stacked","stacks","getDatasetMeta","isDatasetVisible","indexOf","getStackCount","getStackIndex","left","top","getPixelForValue","imeta","ivalue","getRightValue","controller","id","stackIndex","valueOrDefault","maxBarThickness","Infinity","draw","clipArea","ctx","chartArea","unclipArea","setHoverStyle","hoverBackgroundColor","getHoverColor","hoverBorderColor","hoverBorderWidth","removeHoverStyle","rectangleElementOptions","horizontalBar","../core/core.defaults","../elements/index","../helpers/index","24","dataPoint","bubble","Point","points","point","xScale","yScale","_resolveElementOptions","dsIndex","getPixelForDecimal","NaN","_options","hitRadius","pointStyle","radius","skip","hoverRadius","dataIndex","keys","25","animation","animateRotate","animateScale","legendCallback","join","generateLabels","ds","arc","arcOpts","stroke","bw","fillStyle","strokeStyle","lineWidth","hidden","onClick","legendItem","cutoutPercentage","rotation","circumference","tooltipItem","dataLabel","doughnut","pie","Arc","linkScales","noop","getRingIndex","ringIndex","j","opts","availableWidth","right","availableHeight","bottom","minSize","startAngle","endAngle","contains0","contains90","contains180","contains270","cutout","getMaxBorderWidth","outerRadius","innerRadius","radiusLength","getVisibleDatasetCount","offsetX","offsetY","total","calculateTotal","animationOpts","centerX","centerY","calculateCircumference","abs","arcs","hoverWidth","26","showLines","spanGaps","lineEnabled","showLine","line","datasetElementType","lineElementOptions","tension","lineTension","_scale","_children","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","steppedLine","stepped","cubicInterpolationMode","updateBezierControlPoints","getPointBackgroundColor","pointBackgroundColor","getPointBorderColor","pointBorderColor","getPointBorderWidth","pointBorderWidth","pointOptions","pointRadius","pointHitRadius","calculatePointY","dsMeta","sumPos","sumNeg","stackedRightValue","Number","rightValue","capControlPoint","pt","controlPoints","area","splineCurveMonotone","splineCurve","previousItem","nextItem","controlPointPreviousX","previous","controlPointPreviousY","controlPointNextX","controlPointNextY","capBezierPoints","pointHoverRadius","pointHoverBackgroundColor","pointHoverBorderColor","pointHoverBorderWidth","27","angleLines","circular","pointLabels","beginAtZero","polarArea","countVisibleElements","xCenter","yCenter","visibleCount","datasetStartAngle","distance","getDistanceFromCenterForValue","resetRadius","28","radar","_loop","pointElementOptions","pointPosition","getPointPositionForValue","29","scatter","30","duration","easing","onProgress","onComplete","Animation","currentStep","numSteps","onAnimationProgress","onAnimationComplete","animationService","frameDuration","animations","dropFrames","request","addAnimation","lazy","animating","requestAnimationFrame","cancelAnimation","findIndex","splice","requestAnimFrame","startDigest","startTime","Date","now","framesToDrop","advance","endTime","set","./core.defaults","./core.element","31","initConfig","configMerge","updateConfig","newOptions","removeBox","ensureScalesHaveIDs","buildOrUpdateScales","tooltip","positionIsHorizontal","types","instances","construct","acquireContext","uid","aspectRatio","_bufferedRender","notify","retinaScale","devicePixelRatio","responsive","resize","initToolTip","clear","stop","silent","maintainAspectRatio","newWidth","getMaximumWidth","newHeight","getMaximumHeight","style","newSize","onResize","responsiveAnimationDuration","scalesOptions","scaleOptions","xAxisOptions","yAxisOptions","updated","dtype","dposition","isDefault","scaleType","scaleClass","scaleService","getScaleConstructor","mergeTicksOptions","hasUpdated","addScalesToLayout","buildOrUpdateControllers","newControllers","destroyDatasetMeta","updateIndex","ControllerClass","resetElements","_invalidate","_data","buildOrUpdateElements","updateLayout","updateDatasets","lastActive","_bufferedRequest","updateDataset","animationOptions","animationObject","easingFunction","effects","stepDecimal","easingValue","transition","boxes","box","drawDatasets","_drawTooltip","drawDataset","getElementAtEvent","modes","single","getElementsAtEvent","intersect","getElementsAtXAxis","getElementsAtEventForMode","getDatasetAtEvent","_meta","generateLegend","destroy","unbindEvents","releaseContext","toBase64Image","toDataURL","Tooltip","_chartInstance","listeners","_listeners","listener","eventHandler","events","addEventListener","removeEventListener","updateHoverStyle","enabled","changed","handleEvent","_start","bufferedRequest","animationDuration","hoverOptions","active","onHover","arrayEquals","Controller","../platforms/platform","./core.interaction","./core.layouts","./core.plugins","32","listenArrayEvents","array","_chartjs","arrayEvents","res","unlistenArrayEvents","stub","addElements","scaleID","createMetaDataset","createMetaData","metaData","addElementAndReset","resyncElements","elementOpts","numMeta","numData","insertElements","onDataPush","onDataPop","pop","onDataShift","onDataSplice","onDataUnshift","inherits","33","scope","merge","34","interpolate","view","ease","actual","origin","c0","c1","color","isFinite","configuration","_view","tooltipPosition","hasValue","isNumber","chartjs-color","35","parseMaxStyle","styleValue","node","parentProperty","valueInPixels","parentNode","isConstrainedValue","getConstraintDimension","domNode","maxStyle","percentageProperty","defaultView","constrainedNode","getComputedStyle","constrainedContainer","hasCNode","hasCContainer","infinity","POSITIVE_INFINITY","merger","tval","sval","scaleMerge","getScaleDefaults","_merger","slen","where","collection","filterCallback","filtered","findNextWhere","arrayToSearch","startIndex","currentItem","findPreviousWhere","almostEquals","epsilon","almostWhole","rounded","NEGATIVE_INFINITY","sign","log10","exponent","LOG10E","powerOf10","isPowerOf10","toRadians","toDegrees","radians","getAngleFromPoint","centrePoint","anglePoint","distanceFromXCenter","distanceFromYCenter","radialDistanceFromCenter","angle","distanceBetweenPoints","pt1","pt2","aliasPixel","pixelWidth","firstPoint","middlePoint","afterPoint","d01","d12","s01","s12","fa","fb","EPSILON","pointBefore","pointCurrent","pointAfter","pointsWithTangents","deltaK","mK","pointsLen","slopeDeltaX","alphaK","betaK","tauK","squaredMagnitude","deltaX","loop","niceNum","niceFraction","fraction","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","getRelativePosition","evt","mouseX","mouseY","originalEvent","currentTarget","srcElement","boundingRect","getBoundingClientRect","touches","clientX","clientY","paddingLeft","getStyle","paddingTop","paddingRight","paddingBottom","currentDevicePixelRatio","getConstraintWidth","getConstraintHeight","container","clientWidth","cw","clientHeight","ch","el","property","currentStyle","getPropertyValue","forceRatio","pixelRatio","fontString","pixelSize","fontStyle","fontFamily","longestText","font","arrayOfThings","cache","gc","garbageCollect","longest","thing","measureText","nestedThing","gcLen","textWidth","numberOfLabelLines","numberOfLines","CanvasGradient","defaultColor","colorValue","CanvasPattern","36","parseVisibleItems","handler","jlen","getIntersectItems","inRange","getNearestItems","distanceMetric","minDistance","nearestItems","getCenterPoint","getDistanceMetricForAxis","useX","useY","deltaY","indexMode","x-axis","nearest","sort","sizeA","getArea","sizeB","ret","intersectsItem","inXRange","inYRange","37","defaultFontColor","defaultFontFamily","defaultFontSize","defaultFontStyle","layout","padding","38","filterByPosition","sortByWeight","reverse","_tmpIndex_","v0","v1","addBox","fullWidth","layoutItem","configure","getMinimumBoxSize","chartWidth","maxChartAreaWidth","horizontalBoxHeight","maxChartAreaHeight","verticalBoxWidth","minBoxSizes","fitBox","minBoxSize","minBox","scaleMargin","totalLeftBoxesWidth","maxHorizontalLeftPadding","totalRightBoxesWidth","maxHorizontalRightPadding","chartHeight","finalFitVerticalBox","totalTopBoxesHeight","totalBottomBoxesHeight","placeBox","leftPadding","rightPadding","layoutOptions","toPadding","topPadding","bottomPadding","leftBoxes","rightBoxes","topBoxes","bottomBoxes","chartAreaBoxes","chartAreaWidth","chartAreaHeight","maxVerticalTopPadding","maxVerticalBottomPadding","horizontalBox","getPadding","boxPadding","verticalBox","leftPaddingAddition","topPaddingAddition","newMaxChartAreaHeight","newMaxChartAreaWidth","39","_plugins","_cacheId","plugin","unregister","idx","getAll","hook","params","descriptors","$plugins","40","labelsFromTicks","getLineValue","lineValue","drawBorder","drawOnChartArea","drawTicks","tickMarkLength","zeroLineWidth","zeroLineColor","zeroLineBorderDash","zeroLineBorderDashOffset","scaleLabel","labelString","lineHeight","minRotation","maxRotation","mirror","autoSkip","autoSkipPadding","labelOffset","formatters","minor","major","computeTextSize","tick","parseFontOptions","globalDefaults","fontSize","family","parseLineHeight","toLineHeight","Scale","_ticks","beforeUpdate","maxWidth","maxHeight","margins","longestTextCache","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","beforeBuildTicks","buildTicks","afterBuildTicks","beforeTickToLabelConversion","convertTicksToLabels","afterTickToLabelConversion","beforeCalculateTickRotation","calculateTickRotation","afterCalculateTickRotation","beforeFit","fit","afterFit","afterUpdate","tickOpts","userCallback","tickFont","labelRotation","cosRotation","sinRotation","originalLabelWidth","labelWidth","tickWidth","angleRadians","scaleLabelOpts","gridLineOpts","isFullWidth","scaleLabelLineHeight","scaleLabelPadding","deltaHeight","largestTextWidth","tallestLabelHeightInLines","lineSpace","tickPadding","longestLabelWidth","labelHeight","firstLabelWidth","lastLabelWidth","handleMargins","rawValue","getLabelForIndex","getValueForPixel","innerWidth","pixel","finalVal","innerHeight","decimal","valueOffset","getBaseValue","_autoSkip","skipRatio","shouldSkip","maxTicks","optionTicks","tickCount","labelRotationRadians","longestRotatedLabel","maxTicksLimit","optionMajorTicks","isRotated","tickFontColor","fontColor","majorTickFontColor","majorTickFont","tl","scaleLabelFontColor","scaleLabelFont","itemsToDraw","axisWidth","xTickStart","xTickEnd","yTickStart","yTickEnd","lineColor","zeroLineIndex","tx1","ty1","tx2","ty2","x1","y1","x2","labelX","labelY","textAlign","textBaseline","labelYOffset","xLineValue","labelXOffset","isLeft","yLineValue","glWidth","glColor","glBorderDash","glBorderDashOffset","itemToDraw","save","setLineDash","lineDashOffset","beginPath","moveTo","lineTo","restore","translate","lineCount","fillText","scaleLabelX","scaleLabelY","halfLineHeight","./core.ticks","41","constructors","registerScaleType","scaleConstructor","scaleDefaults","updateScaleDefaults","additions","42","linear","tickValue","logDelta","tickString","numDecimal","toFixed","logarithmic","remain","toExponential","43","titleFontStyle","titleSpacing","titleMarginBottom","titleFontColor","titleAlign","bodySpacing","bodyFontColor","bodyAlign","footerFontStyle","footerSpacing","footerMarginTop","footerFontColor","footerAlign","yPadding","xPadding","caretPadding","caretSize","cornerRadius","multiKeyBackground","displayColors","beforeTitle","tooltipItems","labelCount","afterTitle","beforeBody","beforeLabel","labelColor","activeElement","labelTextColor","afterLabel","afterBody","beforeFooter","footer","afterFooter","mergeOpacity","colorString","opacity","pushOrConcat","toPush","createTooltipItem","getBaseModel","tooltipOpts","xAlign","yAlign","_bodyFontFamily","bodyFontFamily","_bodyFontStyle","bodyFontStyle","_bodyAlign","bodyFontSize","_titleFontFamily","titleFontFamily","_titleFontStyle","titleFontSize","_titleAlign","_footerFontFamily","footerFontFamily","_footerFontStyle","footerFontSize","_footerAlign","legendColorBackground","getTooltipSize","body","combinedBodyLength","bodyItem","before","lines","after","titleLineCount","footerLineCount","widthPadding","maxLineWidth","determineAlignment","lf","rf","olf","orf","yf","midX","midY","getBackgroundPoint","vm","alignment","paddingAndSize","radiusAndPadding","_lastActive","getTitle","getBeforeBody","getBody","bodyItems","getAfterBody","getFooter","len","existingModel","_active","backgroundPoint","tooltipSize","caretX","caretY","labelColors","labelTextColors","positioners","_eventPosition","itemSort","dataPoints","drawCaret","tooltipPoint","caretPosition","getCaretPosition","x3","y3","ptX","ptY","tmp","drawTitle","drawBody","xLinePadding","fillLineOfText","drawColorBoxes","textColor","fillRect","strokeRect","drawFooter","drawBackground","quadraticCurveTo","closePath","hasTooltipContent","average","pos","eventPosition","nearestElement","d","tp","44","inLabelRange","chartX","chartY","pointRelativePosition","betweenAngles","withinRadius","halfAngle","halfRadius","centreAngle","rangeFromCentre","sA","eA","lineJoin","../core/core.element","45","currentVM","globalOptionLineElements","lastDrawnIndex","lineCap","46","xRange","yRange","errMargin","drawPoint","47","isVertical","getBarBounds","halfWidth","halfHeight","cornerAt","corners","startCorner","signX","signY","barSize","halfStroke","borderLeft","borderRight","borderTop","borderBottom","borders","corner","bounds","48","./element.arc","./element.line","./element.point","./element.rectangle","49","clearRect","roundedRect","rx","ry","rect","edgeLength","xOffset","yOffset","drawImage","SQRT2","leftX","topY","sideSize","clip","flip","bezierCurveTo","drawRoundedRectangle","./helpers.core","50","isObject","defaultValue","fn","thisArg","loopable","a0","a1","klen","_mergerIf","mergeIf","sources","setFn","extensions","ChartElement","Surrogate","__super__","callCallback","fromIndex","getValueOrDefault","getValueAtIndexOrDefault","51","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","asin","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","easeInOutBounce","easingEffects","52","matches","inputs","53","./helpers.canvas","./helpers.easing","./helpers.options","54","55","readUsedSize","initCanvas","renderHeight","getAttribute","renderWidth","EXPANDO_KEY","initial","displayWidth","displayHeight","eventListenerOptions","createEvent","nativeEvent","native","fromNativeEvent","event","EVENT_TYPES","throttled","ticking","createResizer","resizer","createElement","cls","CSS_PREFIX","maxSize","cssText","className","innerHTML","expand","childNodes","shrink","_reset","scrollLeft","scrollTop","onScroll","watchForRender","expando","proxy","renderProxy","animationName","CSS_RENDER_ANIMATION","ANIMATION_START_EVENTS","reflow","offsetParent","classList","add","CSS_RENDER_MONITOR","unwatchForRender","addResizeListener","insertBefore","firstChild","removeResizeListener","removeChild","injectCSS","_style","setAttribute","getElementsByTagName","appendChild","createTextNode","touchstart","touchmove","touchend","pointerenter","pointerdown","pointermove","pointerup","pointerleave","pointerout","supportsEventListenerOptions","supports","passive","_enabled","keyframes","getElementById","removeAttribute","proxies","addEvent","removeEvent","56","basic","dom","implementation","./platform.basic","./platform.dom","57","filler","./plugin.filler","./plugin.legend","./plugin.title","58","decodeFill","computeBoundary","scaleBottom","scaleTop","scaleZero","getBasePosition","resolveTarget","propagate","visited","visible","createMapper","mappers","isDrawable","drawArea","curve0","curve1","len0","len1","doFill","mapper","p0","p1","d0","d1","span","boundary","afterDatasetsUpdate","$filler","beforeDatasetDraw","59","getBoxWidth","labelOpts","createNewLegendAndAttach","legendOpts","ci","lineDash","legendHitBoxes","doughnutMode","beforeBuildLabels","buildLabels","afterBuildLabels","legendItems","globalDefault","labelFont","hitboxes","lineWidths","totalHeight","vPadding","columnWidths","totalWidth","currentColWidth","currentColHeight","itemHeight","itemWidth","lineDefault","legendWidth","cursor","drawLegendBox","isLineWidthZero","offSet","halfFontSize","xLeft","yMiddle","lh","hitBox","beforeInit","afterEvent","../core/core.layouts","60","createNewTitleBlockAndAttach","titleOpts","titleBlock","textSize","titleX","titleY","titleFont","61","defaultConfig","DatasetScale","getLabels","xLabels","yLabels","minIndex","maxIndex","valueCategory","offsetAmt","valueWidth","widthOffset","valueHeight","heightOffset","horz","valueDimension","62","LinearScale","LinearScaleBase","IDMatches","DEFAULT_MIN","DEFAULT_MAX","hasStacks","valuesPerStack","positiveValues","negativeValues","relativePoints","valuesForType","minVal","maxVal","handleTickRangeOptions","getTickLimit","ceil","tickFontSize","handleDirectionalChanges","innerDimension","ticksAsNumbers","../core/core.ticks","63","generateTicks","generationOptions","dataRange","spacing","stepSize","niceRange","niceMin","niceMax","numSpaces","precision","minSign","maxSign","setMin","suggestedMin","setMax","suggestedMax","numericGeneratorOptions","fixedStepSize","64","exp","significand","tickVal","endExp","endSignificand","minNotZero","lastTick","LogarithmicScale","tickValues","_getFirstTickValue","firstTickValue","65","getValueCount","getPointLabelFontOptions","pointLabelOptions","measureLabelSize","determineLimits","fitWithPointLabels","plFont","largestPossibleRadius","furthestLimits","furthestAngles","_pointLabelSizes","valueCount","getPointPosition","getIndexAngle","hLimits","vLimits","setReductions","drawingArea","setCenterPoint","getTextAlignForAngle","adjustPointPositionForLabelHeight","drawPointLabels","angleLineOpts","pointLabelOpts","outerDistance","outerPosition","pointLabelPosition","pointLabelFontColor","drawRadiusLine","numberOrZero","param","animate","showLabelBackdrop","backdropColor","backdropPaddingY","backdropPaddingX","LinearRadialScale","radiusReductionLeft","radiusReductionRight","radiusReductionTop","radiusReductionBottom","leftMovement","rightMovement","topMovement","bottomMovement","maxRight","maxLeft","maxTop","maxBottom","angleMultiplier","startAngleRadians","scalingFactor","distanceFromCenter","thisAngle","tickFontStyle","tickFontFamily","tickLabelFont","yCenterOffset","66","sorter","arrayUnique","hash","out","buildLookupTable","timestamps","distribution","table","lookup","mid","i0","i1","lo","skey","tkey","momentify","parser","format","startOf","valueOf","determineStepSize","unit","capacity","factor","interval","INTERVALS","milliseconds","steps","determineUnitForAutoTicks","minUnit","UNITS","MAX_INTEGER","common","determineUnitForFormatting","diff","as","determineMajorUnit","generate","timeOpts","unitStepSize","weekday","isoWeekday","majorTicksEnabled","computeOffsets","upper","lower","ticksFromTimestamps","majorUnit","determineLabelFormat","momentDate","hasTime","millisecond","second","minute","hour","MIN_INTEGER","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","day","week","month","quarter","year","displayFormat","displayFormats","TimeScale","warn","endOf","_horizontal","_table","_timestamps","getLabelCapacity","_unit","_majorUnit","_offsets","_labelFormat","tooltipFormat","tickFormatFunction","formatOverride","formats","minorFormat","majorFormat","majorTime","majorTickOpts","formatter","getPixelForOffset","getLabelWidth","ticksOpts","tickLabelWidth","exampleTime","exampleLabel","67","factory","define","amd","processRelativeTime","withoutSuffix","isFuture","dd","M","MM","yy","de","defineLocale","months","monthsShort","monthsParseExact","weekdays","weekdaysShort","weekdaysMin","weekdaysParseExact","longDateFormat","LT","LTS","L","LL","LLL","LLLL","calendar","sameDay","sameElse","nextDay","nextWeek","lastDay","lastWeek","relativeTime","future","past","ss","mm","hh","dayOfMonthOrdinalParse","ordinal","dow","doy","../moment","68","hooks","hookCallback","setHookCallback","isObjectEmpty","getOwnPropertyNames","isUndefined","isDate","hasOwnProp","createUTC","strict","createLocalOrUTC","utc","defaultParsingFlags","empty","unusedTokens","unusedInput","overflow","charsLeftOver","nullInput","invalidMonth","invalidFormat","userInvalidated","iso","parsedDateParts","meridiem","rfc2822","weekdayMismatch","getParsingFlags","_pf","_isValid","flags","parsedParts","some","isNowValid","getTime","invalidWeekday","_strict","bigHour","isFrozen","createInvalid","copyConfig","_isAMomentObject","_f","_l","_tzm","_isUTC","_offset","_locale","momentProperties","Moment","updateInProgress","updateOffset","isMoment","absFloor","toInt","argumentForCoercion","coercedNumber","compareArrays","array1","array2","dontConvert","lengthDiff","diffs","msg","suppressDeprecationWarnings","deprecate","firstTime","deprecationHandler","deprecateSimple","deprecations","isFunction","Function","_config","_dayOfMonthOrdinalParseLenient","RegExp","_dayOfMonthOrdinalParse","_ordinalParse","mergeConfigs","parentConfig","childConfig","Locale","mom","output","_calendar","_longDateFormat","formatUpper","invalidDate","_invalidDate","_ordinal","_relativeTime","pastFuture","addUnitAlias","shorthand","lowerCase","aliases","normalizeUnits","units","normalizeObjectUnits","inputObject","normalizedProp","normalizedInput","addUnitPriority","priority","priorities","getPrioritizedUnits","unitsObj","zeroFill","targetLength","forceSign","absNumber","zerosToFill","substr","addFormatToken","token","padded","formatTokenFunctions","localeData","removeFormattingTokens","makeFormatFunction","formattingTokens","formatMoment","expandFormat","formatFunctions","replaceLongDateFormatTokens","localFormattingTokens","lastIndex","addRegexToken","regex","strictRegex","regexes","isStrict","getParseRegexForToken","unescapeFormat","regexEscape","matched","p2","p3","p4","addParseToken","tokens","addWeekParseToken","_w","addTimeToArrayFromToken","_a","daysInYear","isLeapYear","getIsLeapYear","makeGetSet","keepTime","set$1","date","daysInMonth","stringGet","stringSet","prioritized","mod","modMonth","localeMonths","_months","isFormat","MONTHS_IN_FORMAT","localeMonthsShort","_monthsShort","handleStrictParse","monthName","ii","llc","toLocaleLowerCase","_monthsParse","_longMonthsParse","_shortMonthsParse","localeMonthsParse","_monthsParseExact","setMonth","dayOfMonth","monthsParse","getSetMonth","getDaysInMonth","monthsShortRegex","computeMonthsParse","_monthsShortStrictRegex","_monthsShortRegex","defaultMonthsShortRegex","monthsRegex","_monthsStrictRegex","_monthsRegex","defaultMonthsRegex","cmpLenRev","shortPieces","longPieces","mixedPieces","createDate","ms","getFullYear","setFullYear","createUTCDate","UTC","getUTCFullYear","setUTCFullYear","firstWeekOffset","fwd","fwdlw","getUTCDay","dayOfYearFromWeeks","resYear","resDayOfYear","localWeekday","weekOffset","dayOfYear","weekOfYear","resWeek","weeksInYear","weekOffsetNext","localeWeek","_week","localeFirstDayOfWeek","localeFirstDayOfYear","getSetWeek","getSetISOWeek","parseWeekday","weekdaysParse","parseIsoWeekday","localeWeekdays","_weekdays","localeWeekdaysShort","_weekdaysShort","localeWeekdaysMin","_weekdaysMin","handleStrictParse$1","weekdayName","_weekdaysParse","_shortWeekdaysParse","_minWeekdaysParse","localeWeekdaysParse","_weekdaysParseExact","_fullWeekdaysParse","getSetDayOfWeek","getDay","getSetLocaleDayOfWeek","getSetISODayOfWeek","weekdaysRegex","computeWeekdaysParse","_weekdaysStrictRegex","_weekdaysRegex","defaultWeekdaysRegex","weekdaysShortRegex","_weekdaysShortStrictRegex","_weekdaysShortRegex","defaultWeekdaysShortRegex","weekdaysMinRegex","_weekdaysMinStrictRegex","_weekdaysMinRegex","defaultWeekdaysMinRegex","minp","shortp","longp","minPieces","hFormat","kFormat","lowercase","matchMeridiem","_meridiemParse","localeIsPM","localeMeridiem","isLower","normalizeLocale","chooseLocale","names","loadLocale","globalLocale","oldLocale","locales","_abbr","aliasedRequire","getSetGlobalLocale","getLocale","baseConfig","parentLocale","localeFamilies","updateLocale","tmpLocale","listLocales","checkOverflow","MONTH","DATE","YEAR","HOUR","MINUTE","SECOND","MILLISECOND","_overflowDayOfYear","_overflowWeeks","WEEK","_overflowWeekday","WEEKDAY","currentDateArray","nowValue","_useUTC","getUTCMonth","getUTCDate","getMonth","getDate","configFromArray","currentDate","expectedWeekday","yearToUse","dayOfYearFromWeekInfo","_dayOfYear","_nextDay","setUTCMinutes","getUTCMinutes","weekYear","temp","weekdayOverflow","GG","W","E","createLocal","curWeek","gg","configFromISO","allowTime","dateFormat","timeFormat","tzFormat","extendedIsoRegex","basicIsoRegex","isoDates","isoTimes","tzRegex","configFromStringAndFormat","extractFromRFC2822Strings","yearStr","monthStr","dayStr","hourStr","minuteStr","secondStr","untruncateYear","defaultLocaleMonthsShort","preprocessRFC2822","checkWeekday","weekdayStr","parsedInput","weekdayProvided","defaultLocaleWeekdaysShort","weekdayActual","calculateOffset","obsOffset","militaryOffset","numOffset","obsOffsets","hm","configFromRFC2822","parsedArray","configFromString","aspNetJsonRegex","createFromInputFallback","ISO_8601","RFC_2822","skipped","stringLength","totalParsedInputLength","_meridiem","meridiemFixWrap","isPm","meridiemHour","isPM","configFromStringAndArray","tempConfig","bestMoment","scoreToBeat","currentScore","score","configFromObject","createFromConfig","prepareConfig","preparse","configFromInput","isUTC","pickBy","moments","isDurationValid","ordering","unitHasDecimal","isValid$1","createInvalid$1","createDuration","Duration","years","quarters","weeks","days","seconds","_milliseconds","_days","_bubble","isDuration","absRound","separator","utcOffset","offsetFromString","matcher","parts","chunkOffset","cloneWithOffset","setTime","local","getDateOffset","getTimezoneOffset","getSetOffset","keepLocalTime","keepMinutes","localAdjust","matchShortOffset","_changeInProgress","addSubtract","getSetZone","setOffsetToUTC","setOffsetToLocal","subtract","setOffsetToParsedOffset","tZone","matchOffset","hasAlignedHourOffset","isDaylightSavingTime","isDaylightSavingTimeShifted","_isDSTShifted","other","toArray","isLocal","isUtcOffset","isUtc","diffRes","aspNetRegex","isoRegex","parseIso","momentsDifference","inp","positiveMomentsDifference","isAfter","isBefore","createAdder","direction","period","dur","isAdding","getCalendarFormat","myMoment","calendar$1","sod","calendarFormat","localInput","isBetween","inclusivity","isSame","inputMs","isSameOrAfter","isSameOrBefore","asFloat","that","zoneDelta","monthDiff","anchor2","adjust","wholeMonthDiff","anchor","toISOString","keepOffset","toDate","inspect","zone","prefix","datetime","suffix","inputString","defaultFormatUtc","defaultFormat","postformat","humanize","fromNow","toNow","newLocaleData","unix","toObject","isValid$2","parsingFlags","invalidAt","creationData","addWeekYearFormatToken","getter","getSetWeekYear","getSetWeekYearHelper","getSetISOWeekYear","isoWeek","getISOWeeksInYear","getWeeksInYear","weekInfo","weeksTarget","setWeekAll","dayOfYearData","getSetQuarter","getSetDayOfYear","parseMs","getZoneAbbr","getZoneName","createUnix","createInZone","parseZone","preParsePostFormat","get$1","field","setter","listMonthsImpl","listWeekdaysImpl","localeSorted","listMonths","listMonthsShort","listWeekdays","listWeekdaysShort","listWeekdaysMin","mathAbs","addSubtract$1","add$1","subtract$1","absCeil","monthsFromDays","monthsToDays","daysToMonths","valueOf$1","makeAs","alias","clone$1","get$2","makeGetter","substituteTimeAgo","relativeTime$1","posNegDuration","thresholds","getSetRelativeTimeRounding","roundingFunction","getSetRelativeTimeThreshold","threshold","limit","withSuffix","toISOString$1","abs$1","Y","D","asSeconds","totalSign","ymSign","daysSign","hmsSign","fun","defaultCalendar","defaultLongDateFormat","defaultInvalidDate","defaultOrdinal","defaultDayOfMonthOrdinalParse","defaultRelativeTime","match1","match2","match3","match4","match6","match1to2","match3to4","match5to6","match1to3","match1to4","match1to6","matchUnsigned","matchSigned","matchTimestamp","matchWord","parseTwoDigitYear","getSetYear","defaultLocaleMonths","defaultLocaleWeek","defaultLocaleWeekdays","defaultLocaleWeekdaysMin","kInput","_isPm","pos1","pos2","defaultLocaleMeridiemParse","getSetHour","meridiemParse","UT","GMT","EDT","EST","CDT","CST","MDT","MST","PDT","PST","prototypeMin","prototypeMax","invalid","lang","isoWeekYear","getSetDayOfMonth","getSetMinute","getSetSecond","getSetMillisecond","proto","isoWeeks","isoWeeksInYear","isDST","zoneAbbr","zoneName","dates","isDSTShifted","proto$1","firstDayOfYear","firstDayOfWeek","langData","asMilliseconds","asMinutes","asHours","asDays","asWeeks","asMonths","asYears","proto$2","toIsoString","version","relativeTimeRounding","relativeTimeThreshold","HTML5_FMT","DATETIME_LOCAL","DATETIME_LOCAL_SECONDS","DATETIME_LOCAL_MS","TIME","TIME_SECONDS","TIME_MS"],"mappings":"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","file":"index.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _baseview = require('../../lib/baseview');\n\nvar _baseview2 = _interopRequireDefault(_baseview);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar View = function (_BaseView) {\n    _inherits(View, _BaseView);\n\n    function View(element, options) {\n        _classCallCheck(this, View);\n\n        var _this = _possibleConstructorReturn(this, (View.__proto__ || Object.getPrototypeOf(View)).call(this, element, options));\n\n        _this.bindEvents();\n        console.log('Component: Periodlist', _this, options);\n        return _this;\n    }\n\n    _createClass(View, [{\n        key: 'bindEvents',\n        value: function bindEvents() {\n            var _this2 = this;\n\n            this.$main.off('click').on('click', '.report-period--show-all', function (ev) {\n                ev.preventDefault();\n                ev.stopPropagation();\n                _this2.$main.find('.report-period--show-all').hide();\n                _this2.$main.find(\".report-period--table tr\").removeClass('hide');\n            });\n        }\n    }]);\n\n    return View;\n}(_baseview2.default);\n\nexports.default = View;\n\n},{\"../../lib/baseview\":4}],2:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _baseview = require(\"../../lib/baseview\");\n\nvar _baseview2 = _interopRequireDefault(_baseview);\n\nvar _chart = require(\"chart.js\");\n\nvar _chart2 = _interopRequireDefault(_chart);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar View = function (_BaseView) {\n    _inherits(View, _BaseView);\n\n    function View(element, options) {\n        _classCallCheck(this, View);\n\n        var _this = _possibleConstructorReturn(this, (View.__proto__ || Object.getPrototypeOf(View)).call(this, element, options));\n\n        _this.bindEvents();\n        console.log('Component: Warehouse report', _this, options);\n        _this.$.find(\".chartist\").text('[Initializing chart...]');\n        _this.data = JSON.parse(_this.$.find(\".chartist\").attr('data-chartist'));\n        _this.$.find(\".chartist\").attr('data-chartist', '');\n        //this.renderChartist(data);\n        _this.renderChartjs();\n        return _this;\n    }\n\n    _createClass(View, [{\n        key: \"bindEvents\",\n        value: function bindEvents() {\n            //this.$main.off('click').on('click', '.report-period--show-all', (ev) => {\n            //    ev.preventDefault();\n            //    ev.stopPropagation();\n            //    this.$main.find('.report-period--show-all').hide();\n            //    this.$main.find(\".report-period--table tr\").removeClass('hide');\n            //})\n        }\n    }, {\n        key: \"reduceToField\",\n        value: function reduceToField(number) {\n            return function (list, items) {\n                list.push(items[number]);\n                return list;\n            };\n        }\n    }, {\n        key: \"getLabelInfo\",\n        value: function getLabelInfo(label) {\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = this.data.dictionary[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var info = _step.value;\n\n                    if (info.variable == label) {\n                        return info;\n                    }\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            throw \"WarehouseReport: Label \" + label + \" not found\";\n        }\n    }, {\n        key: \"getListByLabel\",\n        value: function getListByLabel(label) {\n            var info = this.getLabelInfo(label);\n            var list = this.data.data.reduce(this.reduceToField(info.position), []);\n            return list;\n        }\n    }, {\n        key: \"renderChartjs\",\n        value: function renderChartjs() {\n            console.log(this.data);\n            console.log(this.data.visualization.ylabel);\n            var labels = this.getListByLabel(this.data.visualization.xlabel[0]);\n            var datasets = [];\n            var colorlist = ['#008cca', '#ffacaa', '#d0eaca', '#c2c2c2', '#efc10f'];\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = this.data.visualization.ylabel[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var datalabel = _step2.value;\n\n                    var dataset = {};\n                    console.log(datalabel);\n                    dataset.label = this.getLabelInfo(datalabel).description;\n                    dataset.data = this.getListByLabel(datalabel);\n                    dataset.borderColor = colorlist.shift();\n                    dataset.fill = false;\n                    datasets.push(dataset);\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            this.$.find(\".chartist\").html('<canvas></canvas>&nbsp;');\n            this.$.find(\".chartist\").css({\n                \"position\": \"relative\",\n                \"width\": \"100%\",\n                \"height\": \"550px\"\n            });\n            var $canvas = this.$.find(\".chartist canvas\");\n            var canvascontext = $canvas[0].getContext('2d');\n            console.log(datasets);\n            new _chart2.default(canvascontext, {\n                type: 'line',\n                data: {\n                    labels: labels,\n                    datasets: datasets\n                },\n                options: {\n                    legend: {\n                        display: true,\n                        labels: {\n                            boxWidth: 12,\n                            usePointStyle: false\n                        }\n                    },\n                    tooltips: {\n                        mode: \"index\"\n                    }\n                }\n            });\n        }\n    }]);\n\n    return View;\n}(_baseview2.default);\n\nexports.default = View;\n\n},{\"../../lib/baseview\":4,\"chart.js\":15}],3:[function(require,module,exports){\n(function (global){\n\"use strict\";\n\nrequire(\"babel-polyfill\");\n\nvar _window = (typeof window !== \"undefined\" ? window['window'] : typeof global !== \"undefined\" ? global['window'] : null);\n\nvar _window2 = _interopRequireDefault(_window);\n\nvar _jquery = require(\"jquery\");\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _moment = require(\"moment\");\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nrequire(\"moment/locale/de\");\n\nvar _utils = require(\"./lib/utils\");\n\nvar _periodlist = require(\"./block/periodlist\");\n\nvar _periodlist2 = _interopRequireDefault(_periodlist);\n\nvar _warehousereport = require(\"./block/warehousereport\");\n\nvar _warehousereport2 = _interopRequireDefault(_warehousereport);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Bind jQuery on $ for testing\n\n//import bindReact from './lib/bindReact.js'\n\n\n// Import base libs\n_window2.default.$ = _jquery2.default; // --------------------------------------------------------\n// ZMS Statistic behavior\n// --------------------------------------------------------\n\n_moment2.default.locale('de');\n\n// Force https protocol\n(0, _utils.forceHttps)();\n\n// Say hello\nconsole.log(\"Welcome to the ZMS statistics interface...\");\n\n(0, _jquery2.default)('.report-period').each(function () {\n    new _periodlist2.default(this, (0, _utils.getDataAttributes)(this));\n});\n\n(0, _jquery2.default)('.warehouse-report').each(function () {\n    new _warehousereport2.default(this, (0, _utils.getDataAttributes)(this));\n});\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./block/periodlist\":1,\"./block/warehousereport\":2,\"./lib/utils\":8,\"babel-polyfill\":\"babel-polyfill\",\"jquery\":\"jquery\",\"moment\":\"moment\",\"moment/locale/de\":67}],4:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _jquery = require(\"jquery\");\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _bindHandler = require(\"./bindHandler\");\n\nvar _bindHandler2 = _interopRequireDefault(_bindHandler);\n\nvar _exceptionHandler = require(\"./exceptionHandler\");\n\nvar _exceptionHandler2 = _interopRequireDefault(_exceptionHandler);\n\nvar _dialogHandler = require(\"./dialogHandler\");\n\nvar _dialogHandler2 = _interopRequireDefault(_dialogHandler);\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar BaseView = function (_BindHandler) {\n    _inherits(BaseView, _BindHandler);\n\n    function BaseView(element) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, BaseView);\n\n        var _this = _possibleConstructorReturn(this, (BaseView.__proto__ || Object.getPrototypeOf(BaseView)).call(this));\n\n        _this.$main = (0, _jquery2.default)(element);\n        _this.$main.off();\n        _this.options = options;\n        _this.loadPromise = Promise.reject(null).catch(_utils.noOp);\n        return _this;\n    }\n\n    _createClass(BaseView, [{\n        key: \"loadCall\",\n        value: function loadCall(url) {\n            var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'GET';\n            var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n            var spinner = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n            return BaseView.loadCallStatic(url, method, data, spinner, this);\n        }\n    }, {\n        key: \"$\",\n        get: function get() {\n            return this.$main;\n        }\n    }], [{\n        key: \"loadCallStatic\",\n        value: function loadCallStatic(url) {\n            var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'GET';\n            var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n            var spinner = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n            var parent = arguments[4];\n\n            if (spinner) {\n                (0, _utils.showSpinner)(parent.$main);\n            }\n            var ajaxSettings = {\n                method: method\n            };\n            if (method === 'POST' || method === 'PUT') {\n                ajaxSettings.data = data;\n            }\n            return new Promise(function (resolve, reject) {\n                _jquery2.default.ajax(url, ajaxSettings).done(function (responseData) {\n                    resolve(responseData);\n                }).fail(function (err) {\n                    var isException = err.responseText.toLowerCase().includes('exception');\n                    if (err.status >= 400 && isException) {\n                        new _exceptionHandler2.default(parent.$main, {\n                            code: err.status,\n                            message: err.responseText,\n                            parent: parent\n                        });\n                        (0, _utils.hideSpinner)(parent.$main);\n                    } else {\n                        console.log('XHR load error', url, err);\n                        reject(err);\n                    }\n                });\n            });\n        }\n    }, {\n        key: \"loadDialogStatic\",\n        value: function loadDialogStatic(response, _callback, parent) {\n            var callbackAsBackgroundAction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n            var $container = null;\n            var $loader = null;\n            if (parent) {\n                $container = parent.$main;\n                $loader = parent.loadCall;\n            }\n\n            var _lightbox = (0, _utils.lightbox)($container, function () {\n                destroyLightbox(), callbackAsBackgroundAction ? _callback() : function () {};\n            }),\n                lightboxContentElement = _lightbox.lightboxContentElement,\n                destroyLightbox = _lightbox.destroyLightbox;\n\n            new _dialogHandler2.default(lightboxContentElement, {\n                response: response,\n                callback: function callback() {\n                    _callback();\n                    destroyLightbox();\n                },\n                parent: parent,\n                loader: $loader,\n                handleLightbox: destroyLightbox\n            });\n        }\n    }]);\n\n    return BaseView;\n}(_bindHandler2.default);\n\nexports.default = BaseView;\n\n},{\"./bindHandler\":5,\"./dialogHandler\":6,\"./exceptionHandler\":7,\"./utils\":8,\"jquery\":\"jquery\"}],5:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar BindHandler = function () {\n    function BindHandler() {\n        _classCallCheck(this, BindHandler);\n    }\n\n    _createClass(BindHandler, [{\n        key: \"bindPublicMethods\",\n        value: function bindPublicMethods() {\n            var object = this;\n\n            for (var _len = arguments.length, methods = Array(_len), _key = 0; _key < _len; _key++) {\n                methods[_key] = arguments[_key];\n            }\n\n            methods.forEach(function (method) {\n                if (typeof object[method] !== 'function') {\n                    throw \"Method not found: \" + method;\n                }\n                object[method] = object[method].bind(object);\n            });\n        }\n    }]);\n\n    return BindHandler;\n}();\n\nexports.default = BindHandler;\n\n},{}],6:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _jquery = require('jquery');\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _exceptionHandler = require('./exceptionHandler');\n\nvar _exceptionHandler2 = _interopRequireDefault(_exceptionHandler);\n\nvar _settings = require('../settings');\n\nvar _settings2 = _interopRequireDefault(_settings);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DialogHandler = function () {\n    function DialogHandler(element, options) {\n        _classCallCheck(this, DialogHandler);\n\n        this.$main = (0, _jquery2.default)(element);\n        this.response = options.response;\n        this.callback = options.callback || function () {};\n        this.parent = options.parent;\n        this.loader = options.loader || function () {};\n        this.handleLightbox = options.handleLightbox || function () {};\n        this.bindEvents();\n        this.render();\n    }\n\n    _createClass(DialogHandler, [{\n        key: 'render',\n        value: function render() {\n            DialogHandler.hideMessages(true);\n            var content = (0, _jquery2.default)(this.response).filter('div.dialog');\n            if (content.length == 0) {\n                var message = (0, _jquery2.default)(this.response).find('div.dialog');\n                if (message.length > 0) {\n                    content = message.get(0).outerHTML;\n                }\n            }\n            if (content.length == 0) {\n                new _exceptionHandler2.default(this.$main, { 'message': this.response });\n            } else {\n                this.$main.html(content);\n            }\n        }\n    }, {\n        key: 'bindEvents',\n        value: function bindEvents() {\n            var _this = this;\n\n            this.$main.off().on('click', '.button-ok', function (ev) {\n                ev.preventDefault();\n                ev.stopPropagation();\n                _this.callback(ev);\n            }).on('click', '.button-abort', function (ev) {\n                ev.preventDefault();\n                ev.stopPropagation();\n                _this.handleLightbox();\n            }).on('click', '.button-callback', function (ev) {\n                ev.preventDefault();\n                ev.stopPropagation();\n                var callback = (0, _jquery2.default)(ev.target).data('callback');\n                _this.callback = _this.parent[callback];\n                _this.callback(ev);\n            });\n        }\n    }], [{\n        key: 'hideMessages',\n        value: function hideMessages() {\n            var instant = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var message = _jquery2.default.find('.message, .dialog');\n            if (message.length && !instant) {\n                setTimeout(function () {\n                    (0, _jquery2.default)(message).not('.message-keep').fadeOut().remove();\n                }, _settings2.default.hideMessageTime * 1000);\n            } else if (message.length && instant) {\n                (0, _jquery2.default)(message).not('.message-keep').fadeOut().remove();\n            }\n        }\n    }]);\n\n    return DialogHandler;\n}();\n\nexports.default = DialogHandler;\n\n},{\"../settings\":9,\"./exceptionHandler\":7,\"jquery\":\"jquery\"}],7:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _jquery = require('jquery');\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ExceptionHandler = function () {\n    function ExceptionHandler(element, options) {\n        _classCallCheck(this, ExceptionHandler);\n\n        this.$main = (0, _jquery2.default)(element);\n        this.message = options.message;\n        this.parent = options.parent || this.$main;\n        this.code = options.code;\n        this.callback = options.callback || this.closeException;\n        this.bindEvents();\n        this.render();\n    }\n\n    _createClass(ExceptionHandler, [{\n        key: 'render',\n        value: function render() {\n            var _this = this;\n\n            var $message = (0, _jquery2.default)(this.message).filter('div.exception');\n            if ($message.length == 0) {\n                $message = (0, _jquery2.default)(this.message).find('div.exception');\n            }\n\n            this.$messageElement = (0, _jquery2.default)($message.get(0).outerHTML);\n            this.$main.find('.dialog', '.exception').remove();\n            this.$main.find('.body').first().prepend(this.$messageElement);\n            var $buttons = this.$messageElement.find('.btn');\n            if ($buttons.length == 0) {\n                $buttons = (0, _jquery2.default)('<a class=\"btn button-cancel right\">X</a>');\n                this.$messageElement.find('.header').append($buttons);\n            }\n            $buttons.on('click', function (ev) {\n                ev.preventDefault();\n                ev.stopPropagation();\n                var callback = (0, _jquery2.default)(ev.target).data('callback');\n                if (_this.parent[callback]) _this.callback = _this.parent[callback];\n                _this.callback(ev);\n            });\n            /*setTimeout(() => {\n                this.closeException();\n            },8000)\n            */\n        }\n    }, {\n        key: 'closeException',\n        value: function closeException() {\n            if (this.$messageElement) {\n                this.$messageElement.remove();\n            }\n        }\n    }, {\n        key: 'bindEvents',\n        value: function bindEvents() {}\n    }]);\n\n    return ExceptionHandler;\n}();\n\nexports.default = ExceptionHandler;\n\n},{\"jquery\":\"jquery\"}],8:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.forceHttps = exports.getUrlParameters = exports.noOp = exports.lightbox = exports.tryJson = exports.getDataAttributes = exports.deepGet = exports.range = exports.timestampToFloat = exports.timeToFloat = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _baseview = require('./baseview');\n\nvar _baseview2 = _interopRequireDefault(_baseview);\n\nvar _jquery = require('jquery');\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _moment = require('moment');\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _settings = require('../settings');\n\nvar _settings2 = _interopRequireDefault(_settings);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar timeToFloat = exports.timeToFloat = function timeToFloat(time) {\n    var momentTime = (0, _moment2.default)(time, 'HH:mm:ss');\n\n    return momentTime.hours() + momentTime.minutes() / 60;\n};\n\nvar timestampToFloat = exports.timestampToFloat = function timestampToFloat(timestamp) {\n    var momentTime = (0, _moment2.default)(timestamp, 'X');\n\n    return momentTime.hours() + momentTime.minutes() / 60;\n};\n\nvar range = exports.range = function range(start, end) {\n    var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n    var result = [];\n    for (var i = start; i <= end; i += step) {\n        result.push(i);\n    }\n\n    return result;\n};\n\nvar deepGet = exports.deepGet = function deepGet(obj) {\n    var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return path.reduce(function (carry, current) {\n        return carry ? carry[current] : undefined;\n    }, obj);\n};\n\nvar attributesToArray = function attributesToArray(attributes) {\n    return Array.prototype.slice.call(attributes, 0);\n};\n\nvar getDataAttributes = exports.getDataAttributes = function getDataAttributes(element) {\n    var attributes = attributesToArray(element.attributes);\n    var dataRegex = /^data-/i;\n\n    return attributes.filter(function (attribute) {\n        return dataRegex.test(attribute.nodeName);\n    }).map(function (attribute) {\n        return [attribute.name.replace(dataRegex, ''), attribute.value];\n    }).reduce(function (carry, _ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            key = _ref2[0],\n            value = _ref2[1];\n\n        carry[key] = tryJson(value);\n        return carry;\n    }, {});\n};\n\nvar tryJson = exports.tryJson = function tryJson(input) {\n    try {\n        return JSON.parse(input);\n    } catch (e) {\n        return input;\n    }\n};\n\nvar lightboxHtml = '<div class=\"lightbox\"><div class=\"lightbox__content\"></div></div>';\n\nvar lightbox = exports.lightbox = function lightbox(parentElement, onBackgroundClick) {\n    var lightboxElement = (0, _jquery2.default)(lightboxHtml);\n\n    if (!parentElement) {\n        parentElement = (0, _jquery2.default)('body');\n        lightboxElement.addClass('fixed');\n    }\n\n    var destroyLightbox = function destroyLightbox() {\n        lightboxElement.off();\n        lightboxElement.remove();\n    };\n\n    var lightboxContentElement = lightboxElement.find('.lightbox__content');\n\n    lightboxElement.on('click', function (ev) {\n        console.log('background click', ev);\n        ev.stopPropagation();\n        ev.preventDefault();\n        destroyLightbox();\n        onBackgroundClick();\n    }).on('click', '.lightbox__content', function (ev) {\n        ev.stopPropagation();\n    });\n\n    (0, _jquery2.default)(parentElement).append(lightboxElement);\n\n    return {\n        lightboxContentElement: lightboxContentElement,\n        destroyLightbox: destroyLightbox\n    };\n};\n\nvar noOp = exports.noOp = function noOp() {};\n\nvar getUrlParameters = exports.getUrlParameters = function getUrlParameters() {\n    return document.location.search.replace(/^\\?/, \"\").split(\"&\").reduce(function (carry, current) {\n        var _current$split = current.split('='),\n            _current$split2 = _slicedToArray(_current$split, 2),\n            key = _current$split2[0],\n            value = _current$split2[1];\n\n        if (key) {\n            return Object.assign({}, carry, _defineProperty({}, key, value));\n        } else {\n            return carry;\n        }\n    }, {});\n};\n\nvar forceHttps = exports.forceHttps = function forceHttps() {\n    if (document.location.protocol !== \"https:\") {\n        _baseview2.default.loadCallStatic(_settings2.default.includeUrl + '/dialog/?template=force_https').then(function (response) {\n            _baseview2.default.loadDialogStatic(response, function () {\n                document.location.href = \"https://\" + document.location.href.substring(document.location.protocol.length, document.location.href.length);\n            }, _baseview2.default, true);\n        });\n    }\n};\n\n},{\"../settings\":9,\"./baseview\":4,\"jquery\":\"jquery\",\"moment\":\"moment\"}],9:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = {\n    'includeUrl': '/terminvereinbarung/statistic'\n};\n\n},{}],10:[function(require,module,exports){\n/* MIT license */\nvar convert = require('color-convert');\nvar string = require('chartjs-color-string');\n\nvar Color = function (obj) {\n\tif (obj instanceof Color) {\n\t\treturn obj;\n\t}\n\tif (!(this instanceof Color)) {\n\t\treturn new Color(obj);\n\t}\n\n\tthis.valid = false;\n\tthis.values = {\n\t\trgb: [0, 0, 0],\n\t\thsl: [0, 0, 0],\n\t\thsv: [0, 0, 0],\n\t\thwb: [0, 0, 0],\n\t\tcmyk: [0, 0, 0, 0],\n\t\talpha: 1\n\t};\n\n\t// parse Color() argument\n\tvar vals;\n\tif (typeof obj === 'string') {\n\t\tvals = string.getRgba(obj);\n\t\tif (vals) {\n\t\t\tthis.setValues('rgb', vals);\n\t\t} else if (vals = string.getHsla(obj)) {\n\t\t\tthis.setValues('hsl', vals);\n\t\t} else if (vals = string.getHwb(obj)) {\n\t\t\tthis.setValues('hwb', vals);\n\t\t}\n\t} else if (typeof obj === 'object') {\n\t\tvals = obj;\n\t\tif (vals.r !== undefined || vals.red !== undefined) {\n\t\t\tthis.setValues('rgb', vals);\n\t\t} else if (vals.l !== undefined || vals.lightness !== undefined) {\n\t\t\tthis.setValues('hsl', vals);\n\t\t} else if (vals.v !== undefined || vals.value !== undefined) {\n\t\t\tthis.setValues('hsv', vals);\n\t\t} else if (vals.w !== undefined || vals.whiteness !== undefined) {\n\t\t\tthis.setValues('hwb', vals);\n\t\t} else if (vals.c !== undefined || vals.cyan !== undefined) {\n\t\t\tthis.setValues('cmyk', vals);\n\t\t}\n\t}\n};\n\nColor.prototype = {\n\tisValid: function () {\n\t\treturn this.valid;\n\t},\n\trgb: function () {\n\t\treturn this.setSpace('rgb', arguments);\n\t},\n\thsl: function () {\n\t\treturn this.setSpace('hsl', arguments);\n\t},\n\thsv: function () {\n\t\treturn this.setSpace('hsv', arguments);\n\t},\n\thwb: function () {\n\t\treturn this.setSpace('hwb', arguments);\n\t},\n\tcmyk: function () {\n\t\treturn this.setSpace('cmyk', arguments);\n\t},\n\n\trgbArray: function () {\n\t\treturn this.values.rgb;\n\t},\n\thslArray: function () {\n\t\treturn this.values.hsl;\n\t},\n\thsvArray: function () {\n\t\treturn this.values.hsv;\n\t},\n\thwbArray: function () {\n\t\tvar values = this.values;\n\t\tif (values.alpha !== 1) {\n\t\t\treturn values.hwb.concat([values.alpha]);\n\t\t}\n\t\treturn values.hwb;\n\t},\n\tcmykArray: function () {\n\t\treturn this.values.cmyk;\n\t},\n\trgbaArray: function () {\n\t\tvar values = this.values;\n\t\treturn values.rgb.concat([values.alpha]);\n\t},\n\thslaArray: function () {\n\t\tvar values = this.values;\n\t\treturn values.hsl.concat([values.alpha]);\n\t},\n\talpha: function (val) {\n\t\tif (val === undefined) {\n\t\t\treturn this.values.alpha;\n\t\t}\n\t\tthis.setValues('alpha', val);\n\t\treturn this;\n\t},\n\n\tred: function (val) {\n\t\treturn this.setChannel('rgb', 0, val);\n\t},\n\tgreen: function (val) {\n\t\treturn this.setChannel('rgb', 1, val);\n\t},\n\tblue: function (val) {\n\t\treturn this.setChannel('rgb', 2, val);\n\t},\n\thue: function (val) {\n\t\tif (val) {\n\t\t\tval %= 360;\n\t\t\tval = val < 0 ? 360 + val : val;\n\t\t}\n\t\treturn this.setChannel('hsl', 0, val);\n\t},\n\tsaturation: function (val) {\n\t\treturn this.setChannel('hsl', 1, val);\n\t},\n\tlightness: function (val) {\n\t\treturn this.setChannel('hsl', 2, val);\n\t},\n\tsaturationv: function (val) {\n\t\treturn this.setChannel('hsv', 1, val);\n\t},\n\twhiteness: function (val) {\n\t\treturn this.setChannel('hwb', 1, val);\n\t},\n\tblackness: function (val) {\n\t\treturn this.setChannel('hwb', 2, val);\n\t},\n\tvalue: function (val) {\n\t\treturn this.setChannel('hsv', 2, val);\n\t},\n\tcyan: function (val) {\n\t\treturn this.setChannel('cmyk', 0, val);\n\t},\n\tmagenta: function (val) {\n\t\treturn this.setChannel('cmyk', 1, val);\n\t},\n\tyellow: function (val) {\n\t\treturn this.setChannel('cmyk', 2, val);\n\t},\n\tblack: function (val) {\n\t\treturn this.setChannel('cmyk', 3, val);\n\t},\n\n\thexString: function () {\n\t\treturn string.hexString(this.values.rgb);\n\t},\n\trgbString: function () {\n\t\treturn string.rgbString(this.values.rgb, this.values.alpha);\n\t},\n\trgbaString: function () {\n\t\treturn string.rgbaString(this.values.rgb, this.values.alpha);\n\t},\n\tpercentString: function () {\n\t\treturn string.percentString(this.values.rgb, this.values.alpha);\n\t},\n\thslString: function () {\n\t\treturn string.hslString(this.values.hsl, this.values.alpha);\n\t},\n\thslaString: function () {\n\t\treturn string.hslaString(this.values.hsl, this.values.alpha);\n\t},\n\thwbString: function () {\n\t\treturn string.hwbString(this.values.hwb, this.values.alpha);\n\t},\n\tkeyword: function () {\n\t\treturn string.keyword(this.values.rgb, this.values.alpha);\n\t},\n\n\trgbNumber: function () {\n\t\tvar rgb = this.values.rgb;\n\t\treturn (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];\n\t},\n\n\tluminosity: function () {\n\t\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\n\t\tvar rgb = this.values.rgb;\n\t\tvar lum = [];\n\t\tfor (var i = 0; i < rgb.length; i++) {\n\t\t\tvar chan = rgb[i] / 255;\n\t\t\tlum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);\n\t\t}\n\t\treturn 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n\t},\n\n\tcontrast: function (color2) {\n\t\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n\t\tvar lum1 = this.luminosity();\n\t\tvar lum2 = color2.luminosity();\n\t\tif (lum1 > lum2) {\n\t\t\treturn (lum1 + 0.05) / (lum2 + 0.05);\n\t\t}\n\t\treturn (lum2 + 0.05) / (lum1 + 0.05);\n\t},\n\n\tlevel: function (color2) {\n\t\tvar contrastRatio = this.contrast(color2);\n\t\tif (contrastRatio >= 7.1) {\n\t\t\treturn 'AAA';\n\t\t}\n\n\t\treturn (contrastRatio >= 4.5) ? 'AA' : '';\n\t},\n\n\tdark: function () {\n\t\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\n\t\tvar rgb = this.values.rgb;\n\t\tvar yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\n\t\treturn yiq < 128;\n\t},\n\n\tlight: function () {\n\t\treturn !this.dark();\n\t},\n\n\tnegate: function () {\n\t\tvar rgb = [];\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\trgb[i] = 255 - this.values.rgb[i];\n\t\t}\n\t\tthis.setValues('rgb', rgb);\n\t\treturn this;\n\t},\n\n\tlighten: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[2] += hsl[2] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tdarken: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[2] -= hsl[2] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tsaturate: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[1] += hsl[1] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tdesaturate: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[1] -= hsl[1] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\twhiten: function (ratio) {\n\t\tvar hwb = this.values.hwb;\n\t\thwb[1] += hwb[1] * ratio;\n\t\tthis.setValues('hwb', hwb);\n\t\treturn this;\n\t},\n\n\tblacken: function (ratio) {\n\t\tvar hwb = this.values.hwb;\n\t\thwb[2] += hwb[2] * ratio;\n\t\tthis.setValues('hwb', hwb);\n\t\treturn this;\n\t},\n\n\tgreyscale: function () {\n\t\tvar rgb = this.values.rgb;\n\t\t// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n\t\tvar val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n\t\tthis.setValues('rgb', [val, val, val]);\n\t\treturn this;\n\t},\n\n\tclearer: function (ratio) {\n\t\tvar alpha = this.values.alpha;\n\t\tthis.setValues('alpha', alpha - (alpha * ratio));\n\t\treturn this;\n\t},\n\n\topaquer: function (ratio) {\n\t\tvar alpha = this.values.alpha;\n\t\tthis.setValues('alpha', alpha + (alpha * ratio));\n\t\treturn this;\n\t},\n\n\trotate: function (degrees) {\n\t\tvar hsl = this.values.hsl;\n\t\tvar hue = (hsl[0] + degrees) % 360;\n\t\thsl[0] = hue < 0 ? 360 + hue : hue;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\t/**\n\t * Ported from sass implementation in C\n\t * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\n\t */\n\tmix: function (mixinColor, weight) {\n\t\tvar color1 = this;\n\t\tvar color2 = mixinColor;\n\t\tvar p = weight === undefined ? 0.5 : weight;\n\n\t\tvar w = 2 * p - 1;\n\t\tvar a = color1.alpha() - color2.alpha();\n\n\t\tvar w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n\t\tvar w2 = 1 - w1;\n\n\t\treturn this\n\t\t\t.rgb(\n\t\t\t\tw1 * color1.red() + w2 * color2.red(),\n\t\t\t\tw1 * color1.green() + w2 * color2.green(),\n\t\t\t\tw1 * color1.blue() + w2 * color2.blue()\n\t\t\t)\n\t\t\t.alpha(color1.alpha() * p + color2.alpha() * (1 - p));\n\t},\n\n\ttoJSON: function () {\n\t\treturn this.rgb();\n\t},\n\n\tclone: function () {\n\t\t// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,\n\t\t// making the final build way to big to embed in Chart.js. So let's do it manually,\n\t\t// assuming that values to clone are 1 dimension arrays containing only numbers,\n\t\t// except 'alpha' which is a number.\n\t\tvar result = new Color();\n\t\tvar source = this.values;\n\t\tvar target = result.values;\n\t\tvar value, type;\n\n\t\tfor (var prop in source) {\n\t\t\tif (source.hasOwnProperty(prop)) {\n\t\t\t\tvalue = source[prop];\n\t\t\t\ttype = ({}).toString.call(value);\n\t\t\t\tif (type === '[object Array]') {\n\t\t\t\t\ttarget[prop] = value.slice(0);\n\t\t\t\t} else if (type === '[object Number]') {\n\t\t\t\t\ttarget[prop] = value;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error('unexpected color value:', value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n};\n\nColor.prototype.spaces = {\n\trgb: ['red', 'green', 'blue'],\n\thsl: ['hue', 'saturation', 'lightness'],\n\thsv: ['hue', 'saturation', 'value'],\n\thwb: ['hue', 'whiteness', 'blackness'],\n\tcmyk: ['cyan', 'magenta', 'yellow', 'black']\n};\n\nColor.prototype.maxes = {\n\trgb: [255, 255, 255],\n\thsl: [360, 100, 100],\n\thsv: [360, 100, 100],\n\thwb: [360, 100, 100],\n\tcmyk: [100, 100, 100, 100]\n};\n\nColor.prototype.getValues = function (space) {\n\tvar values = this.values;\n\tvar vals = {};\n\n\tfor (var i = 0; i < space.length; i++) {\n\t\tvals[space.charAt(i)] = values[space][i];\n\t}\n\n\tif (values.alpha !== 1) {\n\t\tvals.a = values.alpha;\n\t}\n\n\t// {r: 255, g: 255, b: 255, a: 0.4}\n\treturn vals;\n};\n\nColor.prototype.setValues = function (space, vals) {\n\tvar values = this.values;\n\tvar spaces = this.spaces;\n\tvar maxes = this.maxes;\n\tvar alpha = 1;\n\tvar i;\n\n\tthis.valid = true;\n\n\tif (space === 'alpha') {\n\t\talpha = vals;\n\t} else if (vals.length) {\n\t\t// [10, 10, 10]\n\t\tvalues[space] = vals.slice(0, space.length);\n\t\talpha = vals[space.length];\n\t} else if (vals[space.charAt(0)] !== undefined) {\n\t\t// {r: 10, g: 10, b: 10}\n\t\tfor (i = 0; i < space.length; i++) {\n\t\t\tvalues[space][i] = vals[space.charAt(i)];\n\t\t}\n\n\t\talpha = vals.a;\n\t} else if (vals[spaces[space][0]] !== undefined) {\n\t\t// {red: 10, green: 10, blue: 10}\n\t\tvar chans = spaces[space];\n\n\t\tfor (i = 0; i < space.length; i++) {\n\t\t\tvalues[space][i] = vals[chans[i]];\n\t\t}\n\n\t\talpha = vals.alpha;\n\t}\n\n\tvalues.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));\n\n\tif (space === 'alpha') {\n\t\treturn false;\n\t}\n\n\tvar capped;\n\n\t// cap values of the space prior converting all values\n\tfor (i = 0; i < space.length; i++) {\n\t\tcapped = Math.max(0, Math.min(maxes[space][i], values[space][i]));\n\t\tvalues[space][i] = Math.round(capped);\n\t}\n\n\t// convert to all the other color spaces\n\tfor (var sname in spaces) {\n\t\tif (sname !== space) {\n\t\t\tvalues[sname] = convert[space][sname](values[space]);\n\t\t}\n\t}\n\n\treturn true;\n};\n\nColor.prototype.setSpace = function (space, args) {\n\tvar vals = args[0];\n\n\tif (vals === undefined) {\n\t\t// color.rgb()\n\t\treturn this.getValues(space);\n\t}\n\n\t// color.rgb(10, 10, 10)\n\tif (typeof vals === 'number') {\n\t\tvals = Array.prototype.slice.call(args);\n\t}\n\n\tthis.setValues(space, vals);\n\treturn this;\n};\n\nColor.prototype.setChannel = function (space, index, val) {\n\tvar svalues = this.values[space];\n\tif (val === undefined) {\n\t\t// color.red()\n\t\treturn svalues[index];\n\t} else if (val === svalues[index]) {\n\t\t// color.red(color.red())\n\t\treturn this;\n\t}\n\n\t// color.red(100)\n\tsvalues[index] = val;\n\tthis.setValues(space, svalues);\n\n\treturn this;\n};\n\nif (typeof window !== 'undefined') {\n\twindow.Color = Color;\n}\n\nmodule.exports = Color;\n\n},{\"chartjs-color-string\":11,\"color-convert\":14}],11:[function(require,module,exports){\n/* MIT license */\nvar colorNames = require('color-name');\n\nmodule.exports = {\n   getRgba: getRgba,\n   getHsla: getHsla,\n   getRgb: getRgb,\n   getHsl: getHsl,\n   getHwb: getHwb,\n   getAlpha: getAlpha,\n\n   hexString: hexString,\n   rgbString: rgbString,\n   rgbaString: rgbaString,\n   percentString: percentString,\n   percentaString: percentaString,\n   hslString: hslString,\n   hslaString: hslaString,\n   hwbString: hwbString,\n   keyword: keyword\n}\n\nfunction getRgba(string) {\n   if (!string) {\n      return;\n   }\n   var abbr =  /^#([a-fA-F0-9]{3})$/i,\n       hex =  /^#([a-fA-F0-9]{6})$/i,\n       rgba = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/i,\n       per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/i,\n       keyword = /(\\w+)/;\n\n   var rgb = [0, 0, 0],\n       a = 1,\n       match = string.match(abbr);\n   if (match) {\n      match = match[1];\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = parseInt(match[i] + match[i], 16);\n      }\n   }\n   else if (match = string.match(hex)) {\n      match = match[1];\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);\n      }\n   }\n   else if (match = string.match(rgba)) {\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = parseInt(match[i + 1]);\n      }\n      a = parseFloat(match[4]);\n   }\n   else if (match = string.match(per)) {\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\n      }\n      a = parseFloat(match[4]);\n   }\n   else if (match = string.match(keyword)) {\n      if (match[1] == \"transparent\") {\n         return [0, 0, 0, 0];\n      }\n      rgb = colorNames[match[1]];\n      if (!rgb) {\n         return;\n      }\n   }\n\n   for (var i = 0; i < rgb.length; i++) {\n      rgb[i] = scale(rgb[i], 0, 255);\n   }\n   if (!a && a != 0) {\n      a = 1;\n   }\n   else {\n      a = scale(a, 0, 1);\n   }\n   rgb[3] = a;\n   return rgb;\n}\n\nfunction getHsla(string) {\n   if (!string) {\n      return;\n   }\n   var hsl = /^hsla?\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n   var match = string.match(hsl);\n   if (match) {\n      var alpha = parseFloat(match[4]);\n      var h = scale(parseInt(match[1]), 0, 360),\n          s = scale(parseFloat(match[2]), 0, 100),\n          l = scale(parseFloat(match[3]), 0, 100),\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\n      return [h, s, l, a];\n   }\n}\n\nfunction getHwb(string) {\n   if (!string) {\n      return;\n   }\n   var hwb = /^hwb\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n   var match = string.match(hwb);\n   if (match) {\n    var alpha = parseFloat(match[4]);\n      var h = scale(parseInt(match[1]), 0, 360),\n          w = scale(parseFloat(match[2]), 0, 100),\n          b = scale(parseFloat(match[3]), 0, 100),\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\n      return [h, w, b, a];\n   }\n}\n\nfunction getRgb(string) {\n   var rgba = getRgba(string);\n   return rgba && rgba.slice(0, 3);\n}\n\nfunction getHsl(string) {\n  var hsla = getHsla(string);\n  return hsla && hsla.slice(0, 3);\n}\n\nfunction getAlpha(string) {\n   var vals = getRgba(string);\n   if (vals) {\n      return vals[3];\n   }\n   else if (vals = getHsla(string)) {\n      return vals[3];\n   }\n   else if (vals = getHwb(string)) {\n      return vals[3];\n   }\n}\n\n// generators\nfunction hexString(rgb) {\n   return \"#\" + hexDouble(rgb[0]) + hexDouble(rgb[1])\n              + hexDouble(rgb[2]);\n}\n\nfunction rgbString(rgba, alpha) {\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\n      return rgbaString(rgba, alpha);\n   }\n   return \"rgb(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2] + \")\";\n}\n\nfunction rgbaString(rgba, alpha) {\n   if (alpha === undefined) {\n      alpha = (rgba[3] !== undefined ? rgba[3] : 1);\n   }\n   return \"rgba(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2]\n           + \", \" + alpha + \")\";\n}\n\nfunction percentString(rgba, alpha) {\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\n      return percentaString(rgba, alpha);\n   }\n   var r = Math.round(rgba[0]/255 * 100),\n       g = Math.round(rgba[1]/255 * 100),\n       b = Math.round(rgba[2]/255 * 100);\n\n   return \"rgb(\" + r + \"%, \" + g + \"%, \" + b + \"%)\";\n}\n\nfunction percentaString(rgba, alpha) {\n   var r = Math.round(rgba[0]/255 * 100),\n       g = Math.round(rgba[1]/255 * 100),\n       b = Math.round(rgba[2]/255 * 100);\n   return \"rgba(\" + r + \"%, \" + g + \"%, \" + b + \"%, \" + (alpha || rgba[3] || 1) + \")\";\n}\n\nfunction hslString(hsla, alpha) {\n   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {\n      return hslaString(hsla, alpha);\n   }\n   return \"hsl(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%)\";\n}\n\nfunction hslaString(hsla, alpha) {\n   if (alpha === undefined) {\n      alpha = (hsla[3] !== undefined ? hsla[3] : 1);\n   }\n   return \"hsla(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%, \"\n           + alpha + \")\";\n}\n\n// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\n// (hwb have alpha optional & 1 is default value)\nfunction hwbString(hwb, alpha) {\n   if (alpha === undefined) {\n      alpha = (hwb[3] !== undefined ? hwb[3] : 1);\n   }\n   return \"hwb(\" + hwb[0] + \", \" + hwb[1] + \"%, \" + hwb[2] + \"%\"\n           + (alpha !== undefined && alpha !== 1 ? \", \" + alpha : \"\") + \")\";\n}\n\nfunction keyword(rgb) {\n  return reverseNames[rgb.slice(0, 3)];\n}\n\n// helpers\nfunction scale(num, min, max) {\n   return Math.min(Math.max(min, num), max);\n}\n\nfunction hexDouble(num) {\n  var str = num.toString(16).toUpperCase();\n  return (str.length < 2) ? \"0\" + str : str;\n}\n\n\n//create a list of reverse color names\nvar reverseNames = {};\nfor (var name in colorNames) {\n   reverseNames[colorNames[name]] = name;\n}\n\n},{\"color-name\":12}],12:[function(require,module,exports){\n'use strict'\r\n\r\nmodule.exports = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\r\n\n},{}],13:[function(require,module,exports){\n/* MIT license */\n\nmodule.exports = {\n  rgb2hsl: rgb2hsl,\n  rgb2hsv: rgb2hsv,\n  rgb2hwb: rgb2hwb,\n  rgb2cmyk: rgb2cmyk,\n  rgb2keyword: rgb2keyword,\n  rgb2xyz: rgb2xyz,\n  rgb2lab: rgb2lab,\n  rgb2lch: rgb2lch,\n\n  hsl2rgb: hsl2rgb,\n  hsl2hsv: hsl2hsv,\n  hsl2hwb: hsl2hwb,\n  hsl2cmyk: hsl2cmyk,\n  hsl2keyword: hsl2keyword,\n\n  hsv2rgb: hsv2rgb,\n  hsv2hsl: hsv2hsl,\n  hsv2hwb: hsv2hwb,\n  hsv2cmyk: hsv2cmyk,\n  hsv2keyword: hsv2keyword,\n\n  hwb2rgb: hwb2rgb,\n  hwb2hsl: hwb2hsl,\n  hwb2hsv: hwb2hsv,\n  hwb2cmyk: hwb2cmyk,\n  hwb2keyword: hwb2keyword,\n\n  cmyk2rgb: cmyk2rgb,\n  cmyk2hsl: cmyk2hsl,\n  cmyk2hsv: cmyk2hsv,\n  cmyk2hwb: cmyk2hwb,\n  cmyk2keyword: cmyk2keyword,\n\n  keyword2rgb: keyword2rgb,\n  keyword2hsl: keyword2hsl,\n  keyword2hsv: keyword2hsv,\n  keyword2hwb: keyword2hwb,\n  keyword2cmyk: keyword2cmyk,\n  keyword2lab: keyword2lab,\n  keyword2xyz: keyword2xyz,\n\n  xyz2rgb: xyz2rgb,\n  xyz2lab: xyz2lab,\n  xyz2lch: xyz2lch,\n\n  lab2xyz: lab2xyz,\n  lab2rgb: lab2rgb,\n  lab2lch: lab2lch,\n\n  lch2lab: lch2lab,\n  lch2xyz: lch2xyz,\n  lch2rgb: lch2rgb\n}\n\n\nfunction rgb2hsl(rgb) {\n  var r = rgb[0]/255,\n      g = rgb[1]/255,\n      b = rgb[2]/255,\n      min = Math.min(r, g, b),\n      max = Math.max(r, g, b),\n      delta = max - min,\n      h, s, l;\n\n  if (max == min)\n    h = 0;\n  else if (r == max)\n    h = (g - b) / delta;\n  else if (g == max)\n    h = 2 + (b - r) / delta;\n  else if (b == max)\n    h = 4 + (r - g)/ delta;\n\n  h = Math.min(h * 60, 360);\n\n  if (h < 0)\n    h += 360;\n\n  l = (min + max) / 2;\n\n  if (max == min)\n    s = 0;\n  else if (l <= 0.5)\n    s = delta / (max + min);\n  else\n    s = delta / (2 - max - min);\n\n  return [h, s * 100, l * 100];\n}\n\nfunction rgb2hsv(rgb) {\n  var r = rgb[0],\n      g = rgb[1],\n      b = rgb[2],\n      min = Math.min(r, g, b),\n      max = Math.max(r, g, b),\n      delta = max - min,\n      h, s, v;\n\n  if (max == 0)\n    s = 0;\n  else\n    s = (delta/max * 1000)/10;\n\n  if (max == min)\n    h = 0;\n  else if (r == max)\n    h = (g - b) / delta;\n  else if (g == max)\n    h = 2 + (b - r) / delta;\n  else if (b == max)\n    h = 4 + (r - g) / delta;\n\n  h = Math.min(h * 60, 360);\n\n  if (h < 0)\n    h += 360;\n\n  v = ((max / 255) * 1000) / 10;\n\n  return [h, s, v];\n}\n\nfunction rgb2hwb(rgb) {\n  var r = rgb[0],\n      g = rgb[1],\n      b = rgb[2],\n      h = rgb2hsl(rgb)[0],\n      w = 1/255 * Math.min(r, Math.min(g, b)),\n      b = 1 - 1/255 * Math.max(r, Math.max(g, b));\n\n  return [h, w * 100, b * 100];\n}\n\nfunction rgb2cmyk(rgb) {\n  var r = rgb[0] / 255,\n      g = rgb[1] / 255,\n      b = rgb[2] / 255,\n      c, m, y, k;\n\n  k = Math.min(1 - r, 1 - g, 1 - b);\n  c = (1 - r - k) / (1 - k) || 0;\n  m = (1 - g - k) / (1 - k) || 0;\n  y = (1 - b - k) / (1 - k) || 0;\n  return [c * 100, m * 100, y * 100, k * 100];\n}\n\nfunction rgb2keyword(rgb) {\n  return reverseKeywords[JSON.stringify(rgb)];\n}\n\nfunction rgb2xyz(rgb) {\n  var r = rgb[0] / 255,\n      g = rgb[1] / 255,\n      b = rgb[2] / 255;\n\n  // assume sRGB\n  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n  return [x * 100, y *100, z * 100];\n}\n\nfunction rgb2lab(rgb) {\n  var xyz = rgb2xyz(rgb),\n        x = xyz[0],\n        y = xyz[1],\n        z = xyz[2],\n        l, a, b;\n\n  x /= 95.047;\n  y /= 100;\n  z /= 108.883;\n\n  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\n  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\n  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\n\n  l = (116 * y) - 16;\n  a = 500 * (x - y);\n  b = 200 * (y - z);\n\n  return [l, a, b];\n}\n\nfunction rgb2lch(args) {\n  return lab2lch(rgb2lab(args));\n}\n\nfunction hsl2rgb(hsl) {\n  var h = hsl[0] / 360,\n      s = hsl[1] / 100,\n      l = hsl[2] / 100,\n      t1, t2, t3, rgb, val;\n\n  if (s == 0) {\n    val = l * 255;\n    return [val, val, val];\n  }\n\n  if (l < 0.5)\n    t2 = l * (1 + s);\n  else\n    t2 = l + s - l * s;\n  t1 = 2 * l - t2;\n\n  rgb = [0, 0, 0];\n  for (var i = 0; i < 3; i++) {\n    t3 = h + 1 / 3 * - (i - 1);\n    t3 < 0 && t3++;\n    t3 > 1 && t3--;\n\n    if (6 * t3 < 1)\n      val = t1 + (t2 - t1) * 6 * t3;\n    else if (2 * t3 < 1)\n      val = t2;\n    else if (3 * t3 < 2)\n      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n    else\n      val = t1;\n\n    rgb[i] = val * 255;\n  }\n\n  return rgb;\n}\n\nfunction hsl2hsv(hsl) {\n  var h = hsl[0],\n      s = hsl[1] / 100,\n      l = hsl[2] / 100,\n      sv, v;\n\n  if(l === 0) {\n      // no need to do calc on black\n      // also avoids divide by 0 error\n      return [0, 0, 0];\n  }\n\n  l *= 2;\n  s *= (l <= 1) ? l : 2 - l;\n  v = (l + s) / 2;\n  sv = (2 * s) / (l + s);\n  return [h, sv * 100, v * 100];\n}\n\nfunction hsl2hwb(args) {\n  return rgb2hwb(hsl2rgb(args));\n}\n\nfunction hsl2cmyk(args) {\n  return rgb2cmyk(hsl2rgb(args));\n}\n\nfunction hsl2keyword(args) {\n  return rgb2keyword(hsl2rgb(args));\n}\n\n\nfunction hsv2rgb(hsv) {\n  var h = hsv[0] / 60,\n      s = hsv[1] / 100,\n      v = hsv[2] / 100,\n      hi = Math.floor(h) % 6;\n\n  var f = h - Math.floor(h),\n      p = 255 * v * (1 - s),\n      q = 255 * v * (1 - (s * f)),\n      t = 255 * v * (1 - (s * (1 - f))),\n      v = 255 * v;\n\n  switch(hi) {\n    case 0:\n      return [v, t, p];\n    case 1:\n      return [q, v, p];\n    case 2:\n      return [p, v, t];\n    case 3:\n      return [p, q, v];\n    case 4:\n      return [t, p, v];\n    case 5:\n      return [v, p, q];\n  }\n}\n\nfunction hsv2hsl(hsv) {\n  var h = hsv[0],\n      s = hsv[1] / 100,\n      v = hsv[2] / 100,\n      sl, l;\n\n  l = (2 - s) * v;\n  sl = s * v;\n  sl /= (l <= 1) ? l : 2 - l;\n  sl = sl || 0;\n  l /= 2;\n  return [h, sl * 100, l * 100];\n}\n\nfunction hsv2hwb(args) {\n  return rgb2hwb(hsv2rgb(args))\n}\n\nfunction hsv2cmyk(args) {\n  return rgb2cmyk(hsv2rgb(args));\n}\n\nfunction hsv2keyword(args) {\n  return rgb2keyword(hsv2rgb(args));\n}\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nfunction hwb2rgb(hwb) {\n  var h = hwb[0] / 360,\n      wh = hwb[1] / 100,\n      bl = hwb[2] / 100,\n      ratio = wh + bl,\n      i, v, f, n;\n\n  // wh + bl cant be > 1\n  if (ratio > 1) {\n    wh /= ratio;\n    bl /= ratio;\n  }\n\n  i = Math.floor(6 * h);\n  v = 1 - bl;\n  f = 6 * h - i;\n  if ((i & 0x01) != 0) {\n    f = 1 - f;\n  }\n  n = wh + f * (v - wh);  // linear interpolation\n\n  switch (i) {\n    default:\n    case 6:\n    case 0: r = v; g = n; b = wh; break;\n    case 1: r = n; g = v; b = wh; break;\n    case 2: r = wh; g = v; b = n; break;\n    case 3: r = wh; g = n; b = v; break;\n    case 4: r = n; g = wh; b = v; break;\n    case 5: r = v; g = wh; b = n; break;\n  }\n\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction hwb2hsl(args) {\n  return rgb2hsl(hwb2rgb(args));\n}\n\nfunction hwb2hsv(args) {\n  return rgb2hsv(hwb2rgb(args));\n}\n\nfunction hwb2cmyk(args) {\n  return rgb2cmyk(hwb2rgb(args));\n}\n\nfunction hwb2keyword(args) {\n  return rgb2keyword(hwb2rgb(args));\n}\n\nfunction cmyk2rgb(cmyk) {\n  var c = cmyk[0] / 100,\n      m = cmyk[1] / 100,\n      y = cmyk[2] / 100,\n      k = cmyk[3] / 100,\n      r, g, b;\n\n  r = 1 - Math.min(1, c * (1 - k) + k);\n  g = 1 - Math.min(1, m * (1 - k) + k);\n  b = 1 - Math.min(1, y * (1 - k) + k);\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction cmyk2hsl(args) {\n  return rgb2hsl(cmyk2rgb(args));\n}\n\nfunction cmyk2hsv(args) {\n  return rgb2hsv(cmyk2rgb(args));\n}\n\nfunction cmyk2hwb(args) {\n  return rgb2hwb(cmyk2rgb(args));\n}\n\nfunction cmyk2keyword(args) {\n  return rgb2keyword(cmyk2rgb(args));\n}\n\n\nfunction xyz2rgb(xyz) {\n  var x = xyz[0] / 100,\n      y = xyz[1] / 100,\n      z = xyz[2] / 100,\n      r, g, b;\n\n  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n  // assume sRGB\n  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n    : r = (r * 12.92);\n\n  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n    : g = (g * 12.92);\n\n  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n    : b = (b * 12.92);\n\n  r = Math.min(Math.max(0, r), 1);\n  g = Math.min(Math.max(0, g), 1);\n  b = Math.min(Math.max(0, b), 1);\n\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction xyz2lab(xyz) {\n  var x = xyz[0],\n      y = xyz[1],\n      z = xyz[2],\n      l, a, b;\n\n  x /= 95.047;\n  y /= 100;\n  z /= 108.883;\n\n  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\n  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\n  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\n\n  l = (116 * y) - 16;\n  a = 500 * (x - y);\n  b = 200 * (y - z);\n\n  return [l, a, b];\n}\n\nfunction xyz2lch(args) {\n  return lab2lch(xyz2lab(args));\n}\n\nfunction lab2xyz(lab) {\n  var l = lab[0],\n      a = lab[1],\n      b = lab[2],\n      x, y, z, y2;\n\n  if (l <= 8) {\n    y = (l * 100) / 903.3;\n    y2 = (7.787 * (y / 100)) + (16 / 116);\n  } else {\n    y = 100 * Math.pow((l + 16) / 116, 3);\n    y2 = Math.pow(y / 100, 1/3);\n  }\n\n  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);\n\n  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);\n\n  return [x, y, z];\n}\n\nfunction lab2lch(lab) {\n  var l = lab[0],\n      a = lab[1],\n      b = lab[2],\n      hr, h, c;\n\n  hr = Math.atan2(b, a);\n  h = hr * 360 / 2 / Math.PI;\n  if (h < 0) {\n    h += 360;\n  }\n  c = Math.sqrt(a * a + b * b);\n  return [l, c, h];\n}\n\nfunction lab2rgb(args) {\n  return xyz2rgb(lab2xyz(args));\n}\n\nfunction lch2lab(lch) {\n  var l = lch[0],\n      c = lch[1],\n      h = lch[2],\n      a, b, hr;\n\n  hr = h / 360 * 2 * Math.PI;\n  a = c * Math.cos(hr);\n  b = c * Math.sin(hr);\n  return [l, a, b];\n}\n\nfunction lch2xyz(args) {\n  return lab2xyz(lch2lab(args));\n}\n\nfunction lch2rgb(args) {\n  return lab2rgb(lch2lab(args));\n}\n\nfunction keyword2rgb(keyword) {\n  return cssKeywords[keyword];\n}\n\nfunction keyword2hsl(args) {\n  return rgb2hsl(keyword2rgb(args));\n}\n\nfunction keyword2hsv(args) {\n  return rgb2hsv(keyword2rgb(args));\n}\n\nfunction keyword2hwb(args) {\n  return rgb2hwb(keyword2rgb(args));\n}\n\nfunction keyword2cmyk(args) {\n  return rgb2cmyk(keyword2rgb(args));\n}\n\nfunction keyword2lab(args) {\n  return rgb2lab(keyword2rgb(args));\n}\n\nfunction keyword2xyz(args) {\n  return rgb2xyz(keyword2rgb(args));\n}\n\nvar cssKeywords = {\n  aliceblue:  [240,248,255],\n  antiquewhite: [250,235,215],\n  aqua: [0,255,255],\n  aquamarine: [127,255,212],\n  azure:  [240,255,255],\n  beige:  [245,245,220],\n  bisque: [255,228,196],\n  black:  [0,0,0],\n  blanchedalmond: [255,235,205],\n  blue: [0,0,255],\n  blueviolet: [138,43,226],\n  brown:  [165,42,42],\n  burlywood:  [222,184,135],\n  cadetblue:  [95,158,160],\n  chartreuse: [127,255,0],\n  chocolate:  [210,105,30],\n  coral:  [255,127,80],\n  cornflowerblue: [100,149,237],\n  cornsilk: [255,248,220],\n  crimson:  [220,20,60],\n  cyan: [0,255,255],\n  darkblue: [0,0,139],\n  darkcyan: [0,139,139],\n  darkgoldenrod:  [184,134,11],\n  darkgray: [169,169,169],\n  darkgreen:  [0,100,0],\n  darkgrey: [169,169,169],\n  darkkhaki:  [189,183,107],\n  darkmagenta:  [139,0,139],\n  darkolivegreen: [85,107,47],\n  darkorange: [255,140,0],\n  darkorchid: [153,50,204],\n  darkred:  [139,0,0],\n  darksalmon: [233,150,122],\n  darkseagreen: [143,188,143],\n  darkslateblue:  [72,61,139],\n  darkslategray:  [47,79,79],\n  darkslategrey:  [47,79,79],\n  darkturquoise:  [0,206,209],\n  darkviolet: [148,0,211],\n  deeppink: [255,20,147],\n  deepskyblue:  [0,191,255],\n  dimgray:  [105,105,105],\n  dimgrey:  [105,105,105],\n  dodgerblue: [30,144,255],\n  firebrick:  [178,34,34],\n  floralwhite:  [255,250,240],\n  forestgreen:  [34,139,34],\n  fuchsia:  [255,0,255],\n  gainsboro:  [220,220,220],\n  ghostwhite: [248,248,255],\n  gold: [255,215,0],\n  goldenrod:  [218,165,32],\n  gray: [128,128,128],\n  green:  [0,128,0],\n  greenyellow:  [173,255,47],\n  grey: [128,128,128],\n  honeydew: [240,255,240],\n  hotpink:  [255,105,180],\n  indianred:  [205,92,92],\n  indigo: [75,0,130],\n  ivory:  [255,255,240],\n  khaki:  [240,230,140],\n  lavender: [230,230,250],\n  lavenderblush:  [255,240,245],\n  lawngreen:  [124,252,0],\n  lemonchiffon: [255,250,205],\n  lightblue:  [173,216,230],\n  lightcoral: [240,128,128],\n  lightcyan:  [224,255,255],\n  lightgoldenrodyellow: [250,250,210],\n  lightgray:  [211,211,211],\n  lightgreen: [144,238,144],\n  lightgrey:  [211,211,211],\n  lightpink:  [255,182,193],\n  lightsalmon:  [255,160,122],\n  lightseagreen:  [32,178,170],\n  lightskyblue: [135,206,250],\n  lightslategray: [119,136,153],\n  lightslategrey: [119,136,153],\n  lightsteelblue: [176,196,222],\n  lightyellow:  [255,255,224],\n  lime: [0,255,0],\n  limegreen:  [50,205,50],\n  linen:  [250,240,230],\n  magenta:  [255,0,255],\n  maroon: [128,0,0],\n  mediumaquamarine: [102,205,170],\n  mediumblue: [0,0,205],\n  mediumorchid: [186,85,211],\n  mediumpurple: [147,112,219],\n  mediumseagreen: [60,179,113],\n  mediumslateblue:  [123,104,238],\n  mediumspringgreen:  [0,250,154],\n  mediumturquoise:  [72,209,204],\n  mediumvioletred:  [199,21,133],\n  midnightblue: [25,25,112],\n  mintcream:  [245,255,250],\n  mistyrose:  [255,228,225],\n  moccasin: [255,228,181],\n  navajowhite:  [255,222,173],\n  navy: [0,0,128],\n  oldlace:  [253,245,230],\n  olive:  [128,128,0],\n  olivedrab:  [107,142,35],\n  orange: [255,165,0],\n  orangered:  [255,69,0],\n  orchid: [218,112,214],\n  palegoldenrod:  [238,232,170],\n  palegreen:  [152,251,152],\n  paleturquoise:  [175,238,238],\n  palevioletred:  [219,112,147],\n  papayawhip: [255,239,213],\n  peachpuff:  [255,218,185],\n  peru: [205,133,63],\n  pink: [255,192,203],\n  plum: [221,160,221],\n  powderblue: [176,224,230],\n  purple: [128,0,128],\n  rebeccapurple: [102, 51, 153],\n  red:  [255,0,0],\n  rosybrown:  [188,143,143],\n  royalblue:  [65,105,225],\n  saddlebrown:  [139,69,19],\n  salmon: [250,128,114],\n  sandybrown: [244,164,96],\n  seagreen: [46,139,87],\n  seashell: [255,245,238],\n  sienna: [160,82,45],\n  silver: [192,192,192],\n  skyblue:  [135,206,235],\n  slateblue:  [106,90,205],\n  slategray:  [112,128,144],\n  slategrey:  [112,128,144],\n  snow: [255,250,250],\n  springgreen:  [0,255,127],\n  steelblue:  [70,130,180],\n  tan:  [210,180,140],\n  teal: [0,128,128],\n  thistle:  [216,191,216],\n  tomato: [255,99,71],\n  turquoise:  [64,224,208],\n  violet: [238,130,238],\n  wheat:  [245,222,179],\n  white:  [255,255,255],\n  whitesmoke: [245,245,245],\n  yellow: [255,255,0],\n  yellowgreen:  [154,205,50]\n};\n\nvar reverseKeywords = {};\nfor (var key in cssKeywords) {\n  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;\n}\n\n},{}],14:[function(require,module,exports){\nvar conversions = require(\"./conversions\");\n\nvar convert = function() {\n   return new Converter();\n}\n\nfor (var func in conversions) {\n  // export Raw versions\n  convert[func + \"Raw\"] =  (function(func) {\n    // accept array or plain args\n    return function(arg) {\n      if (typeof arg == \"number\")\n        arg = Array.prototype.slice.call(arguments);\n      return conversions[func](arg);\n    }\n  })(func);\n\n  var pair = /(\\w+)2(\\w+)/.exec(func),\n      from = pair[1],\n      to = pair[2];\n\n  // export rgb2hsl and [\"rgb\"][\"hsl\"]\n  convert[from] = convert[from] || {};\n\n  convert[from][to] = convert[func] = (function(func) { \n    return function(arg) {\n      if (typeof arg == \"number\")\n        arg = Array.prototype.slice.call(arguments);\n      \n      var val = conversions[func](arg);\n      if (typeof val == \"string\" || val === undefined)\n        return val; // keyword\n\n      for (var i = 0; i < val.length; i++)\n        val[i] = Math.round(val[i]);\n      return val;\n    }\n  })(func);\n}\n\n\n/* Converter does lazy conversion and caching */\nvar Converter = function() {\n   this.convs = {};\n};\n\n/* Either get the values for a space or\n  set the values for a space, depending on args */\nConverter.prototype.routeSpace = function(space, args) {\n   var values = args[0];\n   if (values === undefined) {\n      // color.rgb()\n      return this.getValues(space);\n   }\n   // color.rgb(10, 10, 10)\n   if (typeof values == \"number\") {\n      values = Array.prototype.slice.call(args);        \n   }\n\n   return this.setValues(space, values);\n};\n  \n/* Set the values for a space, invalidating cache */\nConverter.prototype.setValues = function(space, values) {\n   this.space = space;\n   this.convs = {};\n   this.convs[space] = values;\n   return this;\n};\n\n/* Get the values for a space. If there's already\n  a conversion for the space, fetch it, otherwise\n  compute it */\nConverter.prototype.getValues = function(space) {\n   var vals = this.convs[space];\n   if (!vals) {\n      var fspace = this.space,\n          from = this.convs[fspace];\n      vals = convert[fspace][space](from);\n\n      this.convs[space] = vals;\n   }\n  return vals;\n};\n\n[\"rgb\", \"hsl\", \"hsv\", \"cmyk\", \"keyword\"].forEach(function(space) {\n   Converter.prototype[space] = function(vals) {\n      return this.routeSpace(space, arguments);\n   }\n});\n\nmodule.exports = convert;\n},{\"./conversions\":13}],15:[function(require,module,exports){\n/**\n * @namespace Chart\n */\nvar Chart = require('./core/core')();\n\nChart.helpers = require('./helpers/index');\n\n// @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!\nrequire('./core/core.helpers')(Chart);\n\nChart.defaults = require('./core/core.defaults');\nChart.Element = require('./core/core.element');\nChart.elements = require('./elements/index');\nChart.Interaction = require('./core/core.interaction');\nChart.layouts = require('./core/core.layouts');\nChart.platform = require('./platforms/platform');\nChart.plugins = require('./core/core.plugins');\nChart.Ticks = require('./core/core.ticks');\n\nrequire('./core/core.animation')(Chart);\nrequire('./core/core.controller')(Chart);\nrequire('./core/core.datasetController')(Chart);\nrequire('./core/core.scaleService')(Chart);\nrequire('./core/core.scale')(Chart);\nrequire('./core/core.tooltip')(Chart);\n\nrequire('./scales/scale.linearbase')(Chart);\nrequire('./scales/scale.category')(Chart);\nrequire('./scales/scale.linear')(Chart);\nrequire('./scales/scale.logarithmic')(Chart);\nrequire('./scales/scale.radialLinear')(Chart);\nrequire('./scales/scale.time')(Chart);\n\n// Controllers must be loaded after elements\n// See Chart.core.datasetController.dataElementType\nrequire('./controllers/controller.bar')(Chart);\nrequire('./controllers/controller.bubble')(Chart);\nrequire('./controllers/controller.doughnut')(Chart);\nrequire('./controllers/controller.line')(Chart);\nrequire('./controllers/controller.polarArea')(Chart);\nrequire('./controllers/controller.radar')(Chart);\nrequire('./controllers/controller.scatter')(Chart);\n\nrequire('./charts/Chart.Bar')(Chart);\nrequire('./charts/Chart.Bubble')(Chart);\nrequire('./charts/Chart.Doughnut')(Chart);\nrequire('./charts/Chart.Line')(Chart);\nrequire('./charts/Chart.PolarArea')(Chart);\nrequire('./charts/Chart.Radar')(Chart);\nrequire('./charts/Chart.Scatter')(Chart);\n\n// Loading built-it plugins\nvar plugins = require('./plugins');\nfor (var k in plugins) {\n\tif (plugins.hasOwnProperty(k)) {\n\t\tChart.plugins.register(plugins[k]);\n\t}\n}\n\nChart.platform.initialize();\n\nmodule.exports = Chart;\nif (typeof window !== 'undefined') {\n\twindow.Chart = Chart;\n}\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, not available anymore\n * @namespace Chart.Legend\n * @deprecated since version 2.1.5\n * @todo remove at version 3\n * @private\n */\nChart.Legend = plugins.legend._element;\n\n/**\n * Provided for backward compatibility, not available anymore\n * @namespace Chart.Title\n * @deprecated since version 2.1.5\n * @todo remove at version 3\n * @private\n */\nChart.Title = plugins.title._element;\n\n/**\n * Provided for backward compatibility, use Chart.plugins instead\n * @namespace Chart.pluginService\n * @deprecated since version 2.1.5\n * @todo remove at version 3\n * @private\n */\nChart.pluginService = Chart.plugins;\n\n/**\n * Provided for backward compatibility, inheriting from Chart.PlugingBase has no\n * effect, instead simply create/register plugins via plain JavaScript objects.\n * @interface Chart.PluginBase\n * @deprecated since version 2.5.0\n * @todo remove at version 3\n * @private\n */\nChart.PluginBase = Chart.Element.extend({});\n\n/**\n * Provided for backward compatibility, use Chart.helpers.canvas instead.\n * @namespace Chart.canvasHelpers\n * @deprecated since version 2.6.0\n * @todo remove at version 3\n * @private\n */\nChart.canvasHelpers = Chart.helpers.canvas;\n\n/**\n * Provided for backward compatibility, use Chart.layouts instead.\n * @namespace Chart.layoutService\n * @deprecated since version 2.8.0\n * @todo remove at version 3\n * @private\n */\nChart.layoutService = Chart.layouts;\n\n},{\"./charts/Chart.Bar\":16,\"./charts/Chart.Bubble\":17,\"./charts/Chart.Doughnut\":18,\"./charts/Chart.Line\":19,\"./charts/Chart.PolarArea\":20,\"./charts/Chart.Radar\":21,\"./charts/Chart.Scatter\":22,\"./controllers/controller.bar\":23,\"./controllers/controller.bubble\":24,\"./controllers/controller.doughnut\":25,\"./controllers/controller.line\":26,\"./controllers/controller.polarArea\":27,\"./controllers/controller.radar\":28,\"./controllers/controller.scatter\":29,\"./core/core\":37,\"./core/core.animation\":30,\"./core/core.controller\":31,\"./core/core.datasetController\":32,\"./core/core.defaults\":33,\"./core/core.element\":34,\"./core/core.helpers\":35,\"./core/core.interaction\":36,\"./core/core.layouts\":38,\"./core/core.plugins\":39,\"./core/core.scale\":40,\"./core/core.scaleService\":41,\"./core/core.ticks\":42,\"./core/core.tooltip\":43,\"./elements/index\":48,\"./helpers/index\":53,\"./platforms/platform\":56,\"./plugins\":57,\"./scales/scale.category\":61,\"./scales/scale.linear\":62,\"./scales/scale.linearbase\":63,\"./scales/scale.logarithmic\":64,\"./scales/scale.radialLinear\":65,\"./scales/scale.time\":66}],16:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Bar = function(context, config) {\n\t\tconfig.type = 'bar';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n},{}],17:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Bubble = function(context, config) {\n\t\tconfig.type = 'bubble';\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n},{}],18:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Doughnut = function(context, config) {\n\t\tconfig.type = 'doughnut';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n},{}],19:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Line = function(context, config) {\n\t\tconfig.type = 'line';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n},{}],20:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.PolarArea = function(context, config) {\n\t\tconfig.type = 'polarArea';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n},{}],21:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Radar = function(context, config) {\n\t\tconfig.type = 'radar';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n},{}],22:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\tChart.Scatter = function(context, config) {\n\t\tconfig.type = 'scatter';\n\t\treturn new Chart(context, config);\n\t};\n};\n\n},{}],23:[function(require,module,exports){\n'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('bar', {\n\thover: {\n\t\tmode: 'label'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'category',\n\n\t\t\t// Specific to Bar Controller\n\t\t\tcategoryPercentage: 0.8,\n\t\t\tbarPercentage: 0.9,\n\n\t\t\t// offset settings\n\t\t\toffset: true,\n\n\t\t\t// grid line settings\n\t\t\tgridLines: {\n\t\t\t\toffsetGridLines: true\n\t\t\t}\n\t\t}],\n\n\t\tyAxes: [{\n\t\t\ttype: 'linear'\n\t\t}]\n\t}\n});\n\ndefaults._set('horizontalBar', {\n\thover: {\n\t\tmode: 'index',\n\t\taxis: 'y'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'linear',\n\t\t\tposition: 'bottom'\n\t\t}],\n\n\t\tyAxes: [{\n\t\t\tposition: 'left',\n\t\t\ttype: 'category',\n\n\t\t\t// Specific to Horizontal Bar Controller\n\t\t\tcategoryPercentage: 0.8,\n\t\t\tbarPercentage: 0.9,\n\n\t\t\t// offset settings\n\t\t\toffset: true,\n\n\t\t\t// grid line settings\n\t\t\tgridLines: {\n\t\t\t\toffsetGridLines: true\n\t\t\t}\n\t\t}]\n\t},\n\n\telements: {\n\t\trectangle: {\n\t\t\tborderSkipped: 'left'\n\t\t}\n\t},\n\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function(item, data) {\n\t\t\t\t// Pick first xLabel for now\n\t\t\t\tvar title = '';\n\n\t\t\t\tif (item.length > 0) {\n\t\t\t\t\tif (item[0].yLabel) {\n\t\t\t\t\t\ttitle = item[0].yLabel;\n\t\t\t\t\t} else if (data.labels.length > 0 && item[0].index < data.labels.length) {\n\t\t\t\t\t\ttitle = data.labels[item[0].index];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn title;\n\t\t\t},\n\n\t\t\tlabel: function(item, data) {\n\t\t\t\tvar datasetLabel = data.datasets[item.datasetIndex].label || '';\n\t\t\t\treturn datasetLabel + ': ' + item.xLabel;\n\t\t\t}\n\t\t},\n\t\tmode: 'index',\n\t\taxis: 'y'\n\t}\n});\n\n/**\n * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\n * @private\n */\nfunction computeMinSampleSize(scale, pixels) {\n\tvar min = scale.isHorizontal() ? scale.width : scale.height;\n\tvar ticks = scale.getTicks();\n\tvar prev, curr, i, ilen;\n\n\tfor (i = 1, ilen = pixels.length; i < ilen; ++i) {\n\t\tmin = Math.min(min, pixels[i] - pixels[i - 1]);\n\t}\n\n\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\tcurr = scale.getPixelForTick(i);\n\t\tmin = i > 0 ? Math.min(min, curr - prev) : min;\n\t\tprev = curr;\n\t}\n\n\treturn min;\n}\n\n/**\n * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\n * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\n * mode currently always generates bars equally sized (until we introduce scriptable options?).\n * @private\n */\nfunction computeFitCategoryTraits(index, ruler, options) {\n\tvar thickness = options.barThickness;\n\tvar count = ruler.stackCount;\n\tvar curr = ruler.pixels[index];\n\tvar size, ratio;\n\n\tif (helpers.isNullOrUndef(thickness)) {\n\t\tsize = ruler.min * options.categoryPercentage;\n\t\tratio = options.barPercentage;\n\t} else {\n\t\t// When bar thickness is enforced, category and bar percentages are ignored.\n\t\t// Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\n\t\t// and deprecate barPercentage since this value is ignored when thickness is absolute.\n\t\tsize = thickness * count;\n\t\tratio = 1;\n\t}\n\n\treturn {\n\t\tchunk: size / count,\n\t\tratio: ratio,\n\t\tstart: curr - (size / 2)\n\t};\n}\n\n/**\n * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\n * percentage options are 1), based on the previous and following categories. This mode\n * generates bars with different widths when data are not evenly spaced.\n * @private\n */\nfunction computeFlexCategoryTraits(index, ruler, options) {\n\tvar pixels = ruler.pixels;\n\tvar curr = pixels[index];\n\tvar prev = index > 0 ? pixels[index - 1] : null;\n\tvar next = index < pixels.length - 1 ? pixels[index + 1] : null;\n\tvar percent = options.categoryPercentage;\n\tvar start, size;\n\n\tif (prev === null) {\n\t\t// first data: its size is double based on the next point or,\n\t\t// if it's also the last data, we use the scale end extremity.\n\t\tprev = curr - (next === null ? ruler.end - curr : next - curr);\n\t}\n\n\tif (next === null) {\n\t\t// last data: its size is also double based on the previous point.\n\t\tnext = curr + curr - prev;\n\t}\n\n\tstart = curr - ((curr - prev) / 2) * percent;\n\tsize = ((next - prev) / 2) * percent;\n\n\treturn {\n\t\tchunk: size / ruler.stackCount,\n\t\tratio: options.barPercentage,\n\t\tstart: start\n\t};\n}\n\nmodule.exports = function(Chart) {\n\n\tChart.controllers.bar = Chart.DatasetController.extend({\n\n\t\tdataElementType: elements.Rectangle,\n\n\t\tinitialize: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta;\n\n\t\t\tChart.DatasetController.prototype.initialize.apply(me, arguments);\n\n\t\t\tmeta = me.getMeta();\n\t\t\tmeta.stack = me.getDataset().stack;\n\t\t\tmeta.bar = true;\n\t\t},\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar rects = me.getMeta().data;\n\t\t\tvar i, ilen;\n\n\t\t\tme._ruler = me.getRuler();\n\n\t\t\tfor (i = 0, ilen = rects.length; i < ilen; ++i) {\n\t\t\t\tme.updateElement(rects[i], i, reset);\n\t\t\t}\n\t\t},\n\n\t\tupdateElement: function(rectangle, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar rectangleOptions = chart.options.elements.rectangle;\n\n\t\t\trectangle._xScale = me.getScaleForId(meta.xAxisID);\n\t\t\trectangle._yScale = me.getScaleForId(meta.yAxisID);\n\t\t\trectangle._datasetIndex = me.index;\n\t\t\trectangle._index = index;\n\n\t\t\trectangle._model = {\n\t\t\t\tdatasetLabel: dataset.label,\n\t\t\t\tlabel: chart.data.labels[index],\n\t\t\t\tborderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,\n\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),\n\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),\n\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)\n\t\t\t};\n\n\t\t\tme.updateElementGeometry(rectangle, index, reset);\n\n\t\t\trectangle.pivot();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tupdateElementGeometry: function(rectangle, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar model = rectangle._model;\n\t\t\tvar vscale = me.getValueScale();\n\t\t\tvar base = vscale.getBasePixel();\n\t\t\tvar horizontal = vscale.isHorizontal();\n\t\t\tvar ruler = me._ruler || me.getRuler();\n\t\t\tvar vpixels = me.calculateBarValuePixels(me.index, index);\n\t\t\tvar ipixels = me.calculateBarIndexPixels(me.index, index, ruler);\n\n\t\t\tmodel.horizontal = horizontal;\n\t\t\tmodel.base = reset ? base : vpixels.base;\n\t\t\tmodel.x = horizontal ? reset ? base : vpixels.head : ipixels.center;\n\t\t\tmodel.y = horizontal ? ipixels.center : reset ? base : vpixels.head;\n\t\t\tmodel.height = horizontal ? ipixels.size : undefined;\n\t\t\tmodel.width = horizontal ? undefined : ipixels.size;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetValueScaleId: function() {\n\t\t\treturn this.getMeta().yAxisID;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetIndexScaleId: function() {\n\t\t\treturn this.getMeta().xAxisID;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetValueScale: function() {\n\t\t\treturn this.getScaleForId(this.getValueScaleId());\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetIndexScale: function() {\n\t\t\treturn this.getScaleForId(this.getIndexScaleId());\n\t\t},\n\n\t\t/**\n\t\t * Returns the stacks based on groups and bar visibility.\n\t\t * @param {Number} [last] - The dataset index\n\t\t * @returns {Array} The stack list\n\t\t * @private\n\t\t */\n\t\t_getStacks: function(last) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar scale = me.getIndexScale();\n\t\t\tvar stacked = scale.options.stacked;\n\t\t\tvar ilen = last === undefined ? chart.data.datasets.length : last + 1;\n\t\t\tvar stacks = [];\n\t\t\tvar i, meta;\n\n\t\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\tif (meta.bar && chart.isDatasetVisible(i) &&\n\t\t\t\t\t(stacked === false ||\n\t\t\t\t\t(stacked === true && stacks.indexOf(meta.stack) === -1) ||\n\t\t\t\t\t(stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1)))) {\n\t\t\t\t\tstacks.push(meta.stack);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn stacks;\n\t\t},\n\n\t\t/**\n\t\t * Returns the effective number of stacks based on groups and bar visibility.\n\t\t * @private\n\t\t */\n\t\tgetStackCount: function() {\n\t\t\treturn this._getStacks().length;\n\t\t},\n\n\t\t/**\n\t\t * Returns the stack index for the given dataset based on groups and bar visibility.\n\t\t * @param {Number} [datasetIndex] - The dataset index\n\t\t * @param {String} [name] - The stack name to find\n\t\t * @returns {Number} The stack index\n\t\t * @private\n\t\t */\n\t\tgetStackIndex: function(datasetIndex, name) {\n\t\t\tvar stacks = this._getStacks(datasetIndex);\n\t\t\tvar index = (name !== undefined)\n\t\t\t\t? stacks.indexOf(name)\n\t\t\t\t: -1; // indexOf returns -1 if element is not present\n\n\t\t\treturn (index === -1)\n\t\t\t\t? stacks.length - 1\n\t\t\t\t: index;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetRuler: function() {\n\t\t\tvar me = this;\n\t\t\tvar scale = me.getIndexScale();\n\t\t\tvar stackCount = me.getStackCount();\n\t\t\tvar datasetIndex = me.index;\n\t\t\tvar isHorizontal = scale.isHorizontal();\n\t\t\tvar start = isHorizontal ? scale.left : scale.top;\n\t\t\tvar end = start + (isHorizontal ? scale.width : scale.height);\n\t\t\tvar pixels = [];\n\t\t\tvar i, ilen, min;\n\n\t\t\tfor (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {\n\t\t\t\tpixels.push(scale.getPixelForValue(null, i, datasetIndex));\n\t\t\t}\n\n\t\t\tmin = helpers.isNullOrUndef(scale.options.barThickness)\n\t\t\t\t? computeMinSampleSize(scale, pixels)\n\t\t\t\t: -1;\n\n\t\t\treturn {\n\t\t\t\tmin: min,\n\t\t\t\tpixels: pixels,\n\t\t\t\tstart: start,\n\t\t\t\tend: end,\n\t\t\t\tstackCount: stackCount,\n\t\t\t\tscale: scale\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Note: pixel values are not clamped to the scale area.\n\t\t * @private\n\t\t */\n\t\tcalculateBarValuePixels: function(datasetIndex, index) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar scale = me.getValueScale();\n\t\t\tvar datasets = chart.data.datasets;\n\t\t\tvar value = scale.getRightValue(datasets[datasetIndex].data[index]);\n\t\t\tvar stacked = scale.options.stacked;\n\t\t\tvar stack = meta.stack;\n\t\t\tvar start = 0;\n\t\t\tvar i, imeta, ivalue, base, head, size;\n\n\t\t\tif (stacked || (stacked === undefined && stack !== undefined)) {\n\t\t\t\tfor (i = 0; i < datasetIndex; ++i) {\n\t\t\t\t\timeta = chart.getDatasetMeta(i);\n\n\t\t\t\t\tif (imeta.bar &&\n\t\t\t\t\t\timeta.stack === stack &&\n\t\t\t\t\t\timeta.controller.getValueScaleId() === scale.id &&\n\t\t\t\t\t\tchart.isDatasetVisible(i)) {\n\n\t\t\t\t\t\tivalue = scale.getRightValue(datasets[i].data[index]);\n\t\t\t\t\t\tif ((value < 0 && ivalue < 0) || (value >= 0 && ivalue > 0)) {\n\t\t\t\t\t\t\tstart += ivalue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbase = scale.getPixelForValue(start);\n\t\t\thead = scale.getPixelForValue(start + value);\n\t\t\tsize = (head - base) / 2;\n\n\t\t\treturn {\n\t\t\t\tsize: size,\n\t\t\t\tbase: base,\n\t\t\t\thead: head,\n\t\t\t\tcenter: head + size / 2\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tcalculateBarIndexPixels: function(datasetIndex, index, ruler) {\n\t\t\tvar me = this;\n\t\t\tvar options = ruler.scale.options;\n\t\t\tvar range = options.barThickness === 'flex'\n\t\t\t\t? computeFlexCategoryTraits(index, ruler, options)\n\t\t\t\t: computeFitCategoryTraits(index, ruler, options);\n\n\t\t\tvar stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);\n\t\t\tvar center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n\t\t\tvar size = Math.min(\n\t\t\t\thelpers.valueOrDefault(options.maxBarThickness, Infinity),\n\t\t\t\trange.chunk * range.ratio);\n\n\t\t\treturn {\n\t\t\t\tbase: center - size / 2,\n\t\t\t\thead: center + size / 2,\n\t\t\t\tcenter: center,\n\t\t\t\tsize: size\n\t\t\t};\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar scale = me.getValueScale();\n\t\t\tvar rects = me.getMeta().data;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar ilen = rects.length;\n\t\t\tvar i = 0;\n\n\t\t\thelpers.canvas.clipArea(chart.ctx, chart.chartArea);\n\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\tif (!isNaN(scale.getRightValue(dataset.data[i]))) {\n\t\t\t\t\trects[i].draw();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thelpers.canvas.unclipArea(chart.ctx);\n\t\t},\n\n\t\tsetHoverStyle: function(rectangle) {\n\t\t\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\n\t\t\tvar index = rectangle._index;\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar model = rectangle._model;\n\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\tremoveHoverStyle: function(rectangle) {\n\t\t\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\n\t\t\tvar index = rectangle._index;\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar model = rectangle._model;\n\t\t\tvar rectangleElementOptions = this.chart.options.elements.rectangle;\n\n\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);\n\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);\n\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);\n\t\t}\n\t});\n\n\tChart.controllers.horizontalBar = Chart.controllers.bar.extend({\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetValueScaleId: function() {\n\t\t\treturn this.getMeta().xAxisID;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetIndexScaleId: function() {\n\t\t\treturn this.getMeta().yAxisID;\n\t\t}\n\t});\n};\n\n},{\"../core/core.defaults\":33,\"../elements/index\":48,\"../helpers/index\":53}],24:[function(require,module,exports){\n'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('bubble', {\n\thover: {\n\t\tmode: 'single'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'linear', // bubble should probably use a linear scale by default\n\t\t\tposition: 'bottom',\n\t\t\tid: 'x-axis-0' // need an ID so datasets can reference the scale\n\t\t}],\n\t\tyAxes: [{\n\t\t\ttype: 'linear',\n\t\t\tposition: 'left',\n\t\t\tid: 'y-axis-0'\n\t\t}]\n\t},\n\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function() {\n\t\t\t\t// Title doesn't make sense for scatter since we format the data as a point\n\t\t\t\treturn '';\n\t\t\t},\n\t\t\tlabel: function(item, data) {\n\t\t\t\tvar datasetLabel = data.datasets[item.datasetIndex].label || '';\n\t\t\t\tvar dataPoint = data.datasets[item.datasetIndex].data[item.index];\n\t\t\t\treturn datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';\n\t\t\t}\n\t\t}\n\t}\n});\n\n\nmodule.exports = function(Chart) {\n\n\tChart.controllers.bubble = Chart.DatasetController.extend({\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tdataElementType: elements.Point,\n\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar points = meta.data;\n\n\t\t\t// Update Points\n\t\t\thelpers.each(points, function(point, index) {\n\t\t\t\tme.updateElement(point, index, reset);\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar options = me._resolveElementOptions(point, index);\n\t\t\tvar data = me.getDataset().data[index];\n\t\t\tvar dsIndex = me.index;\n\n\t\t\tvar x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);\n\t\t\tvar y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);\n\n\t\t\tpoint._xScale = xScale;\n\t\t\tpoint._yScale = yScale;\n\t\t\tpoint._options = options;\n\t\t\tpoint._datasetIndex = dsIndex;\n\t\t\tpoint._index = index;\n\t\t\tpoint._model = {\n\t\t\t\tbackgroundColor: options.backgroundColor,\n\t\t\t\tborderColor: options.borderColor,\n\t\t\t\tborderWidth: options.borderWidth,\n\t\t\t\thitRadius: options.hitRadius,\n\t\t\t\tpointStyle: options.pointStyle,\n\t\t\t\tradius: reset ? 0 : options.radius,\n\t\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t};\n\n\t\t\tpoint.pivot();\n\t\t},\n\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tsetHoverStyle: function(point) {\n\t\t\tvar model = point._model;\n\t\t\tvar options = point._options;\n\n\t\t\tmodel.backgroundColor = helpers.valueOrDefault(options.hoverBackgroundColor, helpers.getHoverColor(options.backgroundColor));\n\t\t\tmodel.borderColor = helpers.valueOrDefault(options.hoverBorderColor, helpers.getHoverColor(options.borderColor));\n\t\t\tmodel.borderWidth = helpers.valueOrDefault(options.hoverBorderWidth, options.borderWidth);\n\t\t\tmodel.radius = options.radius + options.hoverRadius;\n\t\t},\n\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tremoveHoverStyle: function(point) {\n\t\t\tvar model = point._model;\n\t\t\tvar options = point._options;\n\n\t\t\tmodel.backgroundColor = options.backgroundColor;\n\t\t\tmodel.borderColor = options.borderColor;\n\t\t\tmodel.borderWidth = options.borderWidth;\n\t\t\tmodel.radius = options.radius;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_resolveElementOptions: function(point, index) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar datasets = chart.data.datasets;\n\t\t\tvar dataset = datasets[me.index];\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar options = chart.options.elements.point;\n\t\t\tvar resolve = helpers.options.resolve;\n\t\t\tvar data = dataset.data[index];\n\t\t\tvar values = {};\n\t\t\tvar i, ilen, key;\n\n\t\t\t// Scriptable options\n\t\t\tvar context = {\n\t\t\t\tchart: chart,\n\t\t\t\tdataIndex: index,\n\t\t\t\tdataset: dataset,\n\t\t\t\tdatasetIndex: me.index\n\t\t\t};\n\n\t\t\tvar keys = [\n\t\t\t\t'backgroundColor',\n\t\t\t\t'borderColor',\n\t\t\t\t'borderWidth',\n\t\t\t\t'hoverBackgroundColor',\n\t\t\t\t'hoverBorderColor',\n\t\t\t\t'hoverBorderWidth',\n\t\t\t\t'hoverRadius',\n\t\t\t\t'hitRadius',\n\t\t\t\t'pointStyle'\n\t\t\t];\n\n\t\t\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\t\t\tkey = keys[i];\n\t\t\t\tvalues[key] = resolve([\n\t\t\t\t\tcustom[key],\n\t\t\t\t\tdataset[key],\n\t\t\t\t\toptions[key]\n\t\t\t\t], context, index);\n\t\t\t}\n\n\t\t\t// Custom radius resolution\n\t\t\tvalues.radius = resolve([\n\t\t\t\tcustom.radius,\n\t\t\t\tdata ? data.r : undefined,\n\t\t\t\tdataset.radius,\n\t\t\t\toptions.radius\n\t\t\t], context, index);\n\n\t\t\treturn values;\n\t\t}\n\t});\n};\n\n},{\"../core/core.defaults\":33,\"../elements/index\":48,\"../helpers/index\":53}],25:[function(require,module,exports){\n'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('doughnut', {\n\tanimation: {\n\t\t// Boolean - Whether we animate the rotation of the Doughnut\n\t\tanimateRotate: true,\n\t\t// Boolean - Whether we animate scaling the Doughnut from the centre\n\t\tanimateScale: false\n\t},\n\thover: {\n\t\tmode: 'single'\n\t},\n\tlegendCallback: function(chart) {\n\t\tvar text = [];\n\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\n\t\tvar data = chart.data;\n\t\tvar datasets = data.datasets;\n\t\tvar labels = data.labels;\n\n\t\tif (datasets.length) {\n\t\t\tfor (var i = 0; i < datasets[0].data.length; ++i) {\n\t\t\t\ttext.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n\t\t\t\tif (labels[i]) {\n\t\t\t\t\ttext.push(labels[i]);\n\t\t\t\t}\n\t\t\t\ttext.push('</li>');\n\t\t\t}\n\t\t}\n\n\t\ttext.push('</ul>');\n\t\treturn text.join('');\n\t},\n\tlegend: {\n\t\tlabels: {\n\t\t\tgenerateLabels: function(chart) {\n\t\t\t\tvar data = chart.data;\n\t\t\t\tif (data.labels.length && data.datasets.length) {\n\t\t\t\t\treturn data.labels.map(function(label, i) {\n\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\n\t\t\t\t\t\tvar ds = data.datasets[0];\n\t\t\t\t\t\tvar arc = meta.data[i];\n\t\t\t\t\t\tvar custom = arc && arc.custom || {};\n\t\t\t\t\t\tvar valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n\t\t\t\t\t\tvar arcOpts = chart.options.elements.arc;\n\t\t\t\t\t\tvar fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\n\t\t\t\t\t\tvar stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\n\t\t\t\t\t\tvar bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\tfillStyle: fill,\n\t\t\t\t\t\t\tstrokeStyle: stroke,\n\t\t\t\t\t\t\tlineWidth: bw,\n\t\t\t\t\t\t\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n\n\t\t\t\t\t\t\t// Extra data used for toggling the correct item\n\t\t\t\t\t\t\tindex: i\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn [];\n\t\t\t}\n\t\t},\n\n\t\tonClick: function(e, legendItem) {\n\t\t\tvar index = legendItem.index;\n\t\t\tvar chart = this.chart;\n\t\t\tvar i, ilen, meta;\n\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\t// toggle visibility of index if exists\n\t\t\t\tif (meta.data[index]) {\n\t\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchart.update();\n\t\t}\n\t},\n\n\t// The percentage of the chart that we cut out of the middle.\n\tcutoutPercentage: 50,\n\n\t// The rotation of the chart, where the first data arc begins.\n\trotation: Math.PI * -0.5,\n\n\t// The total circumference of the chart.\n\tcircumference: Math.PI * 2.0,\n\n\t// Need to override these to give a nice default\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function() {\n\t\t\t\treturn '';\n\t\t\t},\n\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\tvar dataLabel = data.labels[tooltipItem.index];\n\t\t\t\tvar value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\n\n\t\t\t\tif (helpers.isArray(dataLabel)) {\n\t\t\t\t\t// show value on first line of multiline label\n\t\t\t\t\t// need to clone because we are changing the value\n\t\t\t\t\tdataLabel = dataLabel.slice();\n\t\t\t\t\tdataLabel[0] += value;\n\t\t\t\t} else {\n\t\t\t\t\tdataLabel += value;\n\t\t\t\t}\n\n\t\t\t\treturn dataLabel;\n\t\t\t}\n\t\t}\n\t}\n});\n\ndefaults._set('pie', helpers.clone(defaults.doughnut));\ndefaults._set('pie', {\n\tcutoutPercentage: 0\n});\n\nmodule.exports = function(Chart) {\n\n\tChart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({\n\n\t\tdataElementType: elements.Arc,\n\n\t\tlinkScales: helpers.noop,\n\n\t\t// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly\n\t\tgetRingIndex: function(datasetIndex) {\n\t\t\tvar ringIndex = 0;\n\n\t\t\tfor (var j = 0; j < datasetIndex; ++j) {\n\t\t\t\tif (this.chart.isDatasetVisible(j)) {\n\t\t\t\t\t++ringIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ringIndex;\n\t\t},\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar chartArea = chart.chartArea;\n\t\t\tvar opts = chart.options;\n\t\t\tvar arcOpts = opts.elements.arc;\n\t\t\tvar availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth;\n\t\t\tvar availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth;\n\t\t\tvar minSize = Math.min(availableWidth, availableHeight);\n\t\t\tvar offset = {x: 0, y: 0};\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar cutoutPercentage = opts.cutoutPercentage;\n\t\t\tvar circumference = opts.circumference;\n\n\t\t\t// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc\n\t\t\tif (circumference < Math.PI * 2.0) {\n\t\t\t\tvar startAngle = opts.rotation % (Math.PI * 2.0);\n\t\t\t\tstartAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);\n\t\t\t\tvar endAngle = startAngle + circumference;\n\t\t\t\tvar start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};\n\t\t\t\tvar end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};\n\t\t\t\tvar contains0 = (startAngle <= 0 && endAngle >= 0) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);\n\t\t\t\tvar contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);\n\t\t\t\tvar contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);\n\t\t\t\tvar contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);\n\t\t\t\tvar cutout = cutoutPercentage / 100.0;\n\t\t\t\tvar min = {x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))};\n\t\t\t\tvar max = {x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))};\n\t\t\t\tvar size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};\n\t\t\t\tminSize = Math.min(availableWidth / size.width, availableHeight / size.height);\n\t\t\t\toffset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};\n\t\t\t}\n\n\t\t\tchart.borderWidth = me.getMaxBorderWidth(meta.data);\n\t\t\tchart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);\n\t\t\tchart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 0, 0);\n\t\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n\t\t\tchart.offsetX = offset.x * chart.outerRadius;\n\t\t\tchart.offsetY = offset.y * chart.outerRadius;\n\n\t\t\tmeta.total = me.calculateTotal();\n\n\t\t\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.getRingIndex(me.index));\n\t\t\tme.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);\n\n\t\t\thelpers.each(meta.data, function(arc, index) {\n\t\t\t\tme.updateElement(arc, index, reset);\n\t\t\t});\n\t\t},\n\n\t\tupdateElement: function(arc, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar chartArea = chart.chartArea;\n\t\t\tvar opts = chart.options;\n\t\t\tvar animationOpts = opts.animation;\n\t\t\tvar centerX = (chartArea.left + chartArea.right) / 2;\n\t\t\tvar centerY = (chartArea.top + chartArea.bottom) / 2;\n\t\t\tvar startAngle = opts.rotation; // non reset case handled later\n\t\t\tvar endAngle = opts.rotation; // non reset case handled later\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));\n\t\t\tvar innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;\n\t\t\tvar outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;\n\t\t\tvar valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n\n\t\t\thelpers.extend(arc, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index,\n\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tx: centerX + chart.offsetX,\n\t\t\t\t\ty: centerY + chart.offsetY,\n\t\t\t\t\tstartAngle: startAngle,\n\t\t\t\t\tendAngle: endAngle,\n\t\t\t\t\tcircumference: circumference,\n\t\t\t\t\touterRadius: outerRadius,\n\t\t\t\t\tinnerRadius: innerRadius,\n\t\t\t\t\tlabel: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tvar model = arc._model;\n\t\t\t// Resets the visual styles\n\t\t\tthis.removeHoverStyle(arc);\n\n\t\t\t// Set correct angles if not resetting\n\t\t\tif (!reset || !animationOpts.animateRotate) {\n\t\t\t\tif (index === 0) {\n\t\t\t\t\tmodel.startAngle = opts.rotation;\n\t\t\t\t} else {\n\t\t\t\t\tmodel.startAngle = me.getMeta().data[index - 1]._model.endAngle;\n\t\t\t\t}\n\n\t\t\t\tmodel.endAngle = model.startAngle + model.circumference;\n\t\t\t}\n\n\t\t\tarc.pivot();\n\t\t},\n\n\t\tremoveHoverStyle: function(arc) {\n\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\n\t\t},\n\n\t\tcalculateTotal: function() {\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar total = 0;\n\t\t\tvar value;\n\n\t\t\thelpers.each(meta.data, function(element, index) {\n\t\t\t\tvalue = dataset.data[index];\n\t\t\t\tif (!isNaN(value) && !element.hidden) {\n\t\t\t\t\ttotal += Math.abs(value);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/* if (total === 0) {\n\t\t\t\ttotal = NaN;\n\t\t\t}*/\n\n\t\t\treturn total;\n\t\t},\n\n\t\tcalculateCircumference: function(value) {\n\t\t\tvar total = this.getMeta().total;\n\t\t\tif (total > 0 && !isNaN(value)) {\n\t\t\t\treturn (Math.PI * 2.0) * (Math.abs(value) / total);\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\n\t\t// gets the max border or hover width to properly scale pie charts\n\t\tgetMaxBorderWidth: function(arcs) {\n\t\t\tvar max = 0;\n\t\t\tvar index = this.index;\n\t\t\tvar length = arcs.length;\n\t\t\tvar borderWidth;\n\t\t\tvar hoverWidth;\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tborderWidth = arcs[i]._model ? arcs[i]._model.borderWidth : 0;\n\t\t\t\thoverWidth = arcs[i]._chart ? arcs[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;\n\n\t\t\t\tmax = borderWidth > max ? borderWidth : max;\n\t\t\t\tmax = hoverWidth > max ? hoverWidth : max;\n\t\t\t}\n\t\t\treturn max;\n\t\t}\n\t});\n};\n\n},{\"../core/core.defaults\":33,\"../elements/index\":48,\"../helpers/index\":53}],26:[function(require,module,exports){\n'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('line', {\n\tshowLines: true,\n\tspanGaps: false,\n\n\thover: {\n\t\tmode: 'label'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'category',\n\t\t\tid: 'x-axis-0'\n\t\t}],\n\t\tyAxes: [{\n\t\t\ttype: 'linear',\n\t\t\tid: 'y-axis-0'\n\t\t}]\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\tfunction lineEnabled(dataset, options) {\n\t\treturn helpers.valueOrDefault(dataset.showLine, options.showLines);\n\t}\n\n\tChart.controllers.line = Chart.DatasetController.extend({\n\n\t\tdatasetElementType: elements.Line,\n\n\t\tdataElementType: elements.Point,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar line = meta.dataset;\n\t\t\tvar points = meta.data || [];\n\t\t\tvar options = me.chart.options;\n\t\t\tvar lineElementOptions = options.elements.line;\n\t\t\tvar scale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar i, ilen, custom;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar showLine = lineEnabled(dataset, options);\n\n\t\t\t// Update Line\n\t\t\tif (showLine) {\n\t\t\t\tcustom = line.custom || {};\n\n\t\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\t\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\n\t\t\t\t\tdataset.lineTension = dataset.tension;\n\t\t\t\t}\n\n\t\t\t\t// Utility\n\t\t\t\tline._scale = scale;\n\t\t\t\tline._datasetIndex = me.index;\n\t\t\t\t// Data\n\t\t\t\tline._children = points;\n\t\t\t\t// Model\n\t\t\t\tline._model = {\n\t\t\t\t\t// Appearance\n\t\t\t\t\t// The default behavior of lines is to break at null values, according\n\t\t\t\t\t// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158\n\t\t\t\t\t// This option gives lines the ability to span gaps\n\t\t\t\t\tspanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,\n\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),\n\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\n\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\n\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\n\t\t\t\t\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\n\t\t\t\t\tborderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\n\t\t\t\t\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\n\t\t\t\t\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\n\t\t\t\t\tfill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\n\t\t\t\t\tsteppedLine: custom.steppedLine ? custom.steppedLine : helpers.valueOrDefault(dataset.steppedLine, lineElementOptions.stepped),\n\t\t\t\t\tcubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.valueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),\n\t\t\t\t};\n\n\t\t\t\tline.pivot();\n\t\t\t}\n\n\t\t\t// Update Points\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\tme.updateElement(points[i], i, reset);\n\t\t\t}\n\n\t\t\tif (showLine && line._model.tension !== 0) {\n\t\t\t\tme.updateBezierControlPoints();\n\t\t\t}\n\n\t\t\t// Now pivot the point for animation\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\tpoints[i].pivot();\n\t\t\t}\n\t\t},\n\n\t\tgetPointBackgroundColor: function(point, index) {\n\t\t\tvar backgroundColor = this.chart.options.elements.point.backgroundColor;\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar custom = point.custom || {};\n\n\t\t\tif (custom.backgroundColor) {\n\t\t\t\tbackgroundColor = custom.backgroundColor;\n\t\t\t} else if (dataset.pointBackgroundColor) {\n\t\t\t\tbackgroundColor = helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);\n\t\t\t} else if (dataset.backgroundColor) {\n\t\t\t\tbackgroundColor = dataset.backgroundColor;\n\t\t\t}\n\n\t\t\treturn backgroundColor;\n\t\t},\n\n\t\tgetPointBorderColor: function(point, index) {\n\t\t\tvar borderColor = this.chart.options.elements.point.borderColor;\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar custom = point.custom || {};\n\n\t\t\tif (custom.borderColor) {\n\t\t\t\tborderColor = custom.borderColor;\n\t\t\t} else if (dataset.pointBorderColor) {\n\t\t\t\tborderColor = helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);\n\t\t\t} else if (dataset.borderColor) {\n\t\t\t\tborderColor = dataset.borderColor;\n\t\t\t}\n\n\t\t\treturn borderColor;\n\t\t},\n\n\t\tgetPointBorderWidth: function(point, index) {\n\t\t\tvar borderWidth = this.chart.options.elements.point.borderWidth;\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar custom = point.custom || {};\n\n\t\t\tif (!isNaN(custom.borderWidth)) {\n\t\t\t\tborderWidth = custom.borderWidth;\n\t\t\t} else if (!isNaN(dataset.pointBorderWidth) || helpers.isArray(dataset.pointBorderWidth)) {\n\t\t\t\tborderWidth = helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);\n\t\t\t} else if (!isNaN(dataset.borderWidth)) {\n\t\t\t\tborderWidth = dataset.borderWidth;\n\t\t\t}\n\n\t\t\treturn borderWidth;\n\t\t},\n\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar datasetIndex = me.index;\n\t\t\tvar value = dataset.data[index];\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tvar pointOptions = me.chart.options.elements.point;\n\t\t\tvar x, y;\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t}\n\t\t\tif ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {\n\t\t\t\tdataset.pointHitRadius = dataset.hitRadius;\n\t\t\t}\n\n\t\t\tx = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);\n\t\t\ty = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);\n\n\t\t\t// Utility\n\t\t\tpoint._xScale = xScale;\n\t\t\tpoint._yScale = yScale;\n\t\t\tpoint._datasetIndex = datasetIndex;\n\t\t\tpoint._index = index;\n\n\t\t\t// Desired view properties\n\t\t\tpoint._model = {\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\n\t\t\t\t// Appearance\n\t\t\t\tradius: custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),\n\t\t\t\tpointStyle: custom.pointStyle || helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),\n\t\t\t\tbackgroundColor: me.getPointBackgroundColor(point, index),\n\t\t\t\tborderColor: me.getPointBorderColor(point, index),\n\t\t\t\tborderWidth: me.getPointBorderWidth(point, index),\n\t\t\t\ttension: meta.dataset._model ? meta.dataset._model.tension : 0,\n\t\t\t\tsteppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,\n\t\t\t\t// Tooltip\n\t\t\t\thitRadius: custom.hitRadius || helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)\n\t\t\t};\n\t\t},\n\n\t\tcalculatePointY: function(value, index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar sumPos = 0;\n\t\t\tvar sumNeg = 0;\n\t\t\tvar i, ds, dsMeta;\n\n\t\t\tif (yScale.options.stacked) {\n\t\t\t\tfor (i = 0; i < datasetIndex; i++) {\n\t\t\t\t\tds = chart.data.datasets[i];\n\t\t\t\t\tdsMeta = chart.getDatasetMeta(i);\n\t\t\t\t\tif (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {\n\t\t\t\t\t\tvar stackedRightValue = Number(yScale.getRightValue(ds.data[index]));\n\t\t\t\t\t\tif (stackedRightValue < 0) {\n\t\t\t\t\t\t\tsumNeg += stackedRightValue || 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsumPos += stackedRightValue || 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar rightValue = Number(yScale.getRightValue(value));\n\t\t\t\tif (rightValue < 0) {\n\t\t\t\t\treturn yScale.getPixelForValue(sumNeg + rightValue);\n\t\t\t\t}\n\t\t\t\treturn yScale.getPixelForValue(sumPos + rightValue);\n\t\t\t}\n\n\t\t\treturn yScale.getPixelForValue(value);\n\t\t},\n\n\t\tupdateBezierControlPoints: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar area = me.chart.chartArea;\n\t\t\tvar points = (meta.data || []);\n\t\t\tvar i, ilen, point, model, controlPoints;\n\n\t\t\t// Only consider points that are drawn in case the spanGaps option is used\n\t\t\tif (meta.dataset._model.spanGaps) {\n\t\t\t\tpoints = points.filter(function(pt) {\n\t\t\t\t\treturn !pt._model.skip;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction capControlPoint(pt, min, max) {\n\t\t\t\treturn Math.max(Math.min(pt, max), min);\n\t\t\t}\n\n\t\t\tif (meta.dataset._model.cubicInterpolationMode === 'monotone') {\n\t\t\t\thelpers.splineCurveMonotone(points);\n\t\t\t} else {\n\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\tpoint = points[i];\n\t\t\t\t\tmodel = point._model;\n\t\t\t\t\tcontrolPoints = helpers.splineCurve(\n\t\t\t\t\t\thelpers.previousItem(points, i)._model,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\thelpers.nextItem(points, i)._model,\n\t\t\t\t\t\tmeta.dataset._model.tension\n\t\t\t\t\t);\n\t\t\t\t\tmodel.controlPointPreviousX = controlPoints.previous.x;\n\t\t\t\t\tmodel.controlPointPreviousY = controlPoints.previous.y;\n\t\t\t\t\tmodel.controlPointNextX = controlPoints.next.x;\n\t\t\t\t\tmodel.controlPointNextY = controlPoints.next.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (me.chart.options.elements.line.capBezierPoints) {\n\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\tmodel = points[i]._model;\n\t\t\t\t\tmodel.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\n\t\t\t\t\tmodel.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\n\t\t\t\t\tmodel.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\n\t\t\t\t\tmodel.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar points = meta.data || [];\n\t\t\tvar area = chart.chartArea;\n\t\t\tvar ilen = points.length;\n\t\t\tvar i = 0;\n\n\t\t\thelpers.canvas.clipArea(chart.ctx, area);\n\n\t\t\tif (lineEnabled(me.getDataset(), chart.options)) {\n\t\t\t\tmeta.dataset.draw();\n\t\t\t}\n\n\t\t\thelpers.canvas.unclipArea(chart.ctx);\n\n\t\t\t// Draw the points\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\tpoints[i].draw(area);\n\t\t\t}\n\t\t},\n\n\t\tsetHoverStyle: function(point) {\n\t\t\t// Point\n\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\tvar index = point._index;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar model = point._model;\n\n\t\t\tmodel.radius = custom.hoverRadius || helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\tremoveHoverStyle: function(point) {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.chart.data.datasets[point._datasetIndex];\n\t\t\tvar index = point._index;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar model = point._model;\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t}\n\n\t\t\tmodel.radius = custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);\n\t\t\tmodel.backgroundColor = me.getPointBackgroundColor(point, index);\n\t\t\tmodel.borderColor = me.getPointBorderColor(point, index);\n\t\t\tmodel.borderWidth = me.getPointBorderWidth(point, index);\n\t\t}\n\t});\n};\n\n},{\"../core/core.defaults\":33,\"../elements/index\":48,\"../helpers/index\":53}],27:[function(require,module,exports){\n'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('polarArea', {\n\tscale: {\n\t\ttype: 'radialLinear',\n\t\tangleLines: {\n\t\t\tdisplay: false\n\t\t},\n\t\tgridLines: {\n\t\t\tcircular: true\n\t\t},\n\t\tpointLabels: {\n\t\t\tdisplay: false\n\t\t},\n\t\tticks: {\n\t\t\tbeginAtZero: true\n\t\t}\n\t},\n\n\t// Boolean - Whether to animate the rotation of the chart\n\tanimation: {\n\t\tanimateRotate: true,\n\t\tanimateScale: true\n\t},\n\n\tstartAngle: -0.5 * Math.PI,\n\tlegendCallback: function(chart) {\n\t\tvar text = [];\n\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\n\t\tvar data = chart.data;\n\t\tvar datasets = data.datasets;\n\t\tvar labels = data.labels;\n\n\t\tif (datasets.length) {\n\t\t\tfor (var i = 0; i < datasets[0].data.length; ++i) {\n\t\t\t\ttext.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n\t\t\t\tif (labels[i]) {\n\t\t\t\t\ttext.push(labels[i]);\n\t\t\t\t}\n\t\t\t\ttext.push('</li>');\n\t\t\t}\n\t\t}\n\n\t\ttext.push('</ul>');\n\t\treturn text.join('');\n\t},\n\tlegend: {\n\t\tlabels: {\n\t\t\tgenerateLabels: function(chart) {\n\t\t\t\tvar data = chart.data;\n\t\t\t\tif (data.labels.length && data.datasets.length) {\n\t\t\t\t\treturn data.labels.map(function(label, i) {\n\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\n\t\t\t\t\t\tvar ds = data.datasets[0];\n\t\t\t\t\t\tvar arc = meta.data[i];\n\t\t\t\t\t\tvar custom = arc.custom || {};\n\t\t\t\t\t\tvar valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n\t\t\t\t\t\tvar arcOpts = chart.options.elements.arc;\n\t\t\t\t\t\tvar fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\n\t\t\t\t\t\tvar stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\n\t\t\t\t\t\tvar bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\tfillStyle: fill,\n\t\t\t\t\t\t\tstrokeStyle: stroke,\n\t\t\t\t\t\t\tlineWidth: bw,\n\t\t\t\t\t\t\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n\n\t\t\t\t\t\t\t// Extra data used for toggling the correct item\n\t\t\t\t\t\t\tindex: i\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn [];\n\t\t\t}\n\t\t},\n\n\t\tonClick: function(e, legendItem) {\n\t\t\tvar index = legendItem.index;\n\t\t\tvar chart = this.chart;\n\t\t\tvar i, ilen, meta;\n\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;\n\t\t\t}\n\n\t\t\tchart.update();\n\t\t}\n\t},\n\n\t// Need to override these to give a nice default\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function() {\n\t\t\t\treturn '';\n\t\t\t},\n\t\t\tlabel: function(item, data) {\n\t\t\t\treturn data.labels[item.index] + ': ' + item.yLabel;\n\t\t\t}\n\t\t}\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\tChart.controllers.polarArea = Chart.DatasetController.extend({\n\n\t\tdataElementType: elements.Arc,\n\n\t\tlinkScales: helpers.noop,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar chartArea = chart.chartArea;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar opts = chart.options;\n\t\t\tvar arcOpts = opts.elements.arc;\n\t\t\tvar minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n\t\t\tchart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);\n\t\t\tchart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n\t\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n\n\t\t\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);\n\t\t\tme.innerRadius = me.outerRadius - chart.radiusLength;\n\n\t\t\tmeta.count = me.countVisibleElements();\n\n\t\t\thelpers.each(meta.data, function(arc, index) {\n\t\t\t\tme.updateElement(arc, index, reset);\n\t\t\t});\n\t\t},\n\n\t\tupdateElement: function(arc, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar opts = chart.options;\n\t\t\tvar animationOpts = opts.animation;\n\t\t\tvar scale = chart.scale;\n\t\t\tvar labels = chart.data.labels;\n\n\t\t\tvar circumference = me.calculateCircumference(dataset.data[index]);\n\t\t\tvar centerX = scale.xCenter;\n\t\t\tvar centerY = scale.yCenter;\n\n\t\t\t// If there is NaN data before us, we need to calculate the starting angle correctly.\n\t\t\t// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data\n\t\t\tvar visibleCount = 0;\n\t\t\tvar meta = me.getMeta();\n\t\t\tfor (var i = 0; i < index; ++i) {\n\t\t\t\tif (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {\n\t\t\t\t\t++visibleCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// var negHalfPI = -0.5 * Math.PI;\n\t\t\tvar datasetStartAngle = opts.startAngle;\n\t\t\tvar distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n\t\t\tvar startAngle = datasetStartAngle + (circumference * visibleCount);\n\t\t\tvar endAngle = startAngle + (arc.hidden ? 0 : circumference);\n\n\t\t\tvar resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n\n\t\t\thelpers.extend(arc, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index,\n\t\t\t\t_scale: scale,\n\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tx: centerX,\n\t\t\t\t\ty: centerY,\n\t\t\t\t\tinnerRadius: 0,\n\t\t\t\t\touterRadius: reset ? resetRadius : distance,\n\t\t\t\t\tstartAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,\n\t\t\t\t\tendAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,\n\t\t\t\t\tlabel: helpers.valueAtIndexOrDefault(labels, index, labels[index])\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Apply border and fill style\n\t\t\tme.removeHoverStyle(arc);\n\n\t\t\tarc.pivot();\n\t\t},\n\n\t\tremoveHoverStyle: function(arc) {\n\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\n\t\t},\n\n\t\tcountVisibleElements: function() {\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar count = 0;\n\n\t\t\thelpers.each(meta.data, function(element, index) {\n\t\t\t\tif (!isNaN(dataset.data[index]) && !element.hidden) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn count;\n\t\t},\n\n\t\tcalculateCircumference: function(value) {\n\t\t\tvar count = this.getMeta().count;\n\t\t\tif (count > 0 && !isNaN(value)) {\n\t\t\t\treturn (2 * Math.PI) / count;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t});\n};\n\n},{\"../core/core.defaults\":33,\"../elements/index\":48,\"../helpers/index\":53}],28:[function(require,module,exports){\n'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('radar', {\n\tscale: {\n\t\ttype: 'radialLinear'\n\t},\n\telements: {\n\t\tline: {\n\t\t\ttension: 0 // no bezier in radar\n\t\t}\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\tChart.controllers.radar = Chart.DatasetController.extend({\n\n\t\tdatasetElementType: elements.Line,\n\n\t\tdataElementType: elements.Point,\n\n\t\tlinkScales: helpers.noop,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar line = meta.dataset;\n\t\t\tvar points = meta.data;\n\t\t\tvar custom = line.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar lineElementOptions = me.chart.options.elements.line;\n\t\t\tvar scale = me.chart.scale;\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\n\t\t\t\tdataset.lineTension = dataset.tension;\n\t\t\t}\n\n\t\t\thelpers.extend(meta.dataset, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_scale: scale,\n\t\t\t\t// Data\n\t\t\t\t_children: points,\n\t\t\t\t_loop: true,\n\t\t\t\t// Model\n\t\t\t\t_model: {\n\t\t\t\t\t// Appearance\n\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),\n\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\n\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\n\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\n\t\t\t\t\tfill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\n\t\t\t\t\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\n\t\t\t\t\tborderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\n\t\t\t\t\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\n\t\t\t\t\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tmeta.dataset.pivot();\n\n\t\t\t// Update Points\n\t\t\thelpers.each(points, function(point, index) {\n\t\t\t\tme.updateElement(point, index, reset);\n\t\t\t}, me);\n\n\t\t\t// Update bezier control points\n\t\t\tme.updateBezierControlPoints();\n\t\t},\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar scale = me.chart.scale;\n\t\t\tvar pointElementOptions = me.chart.options.elements.point;\n\t\t\tvar pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t}\n\t\t\tif ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {\n\t\t\t\tdataset.pointHitRadius = dataset.hitRadius;\n\t\t\t}\n\n\t\t\thelpers.extend(point, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index,\n\t\t\t\t_scale: scale,\n\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tx: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales\n\t\t\t\t\ty: reset ? scale.yCenter : pointPosition.y,\n\n\t\t\t\t\t// Appearance\n\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),\n\t\t\t\t\tradius: custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),\n\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),\n\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),\n\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),\n\t\t\t\t\tpointStyle: custom.pointStyle ? custom.pointStyle : helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),\n\n\t\t\t\t\t// Tooltip\n\t\t\t\t\thitRadius: custom.hitRadius ? custom.hitRadius : helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointElementOptions.hitRadius)\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tpoint._model.skip = custom.skip ? custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));\n\t\t},\n\t\tupdateBezierControlPoints: function() {\n\t\t\tvar chartArea = this.chart.chartArea;\n\t\t\tvar meta = this.getMeta();\n\n\t\t\thelpers.each(meta.data, function(point, index) {\n\t\t\t\tvar model = point._model;\n\t\t\t\tvar controlPoints = helpers.splineCurve(\n\t\t\t\t\thelpers.previousItem(meta.data, index, true)._model,\n\t\t\t\t\tmodel,\n\t\t\t\t\thelpers.nextItem(meta.data, index, true)._model,\n\t\t\t\t\tmodel.tension\n\t\t\t\t);\n\n\t\t\t\t// Prevent the bezier going outside of the bounds of the graph\n\t\t\t\tmodel.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);\n\t\t\t\tmodel.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);\n\n\t\t\t\tmodel.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);\n\t\t\t\tmodel.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);\n\n\t\t\t\t// Now pivot the point for animation\n\t\t\t\tpoint.pivot();\n\t\t\t});\n\t\t},\n\n\t\tsetHoverStyle: function(point) {\n\t\t\t// Point\n\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar index = point._index;\n\t\t\tvar model = point._model;\n\n\t\t\tmodel.radius = custom.hoverRadius ? custom.hoverRadius : helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\tremoveHoverStyle: function(point) {\n\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar index = point._index;\n\t\t\tvar model = point._model;\n\t\t\tvar pointElementOptions = this.chart.options.elements.point;\n\n\t\t\tmodel.radius = custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius);\n\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);\n\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);\n\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);\n\t\t}\n\t});\n};\n\n},{\"../core/core.defaults\":33,\"../elements/index\":48,\"../helpers/index\":53}],29:[function(require,module,exports){\n'use strict';\n\nvar defaults = require('../core/core.defaults');\n\ndefaults._set('scatter', {\n\thover: {\n\t\tmode: 'single'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\tid: 'x-axis-1',    // need an ID so datasets can reference the scale\n\t\t\ttype: 'linear',    // scatter should not use a category axis\n\t\t\tposition: 'bottom'\n\t\t}],\n\t\tyAxes: [{\n\t\t\tid: 'y-axis-1',\n\t\t\ttype: 'linear',\n\t\t\tposition: 'left'\n\t\t}]\n\t},\n\n\tshowLines: false,\n\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function() {\n\t\t\t\treturn '';     // doesn't make sense for scatter since data are formatted as a point\n\t\t\t},\n\t\t\tlabel: function(item) {\n\t\t\t\treturn '(' + item.xLabel + ', ' + item.yLabel + ')';\n\t\t\t}\n\t\t}\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\t// Scatter charts use line controllers\n\tChart.controllers.scatter = Chart.controllers.line;\n\n};\n\n},{\"../core/core.defaults\":33}],30:[function(require,module,exports){\n/* global window: false */\n'use strict';\n\nvar defaults = require('./core.defaults');\nvar Element = require('./core.element');\nvar helpers = require('../helpers/index');\n\ndefaults._set('global', {\n\tanimation: {\n\t\tduration: 1000,\n\t\teasing: 'easeOutQuart',\n\t\tonProgress: helpers.noop,\n\t\tonComplete: helpers.noop\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\tChart.Animation = Element.extend({\n\t\tchart: null, // the animation associated chart instance\n\t\tcurrentStep: 0, // the current animation step\n\t\tnumSteps: 60, // default number of steps\n\t\teasing: '', // the easing to use for this animation\n\t\trender: null, // render function used by the animation service\n\n\t\tonAnimationProgress: null, // user specified callback to fire on each step of the animation\n\t\tonAnimationComplete: null, // user specified callback to fire when the animation finishes\n\t});\n\n\tChart.animationService = {\n\t\tframeDuration: 17,\n\t\tanimations: [],\n\t\tdropFrames: 0,\n\t\trequest: null,\n\n\t\t/**\n\t\t * @param {Chart} chart - The chart to animate.\n\t\t * @param {Chart.Animation} animation - The animation that we will animate.\n\t\t * @param {Number} duration - The animation duration in ms.\n\t\t * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions\n\t\t */\n\t\taddAnimation: function(chart, animation, duration, lazy) {\n\t\t\tvar animations = this.animations;\n\t\t\tvar i, ilen;\n\n\t\t\tanimation.chart = chart;\n\n\t\t\tif (!lazy) {\n\t\t\t\tchart.animating = true;\n\t\t\t}\n\n\t\t\tfor (i = 0, ilen = animations.length; i < ilen; ++i) {\n\t\t\t\tif (animations[i].chart === chart) {\n\t\t\t\t\tanimations[i] = animation;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tanimations.push(animation);\n\n\t\t\t// If there are no animations queued, manually kickstart a digest, for lack of a better word\n\t\t\tif (animations.length === 1) {\n\t\t\t\tthis.requestAnimationFrame();\n\t\t\t}\n\t\t},\n\n\t\tcancelAnimation: function(chart) {\n\t\t\tvar index = helpers.findIndex(this.animations, function(animation) {\n\t\t\t\treturn animation.chart === chart;\n\t\t\t});\n\n\t\t\tif (index !== -1) {\n\t\t\t\tthis.animations.splice(index, 1);\n\t\t\t\tchart.animating = false;\n\t\t\t}\n\t\t},\n\n\t\trequestAnimationFrame: function() {\n\t\t\tvar me = this;\n\t\t\tif (me.request === null) {\n\t\t\t\t// Skip animation frame requests until the active one is executed.\n\t\t\t\t// This can happen when processing mouse events, e.g. 'mousemove'\n\t\t\t\t// and 'mouseout' events will trigger multiple renders.\n\t\t\t\tme.request = helpers.requestAnimFrame.call(window, function() {\n\t\t\t\t\tme.request = null;\n\t\t\t\t\tme.startDigest();\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tstartDigest: function() {\n\t\t\tvar me = this;\n\t\t\tvar startTime = Date.now();\n\t\t\tvar framesToDrop = 0;\n\n\t\t\tif (me.dropFrames > 1) {\n\t\t\t\tframesToDrop = Math.floor(me.dropFrames);\n\t\t\t\tme.dropFrames = me.dropFrames % 1;\n\t\t\t}\n\n\t\t\tme.advance(1 + framesToDrop);\n\n\t\t\tvar endTime = Date.now();\n\n\t\t\tme.dropFrames += (endTime - startTime) / me.frameDuration;\n\n\t\t\t// Do we have more stuff to animate?\n\t\t\tif (me.animations.length > 0) {\n\t\t\t\tme.requestAnimationFrame();\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tadvance: function(count) {\n\t\t\tvar animations = this.animations;\n\t\t\tvar animation, chart;\n\t\t\tvar i = 0;\n\n\t\t\twhile (i < animations.length) {\n\t\t\t\tanimation = animations[i];\n\t\t\t\tchart = animation.chart;\n\n\t\t\t\tanimation.currentStep = (animation.currentStep || 0) + count;\n\t\t\t\tanimation.currentStep = Math.min(animation.currentStep, animation.numSteps);\n\n\t\t\t\thelpers.callback(animation.render, [chart, animation], chart);\n\t\t\t\thelpers.callback(animation.onAnimationProgress, [animation], chart);\n\n\t\t\t\tif (animation.currentStep >= animation.numSteps) {\n\t\t\t\t\thelpers.callback(animation.onAnimationComplete, [animation], chart);\n\t\t\t\t\tchart.animating = false;\n\t\t\t\t\tanimations.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\t++i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Provided for backward compatibility, use Chart.Animation instead\n\t * @prop Chart.Animation#animationObject\n\t * @deprecated since version 2.6.0\n\t * @todo remove at version 3\n\t */\n\tObject.defineProperty(Chart.Animation.prototype, 'animationObject', {\n\t\tget: function() {\n\t\t\treturn this;\n\t\t}\n\t});\n\n\t/**\n\t * Provided for backward compatibility, use Chart.Animation#chart instead\n\t * @prop Chart.Animation#chartInstance\n\t * @deprecated since version 2.6.0\n\t * @todo remove at version 3\n\t */\n\tObject.defineProperty(Chart.Animation.prototype, 'chartInstance', {\n\t\tget: function() {\n\t\t\treturn this.chart;\n\t\t},\n\t\tset: function(value) {\n\t\t\tthis.chart = value;\n\t\t}\n\t});\n\n};\n\n},{\"../helpers/index\":53,\"./core.defaults\":33,\"./core.element\":34}],31:[function(require,module,exports){\n'use strict';\n\nvar defaults = require('./core.defaults');\nvar helpers = require('../helpers/index');\nvar Interaction = require('./core.interaction');\nvar layouts = require('./core.layouts');\nvar platform = require('../platforms/platform');\nvar plugins = require('./core.plugins');\n\nmodule.exports = function(Chart) {\n\n\t// Create a dictionary of chart types, to allow for extension of existing types\n\tChart.types = {};\n\n\t// Store a reference to each instance - allowing us to globally resize chart instances on window resize.\n\t// Destroy method on the chart will remove the instance of the chart from this reference.\n\tChart.instances = {};\n\n\t// Controllers available for dataset visualization eg. bar, line, slice, etc.\n\tChart.controllers = {};\n\n\t/**\n\t * Initializes the given config with global and chart default values.\n\t */\n\tfunction initConfig(config) {\n\t\tconfig = config || {};\n\n\t\t// Do NOT use configMerge() for the data object because this method merges arrays\n\t\t// and so would change references to labels and datasets, preventing data updates.\n\t\tvar data = config.data = config.data || {};\n\t\tdata.datasets = data.datasets || [];\n\t\tdata.labels = data.labels || [];\n\n\t\tconfig.options = helpers.configMerge(\n\t\t\tdefaults.global,\n\t\t\tdefaults[config.type],\n\t\t\tconfig.options || {});\n\n\t\treturn config;\n\t}\n\n\t/**\n\t * Updates the config of the chart\n\t * @param chart {Chart} chart to update the options for\n\t */\n\tfunction updateConfig(chart) {\n\t\tvar newOptions = chart.options;\n\n\t\thelpers.each(chart.scales, function(scale) {\n\t\t\tlayouts.removeBox(chart, scale);\n\t\t});\n\n\t\tnewOptions = helpers.configMerge(\n\t\t\tChart.defaults.global,\n\t\t\tChart.defaults[chart.config.type],\n\t\t\tnewOptions);\n\n\t\tchart.options = chart.config.options = newOptions;\n\t\tchart.ensureScalesHaveIDs();\n\t\tchart.buildOrUpdateScales();\n\t\t// Tooltip\n\t\tchart.tooltip._options = newOptions.tooltips;\n\t\tchart.tooltip.initialize();\n\t}\n\n\tfunction positionIsHorizontal(position) {\n\t\treturn position === 'top' || position === 'bottom';\n\t}\n\n\thelpers.extend(Chart.prototype, /** @lends Chart */ {\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tconstruct: function(item, config) {\n\t\t\tvar me = this;\n\n\t\t\tconfig = initConfig(config);\n\n\t\t\tvar context = platform.acquireContext(item, config);\n\t\t\tvar canvas = context && context.canvas;\n\t\t\tvar height = canvas && canvas.height;\n\t\t\tvar width = canvas && canvas.width;\n\n\t\t\tme.id = helpers.uid();\n\t\t\tme.ctx = context;\n\t\t\tme.canvas = canvas;\n\t\t\tme.config = config;\n\t\t\tme.width = width;\n\t\t\tme.height = height;\n\t\t\tme.aspectRatio = height ? width / height : null;\n\t\t\tme.options = config.options;\n\t\t\tme._bufferedRender = false;\n\n\t\t\t/**\n\t\t\t * Provided for backward compatibility, Chart and Chart.Controller have been merged,\n\t\t\t * the \"instance\" still need to be defined since it might be called from plugins.\n\t\t\t * @prop Chart#chart\n\t\t\t * @deprecated since version 2.6.0\n\t\t\t * @todo remove at version 3\n\t\t\t * @private\n\t\t\t */\n\t\t\tme.chart = me;\n\t\t\tme.controller = me; // chart.chart.controller #inception\n\n\t\t\t// Add the chart instance to the global namespace\n\t\t\tChart.instances[me.id] = me;\n\n\t\t\t// Define alias to the config data: `chart.data === chart.config.data`\n\t\t\tObject.defineProperty(me, 'data', {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn me.config.data;\n\t\t\t\t},\n\t\t\t\tset: function(value) {\n\t\t\t\t\tme.config.data = value;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!context || !canvas) {\n\t\t\t\t// The given item is not a compatible context2d element, let's return before finalizing\n\t\t\t\t// the chart initialization but after setting basic chart / controller properties that\n\t\t\t\t// can help to figure out that the chart is not valid (e.g chart.canvas !== null);\n\t\t\t\t// https://github.com/chartjs/Chart.js/issues/2807\n\t\t\t\tconsole.error(\"Failed to create chart: can't acquire context from the given item\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tme.initialize();\n\t\t\tme.update();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tinitialize: function() {\n\t\t\tvar me = this;\n\n\t\t\t// Before init plugin notification\n\t\t\tplugins.notify(me, 'beforeInit');\n\n\t\t\thelpers.retinaScale(me, me.options.devicePixelRatio);\n\n\t\t\tme.bindEvents();\n\n\t\t\tif (me.options.responsive) {\n\t\t\t\t// Initial resize before chart draws (must be silent to preserve initial animations).\n\t\t\t\tme.resize(true);\n\t\t\t}\n\n\t\t\t// Make sure scales have IDs and are built before we build any controllers.\n\t\t\tme.ensureScalesHaveIDs();\n\t\t\tme.buildOrUpdateScales();\n\t\t\tme.initToolTip();\n\n\t\t\t// After init plugin notification\n\t\t\tplugins.notify(me, 'afterInit');\n\n\t\t\treturn me;\n\t\t},\n\n\t\tclear: function() {\n\t\t\thelpers.canvas.clear(this);\n\t\t\treturn this;\n\t\t},\n\n\t\tstop: function() {\n\t\t\t// Stops any current animation loop occurring\n\t\t\tChart.animationService.cancelAnimation(this);\n\t\t\treturn this;\n\t\t},\n\n\t\tresize: function(silent) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tvar canvas = me.canvas;\n\t\t\tvar aspectRatio = (options.maintainAspectRatio && me.aspectRatio) || null;\n\n\t\t\t// the canvas render width and height will be casted to integers so make sure that\n\t\t\t// the canvas display style uses the same integer values to avoid blurring effect.\n\n\t\t\t// Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collased\n\t\t\tvar newWidth = Math.max(0, Math.floor(helpers.getMaximumWidth(canvas)));\n\t\t\tvar newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas)));\n\n\t\t\tif (me.width === newWidth && me.height === newHeight) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcanvas.width = me.width = newWidth;\n\t\t\tcanvas.height = me.height = newHeight;\n\t\t\tcanvas.style.width = newWidth + 'px';\n\t\t\tcanvas.style.height = newHeight + 'px';\n\n\t\t\thelpers.retinaScale(me, options.devicePixelRatio);\n\n\t\t\tif (!silent) {\n\t\t\t\t// Notify any plugins about the resize\n\t\t\t\tvar newSize = {width: newWidth, height: newHeight};\n\t\t\t\tplugins.notify(me, 'resize', [newSize]);\n\n\t\t\t\t// Notify of resize\n\t\t\t\tif (me.options.onResize) {\n\t\t\t\t\tme.options.onResize(me, newSize);\n\t\t\t\t}\n\n\t\t\t\tme.stop();\n\t\t\t\tme.update(me.options.responsiveAnimationDuration);\n\t\t\t}\n\t\t},\n\n\t\tensureScalesHaveIDs: function() {\n\t\t\tvar options = this.options;\n\t\t\tvar scalesOptions = options.scales || {};\n\t\t\tvar scaleOptions = options.scale;\n\n\t\t\thelpers.each(scalesOptions.xAxes, function(xAxisOptions, index) {\n\t\t\t\txAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);\n\t\t\t});\n\n\t\t\thelpers.each(scalesOptions.yAxes, function(yAxisOptions, index) {\n\t\t\t\tyAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);\n\t\t\t});\n\n\t\t\tif (scaleOptions) {\n\t\t\t\tscaleOptions.id = scaleOptions.id || 'scale';\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Builds a map of scale ID to scale object for future lookup.\n\t\t */\n\t\tbuildOrUpdateScales: function() {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tvar scales = me.scales || {};\n\t\t\tvar items = [];\n\t\t\tvar updated = Object.keys(scales).reduce(function(obj, id) {\n\t\t\t\tobj[id] = false;\n\t\t\t\treturn obj;\n\t\t\t}, {});\n\n\t\t\tif (options.scales) {\n\t\t\t\titems = items.concat(\n\t\t\t\t\t(options.scales.xAxes || []).map(function(xAxisOptions) {\n\t\t\t\t\t\treturn {options: xAxisOptions, dtype: 'category', dposition: 'bottom'};\n\t\t\t\t\t}),\n\t\t\t\t\t(options.scales.yAxes || []).map(function(yAxisOptions) {\n\t\t\t\t\t\treturn {options: yAxisOptions, dtype: 'linear', dposition: 'left'};\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (options.scale) {\n\t\t\t\titems.push({\n\t\t\t\t\toptions: options.scale,\n\t\t\t\t\tdtype: 'radialLinear',\n\t\t\t\t\tisDefault: true,\n\t\t\t\t\tdposition: 'chartArea'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thelpers.each(items, function(item) {\n\t\t\t\tvar scaleOptions = item.options;\n\t\t\t\tvar id = scaleOptions.id;\n\t\t\t\tvar scaleType = helpers.valueOrDefault(scaleOptions.type, item.dtype);\n\n\t\t\t\tif (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {\n\t\t\t\t\tscaleOptions.position = item.dposition;\n\t\t\t\t}\n\n\t\t\t\tupdated[id] = true;\n\t\t\t\tvar scale = null;\n\t\t\t\tif (id in scales && scales[id].type === scaleType) {\n\t\t\t\t\tscale = scales[id];\n\t\t\t\t\tscale.options = scaleOptions;\n\t\t\t\t\tscale.ctx = me.ctx;\n\t\t\t\t\tscale.chart = me;\n\t\t\t\t} else {\n\t\t\t\t\tvar scaleClass = Chart.scaleService.getScaleConstructor(scaleType);\n\t\t\t\t\tif (!scaleClass) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tscale = new scaleClass({\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\ttype: scaleType,\n\t\t\t\t\t\toptions: scaleOptions,\n\t\t\t\t\t\tctx: me.ctx,\n\t\t\t\t\t\tchart: me\n\t\t\t\t\t});\n\t\t\t\t\tscales[scale.id] = scale;\n\t\t\t\t}\n\n\t\t\t\tscale.mergeTicksOptions();\n\n\t\t\t\t// TODO(SB): I think we should be able to remove this custom case (options.scale)\n\t\t\t\t// and consider it as a regular scale part of the \"scales\"\" map only! This would\n\t\t\t\t// make the logic easier and remove some useless? custom code.\n\t\t\t\tif (item.isDefault) {\n\t\t\t\t\tme.scale = scale;\n\t\t\t\t}\n\t\t\t});\n\t\t\t// clear up discarded scales\n\t\t\thelpers.each(updated, function(hasUpdated, id) {\n\t\t\t\tif (!hasUpdated) {\n\t\t\t\t\tdelete scales[id];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tme.scales = scales;\n\n\t\t\tChart.scaleService.addScalesToLayout(this);\n\t\t},\n\n\t\tbuildOrUpdateControllers: function() {\n\t\t\tvar me = this;\n\t\t\tvar types = [];\n\t\t\tvar newControllers = [];\n\n\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tvar meta = me.getDatasetMeta(datasetIndex);\n\t\t\t\tvar type = dataset.type || me.config.type;\n\n\t\t\t\tif (meta.type && meta.type !== type) {\n\t\t\t\t\tme.destroyDatasetMeta(datasetIndex);\n\t\t\t\t\tmeta = me.getDatasetMeta(datasetIndex);\n\t\t\t\t}\n\t\t\t\tmeta.type = type;\n\n\t\t\t\ttypes.push(meta.type);\n\n\t\t\t\tif (meta.controller) {\n\t\t\t\t\tmeta.controller.updateIndex(datasetIndex);\n\t\t\t\t\tmeta.controller.linkScales();\n\t\t\t\t} else {\n\t\t\t\t\tvar ControllerClass = Chart.controllers[meta.type];\n\t\t\t\t\tif (ControllerClass === undefined) {\n\t\t\t\t\t\tthrow new Error('\"' + meta.type + '\" is not a chart type.');\n\t\t\t\t\t}\n\n\t\t\t\t\tmeta.controller = new ControllerClass(me, datasetIndex);\n\t\t\t\t\tnewControllers.push(meta.controller);\n\t\t\t\t}\n\t\t\t}, me);\n\n\t\t\treturn newControllers;\n\t\t},\n\n\t\t/**\n\t\t * Reset the elements of all datasets\n\t\t * @private\n\t\t */\n\t\tresetElements: function() {\n\t\t\tvar me = this;\n\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tme.getDatasetMeta(datasetIndex).controller.reset();\n\t\t\t}, me);\n\t\t},\n\n\t\t/**\n\t\t* Resets the chart back to it's state before the initial animation\n\t\t*/\n\t\treset: function() {\n\t\t\tthis.resetElements();\n\t\t\tthis.tooltip.initialize();\n\t\t},\n\n\t\tupdate: function(config) {\n\t\t\tvar me = this;\n\n\t\t\tif (!config || typeof config !== 'object') {\n\t\t\t\t// backwards compatibility\n\t\t\t\tconfig = {\n\t\t\t\t\tduration: config,\n\t\t\t\t\tlazy: arguments[1]\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tupdateConfig(me);\n\n\t\t\t// plugins options references might have change, let's invalidate the cache\n\t\t\t// https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\n\t\t\tplugins._invalidate(me);\n\n\t\t\tif (plugins.notify(me, 'beforeUpdate') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// In case the entire data object changed\n\t\t\tme.tooltip._data = me.data;\n\n\t\t\t// Make sure dataset controllers are updated and new controllers are reset\n\t\t\tvar newControllers = me.buildOrUpdateControllers();\n\n\t\t\t// Make sure all dataset controllers have correct meta data counts\n\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tme.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();\n\t\t\t}, me);\n\n\t\t\tme.updateLayout();\n\n\t\t\t// Can only reset the new controllers after the scales have been updated\n\t\t\tif (me.options.animation && me.options.animation.duration) {\n\t\t\t\thelpers.each(newControllers, function(controller) {\n\t\t\t\t\tcontroller.reset();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tme.updateDatasets();\n\n\t\t\t// Need to reset tooltip in case it is displayed with elements that are removed\n\t\t\t// after update.\n\t\t\tme.tooltip.initialize();\n\n\t\t\t// Last active contains items that were previously in the tooltip.\n\t\t\t// When we reset the tooltip, we need to clear it\n\t\t\tme.lastActive = [];\n\n\t\t\t// Do this before render so that any plugins that need final scale updates can use it\n\t\t\tplugins.notify(me, 'afterUpdate');\n\n\t\t\tif (me._bufferedRender) {\n\t\t\t\tme._bufferedRequest = {\n\t\t\t\t\tduration: config.duration,\n\t\t\t\t\teasing: config.easing,\n\t\t\t\t\tlazy: config.lazy\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tme.render(config);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\n\t\t * hook, in which case, plugins will not be called on `afterLayout`.\n\t\t * @private\n\t\t */\n\t\tupdateLayout: function() {\n\t\t\tvar me = this;\n\n\t\t\tif (plugins.notify(me, 'beforeLayout') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlayouts.update(this, this.width, this.height);\n\n\t\t\t/**\n\t\t\t * Provided for backward compatibility, use `afterLayout` instead.\n\t\t\t * @method IPlugin#afterScaleUpdate\n\t\t\t * @deprecated since version 2.5.0\n\t\t\t * @todo remove at version 3\n\t\t\t * @private\n\t\t\t */\n\t\t\tplugins.notify(me, 'afterScaleUpdate');\n\t\t\tplugins.notify(me, 'afterLayout');\n\t\t},\n\n\t\t/**\n\t\t * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\n\t\t * @private\n\t\t */\n\t\tupdateDatasets: function() {\n\t\t\tvar me = this;\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetsUpdate') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n\t\t\t\tme.updateDataset(i);\n\t\t\t}\n\n\t\t\tplugins.notify(me, 'afterDatasetsUpdate');\n\t\t},\n\n\t\t/**\n\t\t * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetUpdate`.\n\t\t * @private\n\t\t */\n\t\tupdateDataset: function(index) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getDatasetMeta(index);\n\t\t\tvar args = {\n\t\t\t\tmeta: meta,\n\t\t\t\tindex: index\n\t\t\t};\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmeta.controller.update();\n\n\t\t\tplugins.notify(me, 'afterDatasetUpdate', [args]);\n\t\t},\n\n\t\trender: function(config) {\n\t\t\tvar me = this;\n\n\t\t\tif (!config || typeof config !== 'object') {\n\t\t\t\t// backwards compatibility\n\t\t\t\tconfig = {\n\t\t\t\t\tduration: config,\n\t\t\t\t\tlazy: arguments[1]\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tvar duration = config.duration;\n\t\t\tvar lazy = config.lazy;\n\n\t\t\tif (plugins.notify(me, 'beforeRender') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar animationOptions = me.options.animation;\n\t\t\tvar onComplete = function(animation) {\n\t\t\t\tplugins.notify(me, 'afterRender');\n\t\t\t\thelpers.callback(animationOptions && animationOptions.onComplete, [animation], me);\n\t\t\t};\n\n\t\t\tif (animationOptions && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && animationOptions.duration !== 0))) {\n\t\t\t\tvar animation = new Chart.Animation({\n\t\t\t\t\tnumSteps: (duration || animationOptions.duration) / 16.66, // 60 fps\n\t\t\t\t\teasing: config.easing || animationOptions.easing,\n\n\t\t\t\t\trender: function(chart, animationObject) {\n\t\t\t\t\t\tvar easingFunction = helpers.easing.effects[animationObject.easing];\n\t\t\t\t\t\tvar currentStep = animationObject.currentStep;\n\t\t\t\t\t\tvar stepDecimal = currentStep / animationObject.numSteps;\n\n\t\t\t\t\t\tchart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);\n\t\t\t\t\t},\n\n\t\t\t\t\tonAnimationProgress: animationOptions.onProgress,\n\t\t\t\t\tonAnimationComplete: onComplete\n\t\t\t\t});\n\n\t\t\t\tChart.animationService.addAnimation(me, animation, duration, lazy);\n\t\t\t} else {\n\t\t\t\tme.draw();\n\n\t\t\t\t// See https://github.com/chartjs/Chart.js/issues/3781\n\t\t\t\tonComplete(new Chart.Animation({numSteps: 0, chart: me}));\n\t\t\t}\n\n\t\t\treturn me;\n\t\t},\n\n\t\tdraw: function(easingValue) {\n\t\t\tvar me = this;\n\n\t\t\tme.clear();\n\n\t\t\tif (helpers.isNullOrUndef(easingValue)) {\n\t\t\t\teasingValue = 1;\n\t\t\t}\n\n\t\t\tme.transition(easingValue);\n\n\t\t\tif (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Draw all the scales\n\t\t\thelpers.each(me.boxes, function(box) {\n\t\t\t\tbox.draw(me.chartArea);\n\t\t\t}, me);\n\n\t\t\tif (me.scale) {\n\t\t\t\tme.scale.draw();\n\t\t\t}\n\n\t\t\tme.drawDatasets(easingValue);\n\t\t\tme._drawTooltip(easingValue);\n\n\t\t\tplugins.notify(me, 'afterDraw', [easingValue]);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\ttransition: function(easingValue) {\n\t\t\tvar me = this;\n\n\t\t\tfor (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\tif (me.isDatasetVisible(i)) {\n\t\t\t\t\tme.getDatasetMeta(i).controller.transition(easingValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.tooltip.transition(easingValue);\n\t\t},\n\n\t\t/**\n\t\t * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\n\t\t * @private\n\t\t */\n\t\tdrawDatasets: function(easingValue) {\n\t\t\tvar me = this;\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Draw datasets reversed to support proper line stacking\n\t\t\tfor (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {\n\t\t\t\tif (me.isDatasetVisible(i)) {\n\t\t\t\t\tme.drawDataset(i, easingValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplugins.notify(me, 'afterDatasetsDraw', [easingValue]);\n\t\t},\n\n\t\t/**\n\t\t * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetDraw`.\n\t\t * @private\n\t\t */\n\t\tdrawDataset: function(index, easingValue) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getDatasetMeta(index);\n\t\t\tvar args = {\n\t\t\t\tmeta: meta,\n\t\t\t\tindex: index,\n\t\t\t\teasingValue: easingValue\n\t\t\t};\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmeta.controller.draw(easingValue);\n\n\t\t\tplugins.notify(me, 'afterDatasetDraw', [args]);\n\t\t},\n\n\t\t/**\n\t\t * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`\n\t\t * hook, in which case, plugins will not be called on `afterTooltipDraw`.\n\t\t * @private\n\t\t */\n\t\t_drawTooltip: function(easingValue) {\n\t\t\tvar me = this;\n\t\t\tvar tooltip = me.tooltip;\n\t\t\tvar args = {\n\t\t\t\ttooltip: tooltip,\n\t\t\t\teasingValue: easingValue\n\t\t\t};\n\n\t\t\tif (plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttooltip.draw();\n\n\t\t\tplugins.notify(me, 'afterTooltipDraw', [args]);\n\t\t},\n\n\t\t// Get the single element that was clicked on\n\t\t// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw\n\t\tgetElementAtEvent: function(e) {\n\t\t\treturn Interaction.modes.single(this, e);\n\t\t},\n\n\t\tgetElementsAtEvent: function(e) {\n\t\t\treturn Interaction.modes.label(this, e, {intersect: true});\n\t\t},\n\n\t\tgetElementsAtXAxis: function(e) {\n\t\t\treturn Interaction.modes['x-axis'](this, e, {intersect: true});\n\t\t},\n\n\t\tgetElementsAtEventForMode: function(e, mode, options) {\n\t\t\tvar method = Interaction.modes[mode];\n\t\t\tif (typeof method === 'function') {\n\t\t\t\treturn method(this, e, options);\n\t\t\t}\n\n\t\t\treturn [];\n\t\t},\n\n\t\tgetDatasetAtEvent: function(e) {\n\t\t\treturn Interaction.modes.dataset(this, e, {intersect: true});\n\t\t},\n\n\t\tgetDatasetMeta: function(datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.data.datasets[datasetIndex];\n\t\t\tif (!dataset._meta) {\n\t\t\t\tdataset._meta = {};\n\t\t\t}\n\n\t\t\tvar meta = dataset._meta[me.id];\n\t\t\tif (!meta) {\n\t\t\t\tmeta = dataset._meta[me.id] = {\n\t\t\t\t\ttype: null,\n\t\t\t\t\tdata: [],\n\t\t\t\t\tdataset: null,\n\t\t\t\t\tcontroller: null,\n\t\t\t\t\thidden: null,\t\t\t// See isDatasetVisible() comment\n\t\t\t\t\txAxisID: null,\n\t\t\t\t\tyAxisID: null\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn meta;\n\t\t},\n\n\t\tgetVisibleDatasetCount: function() {\n\t\t\tvar count = 0;\n\t\t\tfor (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n\t\t\t\tif (this.isDatasetVisible(i)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn count;\n\t\t},\n\n\t\tisDatasetVisible: function(datasetIndex) {\n\t\t\tvar meta = this.getDatasetMeta(datasetIndex);\n\n\t\t\t// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\n\t\t\t// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\n\t\t\treturn typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;\n\t\t},\n\n\t\tgenerateLegend: function() {\n\t\t\treturn this.options.legendCallback(this);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tdestroyDatasetMeta: function(datasetIndex) {\n\t\t\tvar id = this.id;\n\t\t\tvar dataset = this.data.datasets[datasetIndex];\n\t\t\tvar meta = dataset._meta && dataset._meta[id];\n\n\t\t\tif (meta) {\n\t\t\t\tmeta.controller.destroy();\n\t\t\t\tdelete dataset._meta[id];\n\t\t\t}\n\t\t},\n\n\t\tdestroy: function() {\n\t\t\tvar me = this;\n\t\t\tvar canvas = me.canvas;\n\t\t\tvar i, ilen;\n\n\t\t\tme.stop();\n\n\t\t\t// dataset controllers need to cleanup associated data\n\t\t\tfor (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n\t\t\t\tme.destroyDatasetMeta(i);\n\t\t\t}\n\n\t\t\tif (canvas) {\n\t\t\t\tme.unbindEvents();\n\t\t\t\thelpers.canvas.clear(me);\n\t\t\t\tplatform.releaseContext(me.ctx);\n\t\t\t\tme.canvas = null;\n\t\t\t\tme.ctx = null;\n\t\t\t}\n\n\t\t\tplugins.notify(me, 'destroy');\n\n\t\t\tdelete Chart.instances[me.id];\n\t\t},\n\n\t\ttoBase64Image: function() {\n\t\t\treturn this.canvas.toDataURL.apply(this.canvas, arguments);\n\t\t},\n\n\t\tinitToolTip: function() {\n\t\t\tvar me = this;\n\t\t\tme.tooltip = new Chart.Tooltip({\n\t\t\t\t_chart: me,\n\t\t\t\t_chartInstance: me, // deprecated, backward compatibility\n\t\t\t\t_data: me.data,\n\t\t\t\t_options: me.options.tooltips\n\t\t\t}, me);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tbindEvents: function() {\n\t\t\tvar me = this;\n\t\t\tvar listeners = me._listeners = {};\n\t\t\tvar listener = function() {\n\t\t\t\tme.eventHandler.apply(me, arguments);\n\t\t\t};\n\n\t\t\thelpers.each(me.options.events, function(type) {\n\t\t\t\tplatform.addEventListener(me, type, listener);\n\t\t\t\tlisteners[type] = listener;\n\t\t\t});\n\n\t\t\t// Elements used to detect size change should not be injected for non responsive charts.\n\t\t\t// See https://github.com/chartjs/Chart.js/issues/2210\n\t\t\tif (me.options.responsive) {\n\t\t\t\tlistener = function() {\n\t\t\t\t\tme.resize();\n\t\t\t\t};\n\n\t\t\t\tplatform.addEventListener(me, 'resize', listener);\n\t\t\t\tlisteners.resize = listener;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tunbindEvents: function() {\n\t\t\tvar me = this;\n\t\t\tvar listeners = me._listeners;\n\t\t\tif (!listeners) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdelete me._listeners;\n\t\t\thelpers.each(listeners, function(listener, type) {\n\t\t\t\tplatform.removeEventListener(me, type, listener);\n\t\t\t});\n\t\t},\n\n\t\tupdateHoverStyle: function(elements, mode, enabled) {\n\t\t\tvar method = enabled ? 'setHoverStyle' : 'removeHoverStyle';\n\t\t\tvar element, i, ilen;\n\n\t\t\tfor (i = 0, ilen = elements.length; i < ilen; ++i) {\n\t\t\t\telement = elements[i];\n\t\t\t\tif (element) {\n\t\t\t\t\tthis.getDatasetMeta(element._datasetIndex).controller[method](element);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\teventHandler: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar tooltip = me.tooltip;\n\n\t\t\tif (plugins.notify(me, 'beforeEvent', [e]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Buffer any update calls so that renders do not occur\n\t\t\tme._bufferedRender = true;\n\t\t\tme._bufferedRequest = null;\n\n\t\t\tvar changed = me.handleEvent(e);\n\t\t\t// for smooth tooltip animations issue #4989\n\t\t\t// the tooltip should be the source of change\n\t\t\t// Animation check workaround:\n\t\t\t// tooltip._start will be null when tooltip isn't animating\n\t\t\tif (tooltip) {\n\t\t\t\tchanged = tooltip._start\n\t\t\t\t\t? tooltip.handleEvent(e)\n\t\t\t\t\t: changed | tooltip.handleEvent(e);\n\t\t\t}\n\n\t\t\tplugins.notify(me, 'afterEvent', [e]);\n\n\t\t\tvar bufferedRequest = me._bufferedRequest;\n\t\t\tif (bufferedRequest) {\n\t\t\t\t// If we have an update that was triggered, we need to do a normal render\n\t\t\t\tme.render(bufferedRequest);\n\t\t\t} else if (changed && !me.animating) {\n\t\t\t\t// If entering, leaving, or changing elements, animate the change via pivot\n\t\t\t\tme.stop();\n\n\t\t\t\t// We only need to render at this point. Updating will cause scales to be\n\t\t\t\t// recomputed generating flicker & using more memory than necessary.\n\t\t\t\tme.render(me.options.hover.animationDuration, true);\n\t\t\t}\n\n\t\t\tme._bufferedRender = false;\n\t\t\tme._bufferedRequest = null;\n\n\t\t\treturn me;\n\t\t},\n\n\t\t/**\n\t\t * Handle an event\n\t\t * @private\n\t\t * @param {IEvent} event the event to handle\n\t\t * @return {Boolean} true if the chart needs to re-render\n\t\t */\n\t\thandleEvent: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options || {};\n\t\t\tvar hoverOptions = options.hover;\n\t\t\tvar changed = false;\n\n\t\t\tme.lastActive = me.lastActive || [];\n\n\t\t\t// Find Active Elements for hover and tooltips\n\t\t\tif (e.type === 'mouseout') {\n\t\t\t\tme.active = [];\n\t\t\t} else {\n\t\t\t\tme.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);\n\t\t\t}\n\n\t\t\t// Invoke onHover hook\n\t\t\t// Need to call with native event here to not break backwards compatibility\n\t\t\thelpers.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);\n\n\t\t\tif (e.type === 'mouseup' || e.type === 'click') {\n\t\t\t\tif (options.onClick) {\n\t\t\t\t\t// Use e.native here for backwards compatibility\n\t\t\t\t\toptions.onClick.call(me, e.native, me.active);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove styling for last active (even if it may still be active)\n\t\t\tif (me.lastActive.length) {\n\t\t\t\tme.updateHoverStyle(me.lastActive, hoverOptions.mode, false);\n\t\t\t}\n\n\t\t\t// Built in hover styling\n\t\t\tif (me.active.length && hoverOptions.mode) {\n\t\t\t\tme.updateHoverStyle(me.active, hoverOptions.mode, true);\n\t\t\t}\n\n\t\t\tchanged = !helpers.arrayEquals(me.active, me.lastActive);\n\n\t\t\t// Remember Last Actives\n\t\t\tme.lastActive = me.active;\n\n\t\t\treturn changed;\n\t\t}\n\t});\n\n\t/**\n\t * Provided for backward compatibility, use Chart instead.\n\t * @class Chart.Controller\n\t * @deprecated since version 2.6.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\tChart.Controller = Chart;\n};\n\n},{\"../helpers/index\":53,\"../platforms/platform\":56,\"./core.defaults\":33,\"./core.interaction\":36,\"./core.layouts\":38,\"./core.plugins\":39}],32:[function(require,module,exports){\n'use strict';\n\nvar helpers = require('../helpers/index');\n\nmodule.exports = function(Chart) {\n\n\tvar arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\n\n\t/**\n\t * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\n\t * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\n\t * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.\n\t */\n\tfunction listenArrayEvents(array, listener) {\n\t\tif (array._chartjs) {\n\t\t\tarray._chartjs.listeners.push(listener);\n\t\t\treturn;\n\t\t}\n\n\t\tObject.defineProperty(array, '_chartjs', {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: {\n\t\t\t\tlisteners: [listener]\n\t\t\t}\n\t\t});\n\n\t\tarrayEvents.forEach(function(key) {\n\t\t\tvar method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);\n\t\t\tvar base = array[key];\n\n\t\t\tObject.defineProperty(array, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: function() {\n\t\t\t\t\tvar args = Array.prototype.slice.call(arguments);\n\t\t\t\t\tvar res = base.apply(this, args);\n\n\t\t\t\t\thelpers.each(array._chartjs.listeners, function(object) {\n\t\t\t\t\t\tif (typeof object[method] === 'function') {\n\t\t\t\t\t\t\tobject[method].apply(object, args);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Removes the given array event listener and cleanup extra attached properties (such as\n\t * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\n\t */\n\tfunction unlistenArrayEvents(array, listener) {\n\t\tvar stub = array._chartjs;\n\t\tif (!stub) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar listeners = stub.listeners;\n\t\tvar index = listeners.indexOf(listener);\n\t\tif (index !== -1) {\n\t\t\tlisteners.splice(index, 1);\n\t\t}\n\n\t\tif (listeners.length > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tarrayEvents.forEach(function(key) {\n\t\t\tdelete array[key];\n\t\t});\n\n\t\tdelete array._chartjs;\n\t}\n\n\t// Base class for all dataset controllers (line, bar, etc)\n\tChart.DatasetController = function(chart, datasetIndex) {\n\t\tthis.initialize(chart, datasetIndex);\n\t};\n\n\thelpers.extend(Chart.DatasetController.prototype, {\n\n\t\t/**\n\t\t * Element type used to generate a meta dataset (e.g. Chart.element.Line).\n\t\t * @type {Chart.core.element}\n\t\t */\n\t\tdatasetElementType: null,\n\n\t\t/**\n\t\t * Element type used to generate a meta data (e.g. Chart.element.Point).\n\t\t * @type {Chart.core.element}\n\t\t */\n\t\tdataElementType: null,\n\n\t\tinitialize: function(chart, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tme.chart = chart;\n\t\t\tme.index = datasetIndex;\n\t\t\tme.linkScales();\n\t\t\tme.addElements();\n\t\t},\n\n\t\tupdateIndex: function(datasetIndex) {\n\t\t\tthis.index = datasetIndex;\n\t\t},\n\n\t\tlinkScales: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar dataset = me.getDataset();\n\n\t\t\tif (meta.xAxisID === null || !(meta.xAxisID in me.chart.scales)) {\n\t\t\t\tmeta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;\n\t\t\t}\n\t\t\tif (meta.yAxisID === null || !(meta.yAxisID in me.chart.scales)) {\n\t\t\t\tmeta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;\n\t\t\t}\n\t\t},\n\n\t\tgetDataset: function() {\n\t\t\treturn this.chart.data.datasets[this.index];\n\t\t},\n\n\t\tgetMeta: function() {\n\t\t\treturn this.chart.getDatasetMeta(this.index);\n\t\t},\n\n\t\tgetScaleForId: function(scaleID) {\n\t\t\treturn this.chart.scales[scaleID];\n\t\t},\n\n\t\treset: function() {\n\t\t\tthis.update(true);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tdestroy: function() {\n\t\t\tif (this._data) {\n\t\t\t\tunlistenArrayEvents(this._data, this);\n\t\t\t}\n\t\t},\n\n\t\tcreateMetaDataset: function() {\n\t\t\tvar me = this;\n\t\t\tvar type = me.datasetElementType;\n\t\t\treturn type && new type({\n\t\t\t\t_chart: me.chart,\n\t\t\t\t_datasetIndex: me.index\n\t\t\t});\n\t\t},\n\n\t\tcreateMetaData: function(index) {\n\t\t\tvar me = this;\n\t\t\tvar type = me.dataElementType;\n\t\t\treturn type && new type({\n\t\t\t\t_chart: me.chart,\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index\n\t\t\t});\n\t\t},\n\n\t\taddElements: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar data = me.getDataset().data || [];\n\t\t\tvar metaData = meta.data;\n\t\t\tvar i, ilen;\n\n\t\t\tfor (i = 0, ilen = data.length; i < ilen; ++i) {\n\t\t\t\tmetaData[i] = metaData[i] || me.createMetaData(i);\n\t\t\t}\n\n\t\t\tmeta.dataset = meta.dataset || me.createMetaDataset();\n\t\t},\n\n\t\taddElementAndReset: function(index) {\n\t\t\tvar element = this.createMetaData(index);\n\t\t\tthis.getMeta().data.splice(index, 0, element);\n\t\t\tthis.updateElement(element, index, true);\n\t\t},\n\n\t\tbuildOrUpdateElements: function() {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar data = dataset.data || (dataset.data = []);\n\n\t\t\t// In order to correctly handle data addition/deletion animation (an thus simulate\n\t\t\t// real-time charts), we need to monitor these data modifications and synchronize\n\t\t\t// the internal meta data accordingly.\n\t\t\tif (me._data !== data) {\n\t\t\t\tif (me._data) {\n\t\t\t\t\t// This case happens when the user replaced the data array instance.\n\t\t\t\t\tunlistenArrayEvents(me._data, me);\n\t\t\t\t}\n\n\t\t\t\tlistenArrayEvents(data, me);\n\t\t\t\tme._data = data;\n\t\t\t}\n\n\t\t\t// Re-sync meta data in case the user replaced the data array or if we missed\n\t\t\t// any updates and so make sure that we handle number of datapoints changing.\n\t\t\tme.resyncElements();\n\t\t},\n\n\t\tupdate: helpers.noop,\n\n\t\ttransition: function(easingValue) {\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar elements = meta.data || [];\n\t\t\tvar ilen = elements.length;\n\t\t\tvar i = 0;\n\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\telements[i].transition(easingValue);\n\t\t\t}\n\n\t\t\tif (meta.dataset) {\n\t\t\t\tmeta.dataset.transition(easingValue);\n\t\t\t}\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar elements = meta.data || [];\n\t\t\tvar ilen = elements.length;\n\t\t\tvar i = 0;\n\n\t\t\tif (meta.dataset) {\n\t\t\t\tmeta.dataset.draw();\n\t\t\t}\n\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\telements[i].draw();\n\t\t\t}\n\t\t},\n\n\t\tremoveHoverStyle: function(element, elementOpts) {\n\t\t\tvar dataset = this.chart.data.datasets[element._datasetIndex];\n\t\t\tvar index = element._index;\n\t\t\tvar custom = element.custom || {};\n\t\t\tvar valueOrDefault = helpers.valueAtIndexOrDefault;\n\t\t\tvar model = element._model;\n\n\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);\n\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);\n\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);\n\t\t},\n\n\t\tsetHoverStyle: function(element) {\n\t\t\tvar dataset = this.chart.data.datasets[element._datasetIndex];\n\t\t\tvar index = element._index;\n\t\t\tvar custom = element.custom || {};\n\t\t\tvar valueOrDefault = helpers.valueAtIndexOrDefault;\n\t\t\tvar getHoverColor = helpers.getHoverColor;\n\t\t\tvar model = element._model;\n\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tresyncElements: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar data = me.getDataset().data;\n\t\t\tvar numMeta = meta.data.length;\n\t\t\tvar numData = data.length;\n\n\t\t\tif (numData < numMeta) {\n\t\t\t\tmeta.data.splice(numData, numMeta - numData);\n\t\t\t} else if (numData > numMeta) {\n\t\t\t\tme.insertElements(numMeta, numData - numMeta);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tinsertElements: function(start, count) {\n\t\t\tfor (var i = 0; i < count; ++i) {\n\t\t\t\tthis.addElementAndReset(start + i);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataPush: function() {\n\t\t\tthis.insertElements(this.getDataset().data.length - 1, arguments.length);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataPop: function() {\n\t\t\tthis.getMeta().data.pop();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataShift: function() {\n\t\t\tthis.getMeta().data.shift();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataSplice: function(start, count) {\n\t\t\tthis.getMeta().data.splice(start, count);\n\t\t\tthis.insertElements(start, arguments.length - 2);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataUnshift: function() {\n\t\t\tthis.insertElements(0, arguments.length);\n\t\t}\n\t});\n\n\tChart.DatasetController.extend = helpers.inherits;\n};\n\n},{\"../helpers/index\":53}],33:[function(require,module,exports){\n'use strict';\n\nvar helpers = require('../helpers/index');\n\nmodule.exports = {\n\t/**\n\t * @private\n\t */\n\t_set: function(scope, values) {\n\t\treturn helpers.merge(this[scope] || (this[scope] = {}), values);\n\t}\n};\n\n},{\"../helpers/index\":53}],34:[function(require,module,exports){\n'use strict';\n\nvar color = require('chartjs-color');\nvar helpers = require('../helpers/index');\n\nfunction interpolate(start, view, model, ease) {\n\tvar keys = Object.keys(model);\n\tvar i, ilen, key, actual, origin, target, type, c0, c1;\n\n\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\tkey = keys[i];\n\n\t\ttarget = model[key];\n\n\t\t// if a value is added to the model after pivot() has been called, the view\n\t\t// doesn't contain it, so let's initialize the view to the target value.\n\t\tif (!view.hasOwnProperty(key)) {\n\t\t\tview[key] = target;\n\t\t}\n\n\t\tactual = view[key];\n\n\t\tif (actual === target || key[0] === '_') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!start.hasOwnProperty(key)) {\n\t\t\tstart[key] = actual;\n\t\t}\n\n\t\torigin = start[key];\n\n\t\ttype = typeof target;\n\n\t\tif (type === typeof origin) {\n\t\t\tif (type === 'string') {\n\t\t\t\tc0 = color(origin);\n\t\t\t\tif (c0.valid) {\n\t\t\t\t\tc1 = color(target);\n\t\t\t\t\tif (c1.valid) {\n\t\t\t\t\t\tview[key] = c1.mix(c0, ease).rgbString();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'number' && isFinite(origin) && isFinite(target)) {\n\t\t\t\tview[key] = origin + (target - origin) * ease;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tview[key] = target;\n\t}\n}\n\nvar Element = function(configuration) {\n\thelpers.extend(this, configuration);\n\tthis.initialize.apply(this, arguments);\n};\n\nhelpers.extend(Element.prototype, {\n\n\tinitialize: function() {\n\t\tthis.hidden = false;\n\t},\n\n\tpivot: function() {\n\t\tvar me = this;\n\t\tif (!me._view) {\n\t\t\tme._view = helpers.clone(me._model);\n\t\t}\n\t\tme._start = {};\n\t\treturn me;\n\t},\n\n\ttransition: function(ease) {\n\t\tvar me = this;\n\t\tvar model = me._model;\n\t\tvar start = me._start;\n\t\tvar view = me._view;\n\n\t\t// No animation -> No Transition\n\t\tif (!model || ease === 1) {\n\t\t\tme._view = model;\n\t\t\tme._start = null;\n\t\t\treturn me;\n\t\t}\n\n\t\tif (!view) {\n\t\t\tview = me._view = {};\n\t\t}\n\n\t\tif (!start) {\n\t\t\tstart = me._start = {};\n\t\t}\n\n\t\tinterpolate(start, view, model, ease);\n\n\t\treturn me;\n\t},\n\n\ttooltipPosition: function() {\n\t\treturn {\n\t\t\tx: this._model.x,\n\t\t\ty: this._model.y\n\t\t};\n\t},\n\n\thasValue: function() {\n\t\treturn helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);\n\t}\n});\n\nElement.extend = helpers.inherits;\n\nmodule.exports = Element;\n\n},{\"../helpers/index\":53,\"chartjs-color\":10}],35:[function(require,module,exports){\n/* global window: false */\n/* global document: false */\n'use strict';\n\nvar color = require('chartjs-color');\nvar defaults = require('./core.defaults');\nvar helpers = require('../helpers/index');\n\nmodule.exports = function(Chart) {\n\n\t// -- Basic js utility methods\n\n\thelpers.configMerge = function(/* objects ... */) {\n\t\treturn helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {\n\t\t\tmerger: function(key, target, source, options) {\n\t\t\t\tvar tval = target[key] || {};\n\t\t\t\tvar sval = source[key];\n\n\t\t\t\tif (key === 'scales') {\n\t\t\t\t\t// scale config merging is complex. Add our own function here for that\n\t\t\t\t\ttarget[key] = helpers.scaleMerge(tval, sval);\n\t\t\t\t} else if (key === 'scale') {\n\t\t\t\t\t// used in polar area & radar charts since there is only one scale\n\t\t\t\t\ttarget[key] = helpers.merge(tval, [Chart.scaleService.getScaleDefaults(sval.type), sval]);\n\t\t\t\t} else {\n\t\t\t\t\thelpers._merger(key, target, source, options);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\thelpers.scaleMerge = function(/* objects ... */) {\n\t\treturn helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {\n\t\t\tmerger: function(key, target, source, options) {\n\t\t\t\tif (key === 'xAxes' || key === 'yAxes') {\n\t\t\t\t\tvar slen = source[key].length;\n\t\t\t\t\tvar i, type, scale;\n\n\t\t\t\t\tif (!target[key]) {\n\t\t\t\t\t\ttarget[key] = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (i = 0; i < slen; ++i) {\n\t\t\t\t\t\tscale = source[key][i];\n\t\t\t\t\t\ttype = helpers.valueOrDefault(scale.type, key === 'xAxes' ? 'category' : 'linear');\n\n\t\t\t\t\t\tif (i >= target[key].length) {\n\t\t\t\t\t\t\ttarget[key].push({});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!target[key][i].type || (scale.type && scale.type !== target[key][i].type)) {\n\t\t\t\t\t\t\t// new/untyped scale or type changed: let's apply the new defaults\n\t\t\t\t\t\t\t// then merge source scale to correctly overwrite the defaults.\n\t\t\t\t\t\t\thelpers.merge(target[key][i], [Chart.scaleService.getScaleDefaults(type), scale]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// scales type are the same\n\t\t\t\t\t\t\thelpers.merge(target[key][i], scale);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thelpers._merger(key, target, source, options);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\thelpers.where = function(collection, filterCallback) {\n\t\tif (helpers.isArray(collection) && Array.prototype.filter) {\n\t\t\treturn collection.filter(filterCallback);\n\t\t}\n\t\tvar filtered = [];\n\n\t\thelpers.each(collection, function(item) {\n\t\t\tif (filterCallback(item)) {\n\t\t\t\tfiltered.push(item);\n\t\t\t}\n\t\t});\n\n\t\treturn filtered;\n\t};\n\thelpers.findIndex = Array.prototype.findIndex ?\n\t\tfunction(array, callback, scope) {\n\t\t\treturn array.findIndex(callback, scope);\n\t\t} :\n\t\tfunction(array, callback, scope) {\n\t\t\tscope = scope === undefined ? array : scope;\n\t\t\tfor (var i = 0, ilen = array.length; i < ilen; ++i) {\n\t\t\t\tif (callback.call(scope, array[i], i, array)) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t};\n\thelpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {\n\t\t// Default to start of the array\n\t\tif (helpers.isNullOrUndef(startIndex)) {\n\t\t\tstartIndex = -1;\n\t\t}\n\t\tfor (var i = startIndex + 1; i < arrayToSearch.length; i++) {\n\t\t\tvar currentItem = arrayToSearch[i];\n\t\t\tif (filterCallback(currentItem)) {\n\t\t\t\treturn currentItem;\n\t\t\t}\n\t\t}\n\t};\n\thelpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {\n\t\t// Default to end of the array\n\t\tif (helpers.isNullOrUndef(startIndex)) {\n\t\t\tstartIndex = arrayToSearch.length;\n\t\t}\n\t\tfor (var i = startIndex - 1; i >= 0; i--) {\n\t\t\tvar currentItem = arrayToSearch[i];\n\t\t\tif (filterCallback(currentItem)) {\n\t\t\t\treturn currentItem;\n\t\t\t}\n\t\t}\n\t};\n\n\t// -- Math methods\n\thelpers.isNumber = function(n) {\n\t\treturn !isNaN(parseFloat(n)) && isFinite(n);\n\t};\n\thelpers.almostEquals = function(x, y, epsilon) {\n\t\treturn Math.abs(x - y) < epsilon;\n\t};\n\thelpers.almostWhole = function(x, epsilon) {\n\t\tvar rounded = Math.round(x);\n\t\treturn (((rounded - epsilon) < x) && ((rounded + epsilon) > x));\n\t};\n\thelpers.max = function(array) {\n\t\treturn array.reduce(function(max, value) {\n\t\t\tif (!isNaN(value)) {\n\t\t\t\treturn Math.max(max, value);\n\t\t\t}\n\t\t\treturn max;\n\t\t}, Number.NEGATIVE_INFINITY);\n\t};\n\thelpers.min = function(array) {\n\t\treturn array.reduce(function(min, value) {\n\t\t\tif (!isNaN(value)) {\n\t\t\t\treturn Math.min(min, value);\n\t\t\t}\n\t\t\treturn min;\n\t\t}, Number.POSITIVE_INFINITY);\n\t};\n\thelpers.sign = Math.sign ?\n\t\tfunction(x) {\n\t\t\treturn Math.sign(x);\n\t\t} :\n\t\tfunction(x) {\n\t\t\tx = +x; // convert to a number\n\t\t\tif (x === 0 || isNaN(x)) {\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\treturn x > 0 ? 1 : -1;\n\t\t};\n\thelpers.log10 = Math.log10 ?\n\t\tfunction(x) {\n\t\t\treturn Math.log10(x);\n\t\t} :\n\t\tfunction(x) {\n\t\t\tvar exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.\n\t\t\t// Check for whole powers of 10,\n\t\t\t// which due to floating point rounding error should be corrected.\n\t\t\tvar powerOf10 = Math.round(exponent);\n\t\t\tvar isPowerOf10 = x === Math.pow(10, powerOf10);\n\n\t\t\treturn isPowerOf10 ? powerOf10 : exponent;\n\t\t};\n\thelpers.toRadians = function(degrees) {\n\t\treturn degrees * (Math.PI / 180);\n\t};\n\thelpers.toDegrees = function(radians) {\n\t\treturn radians * (180 / Math.PI);\n\t};\n\t// Gets the angle from vertical upright to the point about a centre.\n\thelpers.getAngleFromPoint = function(centrePoint, anglePoint) {\n\t\tvar distanceFromXCenter = anglePoint.x - centrePoint.x;\n\t\tvar distanceFromYCenter = anglePoint.y - centrePoint.y;\n\t\tvar radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n\n\t\tvar angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\n\t\tif (angle < (-0.5 * Math.PI)) {\n\t\t\tangle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n\t\t}\n\n\t\treturn {\n\t\t\tangle: angle,\n\t\t\tdistance: radialDistanceFromCenter\n\t\t};\n\t};\n\thelpers.distanceBetweenPoints = function(pt1, pt2) {\n\t\treturn Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n\t};\n\thelpers.aliasPixel = function(pixelWidth) {\n\t\treturn (pixelWidth % 2 === 0) ? 0 : 0.5;\n\t};\n\thelpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {\n\t\t// Props to Rob Spencer at scaled innovation for his post on splining between points\n\t\t// http://scaledinnovation.com/analytics/splines/aboutSplines.html\n\n\t\t// This function must also respect \"skipped\" points\n\n\t\tvar previous = firstPoint.skip ? middlePoint : firstPoint;\n\t\tvar current = middlePoint;\n\t\tvar next = afterPoint.skip ? middlePoint : afterPoint;\n\n\t\tvar d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));\n\t\tvar d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));\n\n\t\tvar s01 = d01 / (d01 + d12);\n\t\tvar s12 = d12 / (d01 + d12);\n\n\t\t// If all points are the same, s01 & s02 will be inf\n\t\ts01 = isNaN(s01) ? 0 : s01;\n\t\ts12 = isNaN(s12) ? 0 : s12;\n\n\t\tvar fa = t * s01; // scaling factor for triangle Ta\n\t\tvar fb = t * s12;\n\n\t\treturn {\n\t\t\tprevious: {\n\t\t\t\tx: current.x - fa * (next.x - previous.x),\n\t\t\t\ty: current.y - fa * (next.y - previous.y)\n\t\t\t},\n\t\t\tnext: {\n\t\t\t\tx: current.x + fb * (next.x - previous.x),\n\t\t\t\ty: current.y + fb * (next.y - previous.y)\n\t\t\t}\n\t\t};\n\t};\n\thelpers.EPSILON = Number.EPSILON || 1e-14;\n\thelpers.splineCurveMonotone = function(points) {\n\t\t// This function calculates Bzier control points in a similar way than |splineCurve|,\n\t\t// but preserves monotonicity of the provided data and ensures no local extremums are added\n\t\t// between the dataset discrete points due to the interpolation.\n\t\t// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n\n\t\tvar pointsWithTangents = (points || []).map(function(point) {\n\t\t\treturn {\n\t\t\t\tmodel: point._model,\n\t\t\t\tdeltaK: 0,\n\t\t\t\tmK: 0\n\t\t\t};\n\t\t});\n\n\t\t// Calculate slopes (deltaK) and initialize tangents (mK)\n\t\tvar pointsLen = pointsWithTangents.length;\n\t\tvar i, pointBefore, pointCurrent, pointAfter;\n\t\tfor (i = 0; i < pointsLen; ++i) {\n\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\tif (pointCurrent.model.skip) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n\t\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\t\t\tif (pointAfter && !pointAfter.model.skip) {\n\t\t\t\tvar slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);\n\n\t\t\t\t// In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n\t\t\t\tpointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;\n\t\t\t}\n\n\t\t\tif (!pointBefore || pointBefore.model.skip) {\n\t\t\t\tpointCurrent.mK = pointCurrent.deltaK;\n\t\t\t} else if (!pointAfter || pointAfter.model.skip) {\n\t\t\t\tpointCurrent.mK = pointBefore.deltaK;\n\t\t\t} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {\n\t\t\t\tpointCurrent.mK = 0;\n\t\t\t} else {\n\t\t\t\tpointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;\n\t\t\t}\n\t\t}\n\n\t\t// Adjust tangents to ensure monotonic properties\n\t\tvar alphaK, betaK, tauK, squaredMagnitude;\n\t\tfor (i = 0; i < pointsLen - 1; ++i) {\n\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\tpointAfter = pointsWithTangents[i + 1];\n\t\t\tif (pointCurrent.model.skip || pointAfter.model.skip) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {\n\t\t\t\tpointCurrent.mK = pointAfter.mK = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\talphaK = pointCurrent.mK / pointCurrent.deltaK;\n\t\t\tbetaK = pointAfter.mK / pointCurrent.deltaK;\n\t\t\tsquaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n\t\t\tif (squaredMagnitude <= 9) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttauK = 3 / Math.sqrt(squaredMagnitude);\n\t\t\tpointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;\n\t\t\tpointAfter.mK = betaK * tauK * pointCurrent.deltaK;\n\t\t}\n\n\t\t// Compute control points\n\t\tvar deltaX;\n\t\tfor (i = 0; i < pointsLen; ++i) {\n\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\tif (pointCurrent.model.skip) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n\t\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\t\t\tif (pointBefore && !pointBefore.model.skip) {\n\t\t\t\tdeltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;\n\t\t\t\tpointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;\n\t\t\t\tpointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;\n\t\t\t}\n\t\t\tif (pointAfter && !pointAfter.model.skip) {\n\t\t\t\tdeltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;\n\t\t\t\tpointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;\n\t\t\t\tpointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;\n\t\t\t}\n\t\t}\n\t};\n\thelpers.nextItem = function(collection, index, loop) {\n\t\tif (loop) {\n\t\t\treturn index >= collection.length - 1 ? collection[0] : collection[index + 1];\n\t\t}\n\t\treturn index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];\n\t};\n\thelpers.previousItem = function(collection, index, loop) {\n\t\tif (loop) {\n\t\t\treturn index <= 0 ? collection[collection.length - 1] : collection[index - 1];\n\t\t}\n\t\treturn index <= 0 ? collection[0] : collection[index - 1];\n\t};\n\t// Implementation of the nice number algorithm used in determining where axis labels will go\n\thelpers.niceNum = function(range, round) {\n\t\tvar exponent = Math.floor(helpers.log10(range));\n\t\tvar fraction = range / Math.pow(10, exponent);\n\t\tvar niceFraction;\n\n\t\tif (round) {\n\t\t\tif (fraction < 1.5) {\n\t\t\t\tniceFraction = 1;\n\t\t\t} else if (fraction < 3) {\n\t\t\t\tniceFraction = 2;\n\t\t\t} else if (fraction < 7) {\n\t\t\t\tniceFraction = 5;\n\t\t\t} else {\n\t\t\t\tniceFraction = 10;\n\t\t\t}\n\t\t} else if (fraction <= 1.0) {\n\t\t\tniceFraction = 1;\n\t\t} else if (fraction <= 2) {\n\t\t\tniceFraction = 2;\n\t\t} else if (fraction <= 5) {\n\t\t\tniceFraction = 5;\n\t\t} else {\n\t\t\tniceFraction = 10;\n\t\t}\n\n\t\treturn niceFraction * Math.pow(10, exponent);\n\t};\n\t// Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\n\thelpers.requestAnimFrame = (function() {\n\t\tif (typeof window === 'undefined') {\n\t\t\treturn function(callback) {\n\t\t\t\tcallback();\n\t\t\t};\n\t\t}\n\t\treturn window.requestAnimationFrame ||\n\t\t\twindow.webkitRequestAnimationFrame ||\n\t\t\twindow.mozRequestAnimationFrame ||\n\t\t\twindow.oRequestAnimationFrame ||\n\t\t\twindow.msRequestAnimationFrame ||\n\t\t\tfunction(callback) {\n\t\t\t\treturn window.setTimeout(callback, 1000 / 60);\n\t\t\t};\n\t}());\n\t// -- DOM methods\n\thelpers.getRelativePosition = function(evt, chart) {\n\t\tvar mouseX, mouseY;\n\t\tvar e = evt.originalEvent || evt;\n\t\tvar canvas = evt.currentTarget || evt.srcElement;\n\t\tvar boundingRect = canvas.getBoundingClientRect();\n\n\t\tvar touches = e.touches;\n\t\tif (touches && touches.length > 0) {\n\t\t\tmouseX = touches[0].clientX;\n\t\t\tmouseY = touches[0].clientY;\n\n\t\t} else {\n\t\t\tmouseX = e.clientX;\n\t\t\tmouseY = e.clientY;\n\t\t}\n\n\t\t// Scale mouse coordinates into canvas coordinates\n\t\t// by following the pattern laid out by 'jerryj' in the comments of\n\t\t// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/\n\t\tvar paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));\n\t\tvar paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));\n\t\tvar paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));\n\t\tvar paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));\n\t\tvar width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;\n\t\tvar height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;\n\n\t\t// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However\n\t\t// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here\n\t\tmouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);\n\t\tmouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);\n\n\t\treturn {\n\t\t\tx: mouseX,\n\t\t\ty: mouseY\n\t\t};\n\n\t};\n\n\t// Private helper function to convert max-width/max-height values that may be percentages into a number\n\tfunction parseMaxStyle(styleValue, node, parentProperty) {\n\t\tvar valueInPixels;\n\t\tif (typeof styleValue === 'string') {\n\t\t\tvalueInPixels = parseInt(styleValue, 10);\n\n\t\t\tif (styleValue.indexOf('%') !== -1) {\n\t\t\t\t// percentage * size in dimension\n\t\t\t\tvalueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n\t\t\t}\n\t\t} else {\n\t\t\tvalueInPixels = styleValue;\n\t\t}\n\n\t\treturn valueInPixels;\n\t}\n\n\t/**\n\t * Returns if the given value contains an effective constraint.\n\t * @private\n\t */\n\tfunction isConstrainedValue(value) {\n\t\treturn value !== undefined && value !== null && value !== 'none';\n\t}\n\n\t// Private helper to get a constraint dimension\n\t// @param domNode : the node to check the constraint on\n\t// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)\n\t// @param percentageProperty : property of parent to use when calculating width as a percentage\n\t// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser\n\tfunction getConstraintDimension(domNode, maxStyle, percentageProperty) {\n\t\tvar view = document.defaultView;\n\t\tvar parentNode = domNode.parentNode;\n\t\tvar constrainedNode = view.getComputedStyle(domNode)[maxStyle];\n\t\tvar constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];\n\t\tvar hasCNode = isConstrainedValue(constrainedNode);\n\t\tvar hasCContainer = isConstrainedValue(constrainedContainer);\n\t\tvar infinity = Number.POSITIVE_INFINITY;\n\n\t\tif (hasCNode || hasCContainer) {\n\t\t\treturn Math.min(\n\t\t\t\thasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,\n\t\t\t\thasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);\n\t\t}\n\n\t\treturn 'none';\n\t}\n\t// returns Number or undefined if no constraint\n\thelpers.getConstraintWidth = function(domNode) {\n\t\treturn getConstraintDimension(domNode, 'max-width', 'clientWidth');\n\t};\n\t// returns Number or undefined if no constraint\n\thelpers.getConstraintHeight = function(domNode) {\n\t\treturn getConstraintDimension(domNode, 'max-height', 'clientHeight');\n\t};\n\thelpers.getMaximumWidth = function(domNode) {\n\t\tvar container = domNode.parentNode;\n\t\tif (!container) {\n\t\t\treturn domNode.clientWidth;\n\t\t}\n\n\t\tvar paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);\n\t\tvar paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);\n\t\tvar w = container.clientWidth - paddingLeft - paddingRight;\n\t\tvar cw = helpers.getConstraintWidth(domNode);\n\t\treturn isNaN(cw) ? w : Math.min(w, cw);\n\t};\n\thelpers.getMaximumHeight = function(domNode) {\n\t\tvar container = domNode.parentNode;\n\t\tif (!container) {\n\t\t\treturn domNode.clientHeight;\n\t\t}\n\n\t\tvar paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);\n\t\tvar paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);\n\t\tvar h = container.clientHeight - paddingTop - paddingBottom;\n\t\tvar ch = helpers.getConstraintHeight(domNode);\n\t\treturn isNaN(ch) ? h : Math.min(h, ch);\n\t};\n\thelpers.getStyle = function(el, property) {\n\t\treturn el.currentStyle ?\n\t\t\tel.currentStyle[property] :\n\t\t\tdocument.defaultView.getComputedStyle(el, null).getPropertyValue(property);\n\t};\n\thelpers.retinaScale = function(chart, forceRatio) {\n\t\tvar pixelRatio = chart.currentDevicePixelRatio = forceRatio || window.devicePixelRatio || 1;\n\t\tif (pixelRatio === 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar canvas = chart.canvas;\n\t\tvar height = chart.height;\n\t\tvar width = chart.width;\n\n\t\tcanvas.height = height * pixelRatio;\n\t\tcanvas.width = width * pixelRatio;\n\t\tchart.ctx.scale(pixelRatio, pixelRatio);\n\n\t\t// If no style has been set on the canvas, the render size is used as display size,\n\t\t// making the chart visually bigger, so let's enforce it to the \"correct\" values.\n\t\t// See https://github.com/chartjs/Chart.js/issues/3575\n\t\tif (!canvas.style.height && !canvas.style.width) {\n\t\t\tcanvas.style.height = height + 'px';\n\t\t\tcanvas.style.width = width + 'px';\n\t\t}\n\t};\n\t// -- Canvas methods\n\thelpers.fontString = function(pixelSize, fontStyle, fontFamily) {\n\t\treturn fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n\t};\n\thelpers.longestText = function(ctx, font, arrayOfThings, cache) {\n\t\tcache = cache || {};\n\t\tvar data = cache.data = cache.data || {};\n\t\tvar gc = cache.garbageCollect = cache.garbageCollect || [];\n\n\t\tif (cache.font !== font) {\n\t\t\tdata = cache.data = {};\n\t\t\tgc = cache.garbageCollect = [];\n\t\t\tcache.font = font;\n\t\t}\n\n\t\tctx.font = font;\n\t\tvar longest = 0;\n\t\thelpers.each(arrayOfThings, function(thing) {\n\t\t\t// Undefined strings and arrays should not be measured\n\t\t\tif (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {\n\t\t\t\tlongest = helpers.measureText(ctx, data, gc, longest, thing);\n\t\t\t} else if (helpers.isArray(thing)) {\n\t\t\t\t// if it is an array lets measure each element\n\t\t\t\t// to do maybe simplify this function a bit so we can do this more recursively?\n\t\t\t\thelpers.each(thing, function(nestedThing) {\n\t\t\t\t\t// Undefined strings and arrays should not be measured\n\t\t\t\t\tif (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {\n\t\t\t\t\t\tlongest = helpers.measureText(ctx, data, gc, longest, nestedThing);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tvar gcLen = gc.length / 2;\n\t\tif (gcLen > arrayOfThings.length) {\n\t\t\tfor (var i = 0; i < gcLen; i++) {\n\t\t\t\tdelete data[gc[i]];\n\t\t\t}\n\t\t\tgc.splice(0, gcLen);\n\t\t}\n\t\treturn longest;\n\t};\n\thelpers.measureText = function(ctx, data, gc, longest, string) {\n\t\tvar textWidth = data[string];\n\t\tif (!textWidth) {\n\t\t\ttextWidth = data[string] = ctx.measureText(string).width;\n\t\t\tgc.push(string);\n\t\t}\n\t\tif (textWidth > longest) {\n\t\t\tlongest = textWidth;\n\t\t}\n\t\treturn longest;\n\t};\n\thelpers.numberOfLabelLines = function(arrayOfThings) {\n\t\tvar numberOfLines = 1;\n\t\thelpers.each(arrayOfThings, function(thing) {\n\t\t\tif (helpers.isArray(thing)) {\n\t\t\t\tif (thing.length > numberOfLines) {\n\t\t\t\t\tnumberOfLines = thing.length;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn numberOfLines;\n\t};\n\n\thelpers.color = !color ?\n\t\tfunction(value) {\n\t\t\tconsole.error('Color.js not found!');\n\t\t\treturn value;\n\t\t} :\n\t\tfunction(value) {\n\t\t\t/* global CanvasGradient */\n\t\t\tif (value instanceof CanvasGradient) {\n\t\t\t\tvalue = defaults.global.defaultColor;\n\t\t\t}\n\n\t\t\treturn color(value);\n\t\t};\n\n\thelpers.getHoverColor = function(colorValue) {\n\t\t/* global CanvasPattern */\n\t\treturn (colorValue instanceof CanvasPattern) ?\n\t\t\tcolorValue :\n\t\t\thelpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();\n\t};\n};\n\n},{\"../helpers/index\":53,\"./core.defaults\":33,\"chartjs-color\":10}],36:[function(require,module,exports){\n'use strict';\n\nvar helpers = require('../helpers/index');\n\n/**\n * Helper function to get relative position for an event\n * @param {Event|IEvent} event - The event to get the position for\n * @param {Chart} chart - The chart\n * @returns {Point} the event position\n */\nfunction getRelativePosition(e, chart) {\n\tif (e.native) {\n\t\treturn {\n\t\t\tx: e.x,\n\t\t\ty: e.y\n\t\t};\n\t}\n\n\treturn helpers.getRelativePosition(e, chart);\n}\n\n/**\n * Helper function to traverse all of the visible elements in the chart\n * @param chart {chart} the chart\n * @param handler {Function} the callback to execute for each visible item\n */\nfunction parseVisibleItems(chart, handler) {\n\tvar datasets = chart.data.datasets;\n\tvar meta, i, j, ilen, jlen;\n\n\tfor (i = 0, ilen = datasets.length; i < ilen; ++i) {\n\t\tif (!chart.isDatasetVisible(i)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tmeta = chart.getDatasetMeta(i);\n\t\tfor (j = 0, jlen = meta.data.length; j < jlen; ++j) {\n\t\t\tvar element = meta.data[j];\n\t\t\tif (!element._view.skip) {\n\t\t\t\thandler(element);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Helper function to get the items that intersect the event position\n * @param items {ChartElement[]} elements to filter\n * @param position {Point} the point to be nearest to\n * @return {ChartElement[]} the nearest items\n */\nfunction getIntersectItems(chart, position) {\n\tvar elements = [];\n\n\tparseVisibleItems(chart, function(element) {\n\t\tif (element.inRange(position.x, position.y)) {\n\t\t\telements.push(element);\n\t\t}\n\t});\n\n\treturn elements;\n}\n\n/**\n * Helper function to get the items nearest to the event position considering all visible items in teh chart\n * @param chart {Chart} the chart to look at elements from\n * @param position {Point} the point to be nearest to\n * @param intersect {Boolean} if true, only consider items that intersect the position\n * @param distanceMetric {Function} function to provide the distance between points\n * @return {ChartElement[]} the nearest items\n */\nfunction getNearestItems(chart, position, intersect, distanceMetric) {\n\tvar minDistance = Number.POSITIVE_INFINITY;\n\tvar nearestItems = [];\n\n\tparseVisibleItems(chart, function(element) {\n\t\tif (intersect && !element.inRange(position.x, position.y)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar center = element.getCenterPoint();\n\t\tvar distance = distanceMetric(position, center);\n\n\t\tif (distance < minDistance) {\n\t\t\tnearestItems = [element];\n\t\t\tminDistance = distance;\n\t\t} else if (distance === minDistance) {\n\t\t\t// Can have multiple items at the same distance in which case we sort by size\n\t\t\tnearestItems.push(element);\n\t\t}\n\t});\n\n\treturn nearestItems;\n}\n\n/**\n * Get a distance metric function for two points based on the\n * axis mode setting\n * @param {String} axis the axis mode. x|y|xy\n */\nfunction getDistanceMetricForAxis(axis) {\n\tvar useX = axis.indexOf('x') !== -1;\n\tvar useY = axis.indexOf('y') !== -1;\n\n\treturn function(pt1, pt2) {\n\t\tvar deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n\t\tvar deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n\t\treturn Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n\t};\n}\n\nfunction indexMode(chart, e, options) {\n\tvar position = getRelativePosition(e, chart);\n\t// Default axis for index mode is 'x' to match old behaviour\n\toptions.axis = options.axis || 'x';\n\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\n\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n\tvar elements = [];\n\n\tif (!items.length) {\n\t\treturn [];\n\t}\n\n\tchart.data.datasets.forEach(function(dataset, datasetIndex) {\n\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\tvar element = meta.data[items[0]._index];\n\n\t\t\t// don't count items that are skipped (null data)\n\t\t\tif (element && !element._view.skip) {\n\t\t\t\telements.push(element);\n\t\t\t}\n\t\t}\n\t});\n\n\treturn elements;\n}\n\n/**\n * @interface IInteractionOptions\n */\n/**\n * If true, only consider items that intersect the point\n * @name IInterfaceOptions#boolean\n * @type Boolean\n */\n\n/**\n * Contains interaction related functions\n * @namespace Chart.Interaction\n */\nmodule.exports = {\n\t// Helper function for different modes\n\tmodes: {\n\t\tsingle: function(chart, e) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\tvar elements = [];\n\n\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\telements.push(element);\n\t\t\t\t\treturn elements;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn elements.slice(0, 1);\n\t\t},\n\n\t\t/**\n\t\t * @function Chart.Interaction.modes.label\n\t\t * @deprecated since version 2.4.0\n\t\t * @todo remove at version 3\n\t\t * @private\n\t\t */\n\t\tlabel: indexMode,\n\n\t\t/**\n\t\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n\t\t * @function Chart.Interaction.modes.index\n\t\t * @since v2.4.0\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use during interaction\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tindex: indexMode,\n\n\t\t/**\n\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\n\t\t * @function Chart.Interaction.modes.dataset\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use during interaction\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tdataset: function(chart, e, options) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\toptions.axis = options.axis || 'xy';\n\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\n\t\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n\n\t\t\tif (items.length > 0) {\n\t\t\t\titems = chart.getDatasetMeta(items[0]._datasetIndex).data;\n\t\t\t}\n\n\t\t\treturn items;\n\t\t},\n\n\t\t/**\n\t\t * @function Chart.Interaction.modes.x-axis\n\t\t * @deprecated since version 2.4.0. Use index mode and intersect == true\n\t\t * @todo remove at version 3\n\t\t * @private\n\t\t */\n\t\t'x-axis': function(chart, e) {\n\t\t\treturn indexMode(chart, e, {intersect: false});\n\t\t},\n\n\t\t/**\n\t\t * Point mode returns all elements that hit test based on the event position\n\t\t * of the event\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tpoint: function(chart, e) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\treturn getIntersectItems(chart, position);\n\t\t},\n\n\t\t/**\n\t\t * nearest mode returns the element closest to the point\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tnearest: function(chart, e, options) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\toptions.axis = options.axis || 'xy';\n\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\n\t\t\tvar nearestItems = getNearestItems(chart, position, options.intersect, distanceMetric);\n\n\t\t\t// We have multiple items at the same distance from the event. Now sort by smallest\n\t\t\tif (nearestItems.length > 1) {\n\t\t\t\tnearestItems.sort(function(a, b) {\n\t\t\t\t\tvar sizeA = a.getArea();\n\t\t\t\t\tvar sizeB = b.getArea();\n\t\t\t\t\tvar ret = sizeA - sizeB;\n\n\t\t\t\t\tif (ret === 0) {\n\t\t\t\t\t\t// if equal sort by dataset index\n\t\t\t\t\t\tret = a._datasetIndex - b._datasetIndex;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn ret;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Return only 1 item\n\t\t\treturn nearestItems.slice(0, 1);\n\t\t},\n\n\t\t/**\n\t\t * x mode returns the elements that hit-test at the current x coordinate\n\t\t * @function Chart.Interaction.modes.x\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tx: function(chart, e, options) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\tvar items = [];\n\t\t\tvar intersectsItem = false;\n\n\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\tif (element.inXRange(position.x)) {\n\t\t\t\t\titems.push(element);\n\t\t\t\t}\n\n\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\tintersectsItem = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// If we want to trigger on an intersect and we don't have any items\n\t\t\t// that intersect the position, return nothing\n\t\t\tif (options.intersect && !intersectsItem) {\n\t\t\t\titems = [];\n\t\t\t}\n\t\t\treturn items;\n\t\t},\n\n\t\t/**\n\t\t * y mode returns the elements that hit-test at the current y coordinate\n\t\t * @function Chart.Interaction.modes.y\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\ty: function(chart, e, options) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\tvar items = [];\n\t\t\tvar intersectsItem = false;\n\n\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\tif (element.inYRange(position.y)) {\n\t\t\t\t\titems.push(element);\n\t\t\t\t}\n\n\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\tintersectsItem = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// If we want to trigger on an intersect and we don't have any items\n\t\t\t// that intersect the position, return nothing\n\t\t\tif (options.intersect && !intersectsItem) {\n\t\t\t\titems = [];\n\t\t\t}\n\t\t\treturn items;\n\t\t}\n\t}\n};\n\n},{\"../helpers/index\":53}],37:[function(require,module,exports){\n'use strict';\n\nvar defaults = require('./core.defaults');\n\ndefaults._set('global', {\n\tresponsive: true,\n\tresponsiveAnimationDuration: 0,\n\tmaintainAspectRatio: true,\n\tevents: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],\n\thover: {\n\t\tonHover: null,\n\t\tmode: 'nearest',\n\t\tintersect: true,\n\t\tanimationDuration: 400\n\t},\n\tonClick: null,\n\tdefaultColor: 'rgba(0,0,0,0.1)',\n\tdefaultFontColor: '#666',\n\tdefaultFontFamily: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n\tdefaultFontSize: 12,\n\tdefaultFontStyle: 'normal',\n\tshowLines: true,\n\n\t// Element defaults defined in element extensions\n\telements: {},\n\n\t// Layout options such as padding\n\tlayout: {\n\t\tpadding: {\n\t\t\ttop: 0,\n\t\t\tright: 0,\n\t\t\tbottom: 0,\n\t\t\tleft: 0\n\t\t}\n\t}\n});\n\nmodule.exports = function() {\n\n\t// Occupy the global variable of Chart, and create a simple base class\n\tvar Chart = function(item, config) {\n\t\tthis.construct(item, config);\n\t\treturn this;\n\t};\n\n\tChart.Chart = Chart;\n\n\treturn Chart;\n};\n\n},{\"./core.defaults\":33}],38:[function(require,module,exports){\n'use strict';\n\nvar helpers = require('../helpers/index');\n\nfunction filterByPosition(array, position) {\n\treturn helpers.where(array, function(v) {\n\t\treturn v.position === position;\n\t});\n}\n\nfunction sortByWeight(array, reverse) {\n\tarray.forEach(function(v, i) {\n\t\tv._tmpIndex_ = i;\n\t\treturn v;\n\t});\n\tarray.sort(function(a, b) {\n\t\tvar v0 = reverse ? b : a;\n\t\tvar v1 = reverse ? a : b;\n\t\treturn v0.weight === v1.weight ?\n\t\t\tv0._tmpIndex_ - v1._tmpIndex_ :\n\t\t\tv0.weight - v1.weight;\n\t});\n\tarray.forEach(function(v) {\n\t\tdelete v._tmpIndex_;\n\t});\n}\n\n/**\n * @interface ILayoutItem\n * @prop {String} position - The position of the item in the chart layout. Possible values are\n * 'left', 'top', 'right', 'bottom', and 'chartArea'\n * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area\n * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down\n * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\n * @prop {Function} update - Takes two parameters: width and height. Returns size of item\n * @prop {Function} getPadding -  Returns an object with padding on the edges\n * @prop {Number} width - Width of item. Must be valid after update()\n * @prop {Number} height - Height of item. Must be valid after update()\n * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update\n * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update\n * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update\n * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\n */\n\n// The layout service is very self explanatory.  It's responsible for the layout within a chart.\n// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n// It is this service's responsibility of carrying out that layout.\nmodule.exports = {\n\tdefaults: {},\n\n\t/**\n\t * Register a box to a chart.\n\t * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\n\t * @param {Chart} chart - the chart to use\n\t * @param {ILayoutItem} item - the item to add to be layed out\n\t */\n\taddBox: function(chart, item) {\n\t\tif (!chart.boxes) {\n\t\t\tchart.boxes = [];\n\t\t}\n\n\t\t// initialize item with default values\n\t\titem.fullWidth = item.fullWidth || false;\n\t\titem.position = item.position || 'top';\n\t\titem.weight = item.weight || 0;\n\n\t\tchart.boxes.push(item);\n\t},\n\n\t/**\n\t * Remove a layoutItem from a chart\n\t * @param {Chart} chart - the chart to remove the box from\n\t * @param {Object} layoutItem - the item to remove from the layout\n\t */\n\tremoveBox: function(chart, layoutItem) {\n\t\tvar index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n\t\tif (index !== -1) {\n\t\t\tchart.boxes.splice(index, 1);\n\t\t}\n\t},\n\n\t/**\n\t * Sets (or updates) options on the given `item`.\n\t * @param {Chart} chart - the chart in which the item lives (or will be added to)\n\t * @param {Object} item - the item to configure with the given options\n\t * @param {Object} options - the new item options.\n\t */\n\tconfigure: function(chart, item, options) {\n\t\tvar props = ['fullWidth', 'position', 'weight'];\n\t\tvar ilen = props.length;\n\t\tvar i = 0;\n\t\tvar prop;\n\n\t\tfor (; i < ilen; ++i) {\n\t\t\tprop = props[i];\n\t\t\tif (options.hasOwnProperty(prop)) {\n\t\t\t\titem[prop] = options[prop];\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Fits boxes of the given chart into the given size by having each box measure itself\n\t * then running a fitting algorithm\n\t * @param {Chart} chart - the chart\n\t * @param {Number} width - the width to fit into\n\t * @param {Number} height - the height to fit into\n\t */\n\tupdate: function(chart, width, height) {\n\t\tif (!chart) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar layoutOptions = chart.options.layout || {};\n\t\tvar padding = helpers.options.toPadding(layoutOptions.padding);\n\t\tvar leftPadding = padding.left;\n\t\tvar rightPadding = padding.right;\n\t\tvar topPadding = padding.top;\n\t\tvar bottomPadding = padding.bottom;\n\n\t\tvar leftBoxes = filterByPosition(chart.boxes, 'left');\n\t\tvar rightBoxes = filterByPosition(chart.boxes, 'right');\n\t\tvar topBoxes = filterByPosition(chart.boxes, 'top');\n\t\tvar bottomBoxes = filterByPosition(chart.boxes, 'bottom');\n\t\tvar chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');\n\n\t\t// Sort boxes by weight. A higher weight is further away from the chart area\n\t\tsortByWeight(leftBoxes, true);\n\t\tsortByWeight(rightBoxes, false);\n\t\tsortByWeight(topBoxes, true);\n\t\tsortByWeight(bottomBoxes, false);\n\n\t\t// Essentially we now have any number of boxes on each of the 4 sides.\n\t\t// Our canvas looks like the following.\n\t\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n\t\t// B1 is the bottom axis\n\t\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n\t\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n\t\t// an error will be thrown.\n\t\t//\n\t\t// |----------------------------------------------------|\n\t\t// |                  T1 (Full Width)                   |\n\t\t// |----------------------------------------------------|\n\t\t// |    |    |                 T2                  |    |\n\t\t// |    |----|-------------------------------------|----|\n\t\t// |    |    | C1 |                           | C2 |    |\n\t\t// |    |    |----|                           |----|    |\n\t\t// |    |    |                                     |    |\n\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\n\t\t// |    |    |                                     |    |\n\t\t// |    |    |----|                           |----|    |\n\t\t// |    |    | C3 |                           | C4 |    |\n\t\t// |    |----|-------------------------------------|----|\n\t\t// |    |    |                 B1                  |    |\n\t\t// |----------------------------------------------------|\n\t\t// |                  B2 (Full Width)                   |\n\t\t// |----------------------------------------------------|\n\t\t//\n\t\t// What we do to find the best sizing, we do the following\n\t\t// 1. Determine the minimum size of the chart area.\n\t\t// 2. Split the remaining width equally between each vertical axis\n\t\t// 3. Split the remaining height equally between each horizontal axis\n\t\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size\n\t\t// 5. Adjust the sizes of each axis based on it's minimum reported size.\n\t\t// 6. Refit each axis\n\t\t// 7. Position each axis in the final location\n\t\t// 8. Tell the chart the final location of the chart area\n\t\t// 9. Tell any axes that overlay the chart area the positions of the chart area\n\n\t\t// Step 1\n\t\tvar chartWidth = width - leftPadding - rightPadding;\n\t\tvar chartHeight = height - topPadding - bottomPadding;\n\t\tvar chartAreaWidth = chartWidth / 2; // min 50%\n\t\tvar chartAreaHeight = chartHeight / 2; // min 50%\n\n\t\t// Step 2\n\t\tvar verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);\n\n\t\t// Step 3\n\t\tvar horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);\n\n\t\t// Step 4\n\t\tvar maxChartAreaWidth = chartWidth;\n\t\tvar maxChartAreaHeight = chartHeight;\n\t\tvar minBoxSizes = [];\n\n\t\tfunction getMinimumBoxSize(box) {\n\t\t\tvar minSize;\n\t\t\tvar isHorizontal = box.isHorizontal();\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tminSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\n\t\t\t\tmaxChartAreaHeight -= minSize.height;\n\t\t\t} else {\n\t\t\t\tminSize = box.update(verticalBoxWidth, maxChartAreaHeight);\n\t\t\t\tmaxChartAreaWidth -= minSize.width;\n\t\t\t}\n\n\t\t\tminBoxSizes.push({\n\t\t\t\thorizontal: isHorizontal,\n\t\t\t\tminSize: minSize,\n\t\t\t\tbox: box,\n\t\t\t});\n\t\t}\n\n\t\thelpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);\n\n\t\t// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\n\t\tvar maxHorizontalLeftPadding = 0;\n\t\tvar maxHorizontalRightPadding = 0;\n\t\tvar maxVerticalTopPadding = 0;\n\t\tvar maxVerticalBottomPadding = 0;\n\n\t\thelpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {\n\t\t\tif (horizontalBox.getPadding) {\n\t\t\t\tvar boxPadding = horizontalBox.getPadding();\n\t\t\t\tmaxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\n\t\t\t\tmaxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\n\t\t\t}\n\t\t});\n\n\t\thelpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {\n\t\t\tif (verticalBox.getPadding) {\n\t\t\t\tvar boxPadding = verticalBox.getPadding();\n\t\t\t\tmaxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\n\t\t\t\tmaxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\n\t\t\t}\n\t\t});\n\n\t\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\n\t\t// be if the axes are drawn at their minimum sizes.\n\t\t// Steps 5 & 6\n\t\tvar totalLeftBoxesWidth = leftPadding;\n\t\tvar totalRightBoxesWidth = rightPadding;\n\t\tvar totalTopBoxesHeight = topPadding;\n\t\tvar totalBottomBoxesHeight = bottomPadding;\n\n\t\t// Function to fit a box\n\t\tfunction fitBox(box) {\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {\n\t\t\t\treturn minBox.box === box;\n\t\t\t});\n\n\t\t\tif (minBoxSize) {\n\t\t\t\tif (box.isHorizontal()) {\n\t\t\t\t\tvar scaleMargin = {\n\t\t\t\t\t\tleft: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\n\t\t\t\t\t\tright: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\tbottom: 0\n\t\t\t\t\t};\n\n\t\t\t\t\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\n\t\t\t\t\t// on the margin. Sometimes they need to increase in size slightly\n\t\t\t\t\tbox.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\n\t\t\t\t} else {\n\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Update, and calculate the left and right margins for the horizontal boxes\n\t\thelpers.each(leftBoxes.concat(rightBoxes), fitBox);\n\n\t\thelpers.each(leftBoxes, function(box) {\n\t\t\ttotalLeftBoxesWidth += box.width;\n\t\t});\n\n\t\thelpers.each(rightBoxes, function(box) {\n\t\t\ttotalRightBoxesWidth += box.width;\n\t\t});\n\n\t\t// Set the Left and Right margins for the horizontal boxes\n\t\thelpers.each(topBoxes.concat(bottomBoxes), fitBox);\n\n\t\t// Figure out how much margin is on the top and bottom of the vertical boxes\n\t\thelpers.each(topBoxes, function(box) {\n\t\t\ttotalTopBoxesHeight += box.height;\n\t\t});\n\n\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\ttotalBottomBoxesHeight += box.height;\n\t\t});\n\n\t\tfunction finalFitVerticalBox(box) {\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {\n\t\t\t\treturn minSize.box === box;\n\t\t\t});\n\n\t\t\tvar scaleMargin = {\n\t\t\t\tleft: 0,\n\t\t\t\tright: 0,\n\t\t\t\ttop: totalTopBoxesHeight,\n\t\t\t\tbottom: totalBottomBoxesHeight\n\t\t\t};\n\n\t\t\tif (minBoxSize) {\n\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\n\t\t\t}\n\t\t}\n\n\t\t// Let the left layout know the final margin\n\t\thelpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);\n\n\t\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\n\t\ttotalLeftBoxesWidth = leftPadding;\n\t\ttotalRightBoxesWidth = rightPadding;\n\t\ttotalTopBoxesHeight = topPadding;\n\t\ttotalBottomBoxesHeight = bottomPadding;\n\n\t\thelpers.each(leftBoxes, function(box) {\n\t\t\ttotalLeftBoxesWidth += box.width;\n\t\t});\n\n\t\thelpers.each(rightBoxes, function(box) {\n\t\t\ttotalRightBoxesWidth += box.width;\n\t\t});\n\n\t\thelpers.each(topBoxes, function(box) {\n\t\t\ttotalTopBoxesHeight += box.height;\n\t\t});\n\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\ttotalBottomBoxesHeight += box.height;\n\t\t});\n\n\t\t// We may be adding some padding to account for rotated x axis labels\n\t\tvar leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\n\t\ttotalLeftBoxesWidth += leftPaddingAddition;\n\t\ttotalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\n\n\t\tvar topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\n\t\ttotalTopBoxesHeight += topPaddingAddition;\n\t\ttotalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);\n\n\t\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation\n\t\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\n\t\t// without calling `fit` again\n\t\tvar newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\n\t\tvar newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\n\n\t\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\n\t\t\thelpers.each(leftBoxes, function(box) {\n\t\t\t\tbox.height = newMaxChartAreaHeight;\n\t\t\t});\n\n\t\t\thelpers.each(rightBoxes, function(box) {\n\t\t\t\tbox.height = newMaxChartAreaHeight;\n\t\t\t});\n\n\t\t\thelpers.each(topBoxes, function(box) {\n\t\t\t\tif (!box.fullWidth) {\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\t\tif (!box.fullWidth) {\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tmaxChartAreaHeight = newMaxChartAreaHeight;\n\t\t\tmaxChartAreaWidth = newMaxChartAreaWidth;\n\t\t}\n\n\t\t// Step 7 - Position the boxes\n\t\tvar left = leftPadding + leftPaddingAddition;\n\t\tvar top = topPadding + topPaddingAddition;\n\n\t\tfunction placeBox(box) {\n\t\t\tif (box.isHorizontal()) {\n\t\t\t\tbox.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;\n\t\t\t\tbox.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\n\t\t\t\tbox.top = top;\n\t\t\t\tbox.bottom = top + box.height;\n\n\t\t\t\t// Move to next point\n\t\t\t\ttop = box.bottom;\n\n\t\t\t} else {\n\n\t\t\t\tbox.left = left;\n\t\t\t\tbox.right = left + box.width;\n\t\t\t\tbox.top = totalTopBoxesHeight;\n\t\t\t\tbox.bottom = totalTopBoxesHeight + maxChartAreaHeight;\n\n\t\t\t\t// Move to next point\n\t\t\t\tleft = box.right;\n\t\t\t}\n\t\t}\n\n\t\thelpers.each(leftBoxes.concat(topBoxes), placeBox);\n\n\t\t// Account for chart width and height\n\t\tleft += maxChartAreaWidth;\n\t\ttop += maxChartAreaHeight;\n\n\t\thelpers.each(rightBoxes, placeBox);\n\t\thelpers.each(bottomBoxes, placeBox);\n\n\t\t// Step 8\n\t\tchart.chartArea = {\n\t\t\tleft: totalLeftBoxesWidth,\n\t\t\ttop: totalTopBoxesHeight,\n\t\t\tright: totalLeftBoxesWidth + maxChartAreaWidth,\n\t\t\tbottom: totalTopBoxesHeight + maxChartAreaHeight\n\t\t};\n\n\t\t// Step 9\n\t\thelpers.each(chartAreaBoxes, function(box) {\n\t\t\tbox.left = chart.chartArea.left;\n\t\t\tbox.top = chart.chartArea.top;\n\t\t\tbox.right = chart.chartArea.right;\n\t\t\tbox.bottom = chart.chartArea.bottom;\n\n\t\t\tbox.update(maxChartAreaWidth, maxChartAreaHeight);\n\t\t});\n\t}\n};\n\n},{\"../helpers/index\":53}],39:[function(require,module,exports){\n'use strict';\n\nvar defaults = require('./core.defaults');\nvar helpers = require('../helpers/index');\n\ndefaults._set('global', {\n\tplugins: {}\n});\n\n/**\n * The plugin service singleton\n * @namespace Chart.plugins\n * @since 2.1.0\n */\nmodule.exports = {\n\t/**\n\t * Globally registered plugins.\n\t * @private\n\t */\n\t_plugins: [],\n\n\t/**\n\t * This identifier is used to invalidate the descriptors cache attached to each chart\n\t * when a global plugin is registered or unregistered. In this case, the cache ID is\n\t * incremented and descriptors are regenerated during following API calls.\n\t * @private\n\t */\n\t_cacheId: 0,\n\n\t/**\n\t * Registers the given plugin(s) if not already registered.\n\t * @param {Array|Object} plugins plugin instance(s).\n\t */\n\tregister: function(plugins) {\n\t\tvar p = this._plugins;\n\t\t([]).concat(plugins).forEach(function(plugin) {\n\t\t\tif (p.indexOf(plugin) === -1) {\n\t\t\t\tp.push(plugin);\n\t\t\t}\n\t\t});\n\n\t\tthis._cacheId++;\n\t},\n\n\t/**\n\t * Unregisters the given plugin(s) only if registered.\n\t * @param {Array|Object} plugins plugin instance(s).\n\t */\n\tunregister: function(plugins) {\n\t\tvar p = this._plugins;\n\t\t([]).concat(plugins).forEach(function(plugin) {\n\t\t\tvar idx = p.indexOf(plugin);\n\t\t\tif (idx !== -1) {\n\t\t\t\tp.splice(idx, 1);\n\t\t\t}\n\t\t});\n\n\t\tthis._cacheId++;\n\t},\n\n\t/**\n\t * Remove all registered plugins.\n\t * @since 2.1.5\n\t */\n\tclear: function() {\n\t\tthis._plugins = [];\n\t\tthis._cacheId++;\n\t},\n\n\t/**\n\t * Returns the number of registered plugins?\n\t * @returns {Number}\n\t * @since 2.1.5\n\t */\n\tcount: function() {\n\t\treturn this._plugins.length;\n\t},\n\n\t/**\n\t * Returns all registered plugin instances.\n\t * @returns {Array} array of plugin objects.\n\t * @since 2.1.5\n\t */\n\tgetAll: function() {\n\t\treturn this._plugins;\n\t},\n\n\t/**\n\t * Calls enabled plugins for `chart` on the specified hook and with the given args.\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t * returned value can be used, for instance, to interrupt the current action.\n\t * @param {Object} chart - The chart instance for which plugins should be called.\n\t * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t * @param {Array} [args] - Extra arguments to apply to the hook call.\n\t * @returns {Boolean} false if any of the plugins return false, else returns true.\n\t */\n\tnotify: function(chart, hook, args) {\n\t\tvar descriptors = this.descriptors(chart);\n\t\tvar ilen = descriptors.length;\n\t\tvar i, descriptor, plugin, params, method;\n\n\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\tdescriptor = descriptors[i];\n\t\t\tplugin = descriptor.plugin;\n\t\t\tmethod = plugin[hook];\n\t\t\tif (typeof method === 'function') {\n\t\t\t\tparams = [chart].concat(args || []);\n\t\t\t\tparams.push(descriptor.options);\n\t\t\t\tif (method.apply(plugin, params) === false) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/**\n\t * Returns descriptors of enabled plugins for the given chart.\n\t * @returns {Array} [{ plugin, options }]\n\t * @private\n\t */\n\tdescriptors: function(chart) {\n\t\tvar cache = chart.$plugins || (chart.$plugins = {});\n\t\tif (cache.id === this._cacheId) {\n\t\t\treturn cache.descriptors;\n\t\t}\n\n\t\tvar plugins = [];\n\t\tvar descriptors = [];\n\t\tvar config = (chart && chart.config) || {};\n\t\tvar options = (config.options && config.options.plugins) || {};\n\n\t\tthis._plugins.concat(config.plugins || []).forEach(function(plugin) {\n\t\t\tvar idx = plugins.indexOf(plugin);\n\t\t\tif (idx !== -1) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar id = plugin.id;\n\t\t\tvar opts = options[id];\n\t\t\tif (opts === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (opts === true) {\n\t\t\t\topts = helpers.clone(defaults.global.plugins[id]);\n\t\t\t}\n\n\t\t\tplugins.push(plugin);\n\t\t\tdescriptors.push({\n\t\t\t\tplugin: plugin,\n\t\t\t\toptions: opts || {}\n\t\t\t});\n\t\t});\n\n\t\tcache.descriptors = descriptors;\n\t\tcache.id = this._cacheId;\n\t\treturn descriptors;\n\t},\n\n\t/**\n\t * Invalidates cache for the given chart: descriptors hold a reference on plugin option,\n\t * but in some cases, this reference can be changed by the user when updating options.\n\t * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\n\t * @private\n\t */\n\t_invalidate: function(chart) {\n\t\tdelete chart.$plugins;\n\t}\n};\n\n/**\n * Plugin extension hooks.\n * @interface IPlugin\n * @since 2.1.0\n */\n/**\n * @method IPlugin#beforeInit\n * @desc Called before initializing `chart`.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#afterInit\n * @desc Called after `chart` has been initialized and before the first update.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeUpdate\n * @desc Called before updating `chart`. If any plugin returns `false`, the update\n * is cancelled (and thus subsequent render(s)) until another `update` is triggered.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart update.\n */\n/**\n * @method IPlugin#afterUpdate\n * @desc Called after `chart` has been updated and before rendering. Note that this\n * hook will not be called if the chart update has been previously cancelled.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeDatasetsUpdate\n * @desc Called before updating the `chart` datasets. If any plugin returns `false`,\n * the datasets update is cancelled until another `update` is triggered.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} false to cancel the datasets update.\n * @since version 2.1.5\n*/\n/**\n * @method IPlugin#afterDatasetsUpdate\n * @desc Called after the `chart` datasets have been updated. Note that this hook\n * will not be called if the datasets update has been previously cancelled.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n * @since version 2.1.5\n */\n/**\n * @method IPlugin#beforeDatasetUpdate\n * @desc Called before updating the `chart` dataset at the given `args.index`. If any plugin\n * returns `false`, the datasets update is cancelled until another `update` is triggered.\n * @param {Chart} chart - The chart instance.\n * @param {Object} args - The call arguments.\n * @param {Number} args.index - The dataset index.\n * @param {Object} args.meta - The dataset metadata.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart datasets drawing.\n */\n/**\n * @method IPlugin#afterDatasetUpdate\n * @desc Called after the `chart` datasets at the given `args.index` has been updated. Note\n * that this hook will not be called if the datasets update has been previously cancelled.\n * @param {Chart} chart - The chart instance.\n * @param {Object} args - The call arguments.\n * @param {Number} args.index - The dataset index.\n * @param {Object} args.meta - The dataset metadata.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeLayout\n * @desc Called before laying out `chart`. If any plugin returns `false`,\n * the layout update is cancelled until another `update` is triggered.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart layout.\n */\n/**\n * @method IPlugin#afterLayout\n * @desc Called after the `chart` has been layed out. Note that this hook will not\n * be called if the layout update has been previously cancelled.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeRender\n * @desc Called before rendering `chart`. If any plugin returns `false`,\n * the rendering is cancelled until another `render` is triggered.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart rendering.\n */\n/**\n * @method IPlugin#afterRender\n * @desc Called after the `chart` has been fully rendered (and animation completed). Note\n * that this hook will not be called if the rendering has been previously cancelled.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeDraw\n * @desc Called before drawing `chart` at every animation frame specified by the given\n * easing value. If any plugin returns `false`, the frame drawing is cancelled until\n * another `render` is triggered.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart drawing.\n */\n/**\n * @method IPlugin#afterDraw\n * @desc Called after the `chart` has been drawn for the specific easing value. Note\n * that this hook will not be called if the drawing has been previously cancelled.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeDatasetsDraw\n * @desc Called before drawing the `chart` datasets. If any plugin returns `false`,\n * the datasets drawing is cancelled until another `render` is triggered.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart datasets drawing.\n */\n/**\n * @method IPlugin#afterDatasetsDraw\n * @desc Called after the `chart` datasets have been drawn. Note that this hook\n * will not be called if the datasets drawing has been previously cancelled.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeDatasetDraw\n * @desc Called before drawing the `chart` dataset at the given `args.index` (datasets\n * are drawn in the reverse order). If any plugin returns `false`, the datasets drawing\n * is cancelled until another `render` is triggered.\n * @param {Chart} chart - The chart instance.\n * @param {Object} args - The call arguments.\n * @param {Number} args.index - The dataset index.\n * @param {Object} args.meta - The dataset metadata.\n * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart datasets drawing.\n */\n/**\n * @method IPlugin#afterDatasetDraw\n * @desc Called after the `chart` datasets at the given `args.index` have been drawn\n * (datasets are drawn in the reverse order). Note that this hook will not be called\n * if the datasets drawing has been previously cancelled.\n * @param {Chart} chart - The chart instance.\n * @param {Object} args - The call arguments.\n * @param {Number} args.index - The dataset index.\n * @param {Object} args.meta - The dataset metadata.\n * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeTooltipDraw\n * @desc Called before drawing the `tooltip`. If any plugin returns `false`,\n * the tooltip drawing is cancelled until another `render` is triggered.\n * @param {Chart} chart - The chart instance.\n * @param {Object} args - The call arguments.\n * @param {Object} args.tooltip - The tooltip.\n * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart tooltip drawing.\n */\n/**\n * @method IPlugin#afterTooltipDraw\n * @desc Called after drawing the `tooltip`. Note that this hook will not\n * be called if the tooltip drawing has been previously cancelled.\n * @param {Chart} chart - The chart instance.\n * @param {Object} args - The call arguments.\n * @param {Object} args.tooltip - The tooltip.\n * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeEvent\n * @desc Called before processing the specified `event`. If any plugin returns `false`,\n * the event will be discarded.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {IEvent} event - The event object.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#afterEvent\n * @desc Called after the `event` has been consumed. Note that this hook\n * will not be called if the `event` has been previously discarded.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {IEvent} event - The event object.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#resize\n * @desc Called after the chart as been resized.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Number} size - The new canvas display size (eq. canvas.style width & height).\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#destroy\n * @desc Called after the chart as been destroyed.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n */\n\n},{\"../helpers/index\":53,\"./core.defaults\":33}],40:[function(require,module,exports){\n'use strict';\n\nvar defaults = require('./core.defaults');\nvar Element = require('./core.element');\nvar helpers = require('../helpers/index');\nvar Ticks = require('./core.ticks');\n\ndefaults._set('scale', {\n\tdisplay: true,\n\tposition: 'left',\n\toffset: false,\n\n\t// grid line settings\n\tgridLines: {\n\t\tdisplay: true,\n\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\tlineWidth: 1,\n\t\tdrawBorder: true,\n\t\tdrawOnChartArea: true,\n\t\tdrawTicks: true,\n\t\ttickMarkLength: 10,\n\t\tzeroLineWidth: 1,\n\t\tzeroLineColor: 'rgba(0,0,0,0.25)',\n\t\tzeroLineBorderDash: [],\n\t\tzeroLineBorderDashOffset: 0.0,\n\t\toffsetGridLines: false,\n\t\tborderDash: [],\n\t\tborderDashOffset: 0.0\n\t},\n\n\t// scale label\n\tscaleLabel: {\n\t\t// display property\n\t\tdisplay: false,\n\n\t\t// actual label\n\t\tlabelString: '',\n\n\t\t// line height\n\t\tlineHeight: 1.2,\n\n\t\t// top/bottom padding\n\t\tpadding: {\n\t\t\ttop: 4,\n\t\t\tbottom: 4\n\t\t}\n\t},\n\n\t// label settings\n\tticks: {\n\t\tbeginAtZero: false,\n\t\tminRotation: 0,\n\t\tmaxRotation: 50,\n\t\tmirror: false,\n\t\tpadding: 0,\n\t\treverse: false,\n\t\tdisplay: true,\n\t\tautoSkip: true,\n\t\tautoSkipPadding: 0,\n\t\tlabelOffset: 0,\n\t\t// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n\t\tcallback: Ticks.formatters.values,\n\t\tminor: {},\n\t\tmajor: {}\n\t}\n});\n\nfunction labelsFromTicks(ticks) {\n\tvar labels = [];\n\tvar i, ilen;\n\n\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\tlabels.push(ticks[i].label);\n\t}\n\n\treturn labels;\n}\n\nfunction getLineValue(scale, index, offsetGridLines) {\n\tvar lineValue = scale.getPixelForTick(index);\n\n\tif (offsetGridLines) {\n\t\tif (index === 0) {\n\t\t\tlineValue -= (scale.getPixelForTick(1) - lineValue) / 2;\n\t\t} else {\n\t\t\tlineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;\n\t\t}\n\t}\n\treturn lineValue;\n}\n\nmodule.exports = function(Chart) {\n\n\tfunction computeTextSize(context, tick, font) {\n\t\treturn helpers.isArray(tick) ?\n\t\t\thelpers.longestText(context, font, tick) :\n\t\t\tcontext.measureText(tick).width;\n\t}\n\n\tfunction parseFontOptions(options) {\n\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\tvar globalDefaults = defaults.global;\n\t\tvar size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\n\t\tvar style = valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);\n\t\tvar family = valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);\n\n\t\treturn {\n\t\t\tsize: size,\n\t\t\tstyle: style,\n\t\t\tfamily: family,\n\t\t\tfont: helpers.fontString(size, style, family)\n\t\t};\n\t}\n\n\tfunction parseLineHeight(options) {\n\t\treturn helpers.options.toLineHeight(\n\t\t\thelpers.valueOrDefault(options.lineHeight, 1.2),\n\t\t\thelpers.valueOrDefault(options.fontSize, defaults.global.defaultFontSize));\n\t}\n\n\tChart.Scale = Element.extend({\n\t\t/**\n\t\t * Get the padding needed for the scale\n\t\t * @method getPadding\n\t\t * @private\n\t\t * @returns {Padding} the necessary padding\n\t\t */\n\t\tgetPadding: function() {\n\t\t\tvar me = this;\n\t\t\treturn {\n\t\t\t\tleft: me.paddingLeft || 0,\n\t\t\t\ttop: me.paddingTop || 0,\n\t\t\t\tright: me.paddingRight || 0,\n\t\t\t\tbottom: me.paddingBottom || 0\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Returns the scale tick objects ({label, major})\n\t\t * @since 2.7\n\t\t */\n\t\tgetTicks: function() {\n\t\t\treturn this._ticks;\n\t\t},\n\n\t\t// These methods are ordered by lifecyle. Utilities then follow.\n\t\t// Any function defined here is inherited by all scale types.\n\t\t// Any function can be extended by the scale type\n\n\t\tmergeTicksOptions: function() {\n\t\t\tvar ticks = this.options.ticks;\n\t\t\tif (ticks.minor === false) {\n\t\t\t\tticks.minor = {\n\t\t\t\t\tdisplay: false\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (ticks.major === false) {\n\t\t\t\tticks.major = {\n\t\t\t\t\tdisplay: false\n\t\t\t\t};\n\t\t\t}\n\t\t\tfor (var key in ticks) {\n\t\t\t\tif (key !== 'major' && key !== 'minor') {\n\t\t\t\t\tif (typeof ticks.minor[key] === 'undefined') {\n\t\t\t\t\t\tticks.minor[key] = ticks[key];\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof ticks.major[key] === 'undefined') {\n\t\t\t\t\t\tticks.major[key] = ticks[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tbeforeUpdate: function() {\n\t\t\thelpers.callback(this.options.beforeUpdate, [this]);\n\t\t},\n\t\tupdate: function(maxWidth, maxHeight, margins) {\n\t\t\tvar me = this;\n\t\t\tvar i, ilen, labels, label, ticks, tick;\n\n\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\tme.beforeUpdate();\n\n\t\t\t// Absorb the master measurements\n\t\t\tme.maxWidth = maxWidth;\n\t\t\tme.maxHeight = maxHeight;\n\t\t\tme.margins = helpers.extend({\n\t\t\t\tleft: 0,\n\t\t\t\tright: 0,\n\t\t\t\ttop: 0,\n\t\t\t\tbottom: 0\n\t\t\t}, margins);\n\t\t\tme.longestTextCache = me.longestTextCache || {};\n\n\t\t\t// Dimensions\n\t\t\tme.beforeSetDimensions();\n\t\t\tme.setDimensions();\n\t\t\tme.afterSetDimensions();\n\n\t\t\t// Data min/max\n\t\t\tme.beforeDataLimits();\n\t\t\tme.determineDataLimits();\n\t\t\tme.afterDataLimits();\n\n\t\t\t// Ticks - `this.ticks` is now DEPRECATED!\n\t\t\t// Internal ticks are now stored as objects in the PRIVATE `this._ticks` member\n\t\t\t// and must not be accessed directly from outside this class. `this.ticks` being\n\t\t\t// around for long time and not marked as private, we can't change its structure\n\t\t\t// without unexpected breaking changes. If you need to access the scale ticks,\n\t\t\t// use scale.getTicks() instead.\n\n\t\t\tme.beforeBuildTicks();\n\n\t\t\t// New implementations should return an array of objects but for BACKWARD COMPAT,\n\t\t\t// we still support no return (`this.ticks` internally set by calling this method).\n\t\t\tticks = me.buildTicks() || [];\n\n\t\t\tme.afterBuildTicks();\n\n\t\t\tme.beforeTickToLabelConversion();\n\n\t\t\t// New implementations should return the formatted tick labels but for BACKWARD\n\t\t\t// COMPAT, we still support no return (`this.ticks` internally changed by calling\n\t\t\t// this method and supposed to contain only string values).\n\t\t\tlabels = me.convertTicksToLabels(ticks) || me.ticks;\n\n\t\t\tme.afterTickToLabelConversion();\n\n\t\t\tme.ticks = labels;   // BACKWARD COMPATIBILITY\n\n\t\t\t// IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!\n\n\t\t\t// BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)\n\t\t\tfor (i = 0, ilen = labels.length; i < ilen; ++i) {\n\t\t\t\tlabel = labels[i];\n\t\t\t\ttick = ticks[i];\n\t\t\t\tif (!tick) {\n\t\t\t\t\tticks.push(tick = {\n\t\t\t\t\t\tlabel: label,\n\t\t\t\t\t\tmajor: false\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\ttick.label = label;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme._ticks = ticks;\n\n\t\t\t// Tick Rotation\n\t\t\tme.beforeCalculateTickRotation();\n\t\t\tme.calculateTickRotation();\n\t\t\tme.afterCalculateTickRotation();\n\t\t\t// Fit\n\t\t\tme.beforeFit();\n\t\t\tme.fit();\n\t\t\tme.afterFit();\n\t\t\t//\n\t\t\tme.afterUpdate();\n\n\t\t\treturn me.minSize;\n\n\t\t},\n\t\tafterUpdate: function() {\n\t\t\thelpers.callback(this.options.afterUpdate, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeSetDimensions: function() {\n\t\t\thelpers.callback(this.options.beforeSetDimensions, [this]);\n\t\t},\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.width = me.maxWidth;\n\t\t\t\tme.left = 0;\n\t\t\t\tme.right = me.width;\n\t\t\t} else {\n\t\t\t\tme.height = me.maxHeight;\n\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.top = 0;\n\t\t\t\tme.bottom = me.height;\n\t\t\t}\n\n\t\t\t// Reset padding\n\t\t\tme.paddingLeft = 0;\n\t\t\tme.paddingTop = 0;\n\t\t\tme.paddingRight = 0;\n\t\t\tme.paddingBottom = 0;\n\t\t},\n\t\tafterSetDimensions: function() {\n\t\t\thelpers.callback(this.options.afterSetDimensions, [this]);\n\t\t},\n\n\t\t// Data limits\n\t\tbeforeDataLimits: function() {\n\t\t\thelpers.callback(this.options.beforeDataLimits, [this]);\n\t\t},\n\t\tdetermineDataLimits: helpers.noop,\n\t\tafterDataLimits: function() {\n\t\t\thelpers.callback(this.options.afterDataLimits, [this]);\n\t\t},\n\n\t\t//\n\t\tbeforeBuildTicks: function() {\n\t\t\thelpers.callback(this.options.beforeBuildTicks, [this]);\n\t\t},\n\t\tbuildTicks: helpers.noop,\n\t\tafterBuildTicks: function() {\n\t\t\thelpers.callback(this.options.afterBuildTicks, [this]);\n\t\t},\n\n\t\tbeforeTickToLabelConversion: function() {\n\t\t\thelpers.callback(this.options.beforeTickToLabelConversion, [this]);\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\t// Convert ticks to strings\n\t\t\tvar tickOpts = me.options.ticks;\n\t\t\tme.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);\n\t\t},\n\t\tafterTickToLabelConversion: function() {\n\t\t\thelpers.callback(this.options.afterTickToLabelConversion, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeCalculateTickRotation: function() {\n\t\t\thelpers.callback(this.options.beforeCalculateTickRotation, [this]);\n\t\t},\n\t\tcalculateTickRotation: function() {\n\t\t\tvar me = this;\n\t\t\tvar context = me.ctx;\n\t\t\tvar tickOpts = me.options.ticks;\n\t\t\tvar labels = labelsFromTicks(me._ticks);\n\n\t\t\t// Get the width of each grid by calculating the difference\n\t\t\t// between x offsets between 0 and 1.\n\t\t\tvar tickFont = parseFontOptions(tickOpts);\n\t\t\tcontext.font = tickFont.font;\n\n\t\t\tvar labelRotation = tickOpts.minRotation || 0;\n\n\t\t\tif (labels.length && me.options.display && me.isHorizontal()) {\n\t\t\t\tvar originalLabelWidth = helpers.longestText(context, tickFont.font, labels, me.longestTextCache);\n\t\t\t\tvar labelWidth = originalLabelWidth;\n\t\t\t\tvar cosRotation, sinRotation;\n\n\t\t\t\t// Allow 3 pixels x2 padding either side for label readability\n\t\t\t\tvar tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;\n\n\t\t\t\t// Max label rotation can be set or default to 90 - also act as a loop counter\n\t\t\t\twhile (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {\n\t\t\t\t\tvar angleRadians = helpers.toRadians(labelRotation);\n\t\t\t\t\tcosRotation = Math.cos(angleRadians);\n\t\t\t\t\tsinRotation = Math.sin(angleRadians);\n\n\t\t\t\t\tif (sinRotation * originalLabelWidth > me.maxHeight) {\n\t\t\t\t\t\t// go back one step\n\t\t\t\t\t\tlabelRotation--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tlabelRotation++;\n\t\t\t\t\tlabelWidth = cosRotation * originalLabelWidth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.labelRotation = labelRotation;\n\t\t},\n\t\tafterCalculateTickRotation: function() {\n\t\t\thelpers.callback(this.options.afterCalculateTickRotation, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeFit: function() {\n\t\t\thelpers.callback(this.options.beforeFit, [this]);\n\t\t},\n\t\tfit: function() {\n\t\t\tvar me = this;\n\t\t\t// Reset\n\t\t\tvar minSize = me.minSize = {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\n\t\t\tvar labels = labelsFromTicks(me._ticks);\n\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar scaleLabelOpts = opts.scaleLabel;\n\t\t\tvar gridLineOpts = opts.gridLines;\n\t\t\tvar display = opts.display;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tvar tickFont = parseFontOptions(tickOpts);\n\t\t\tvar tickMarkLength = opts.gridLines.tickMarkLength;\n\n\t\t\t// Width\n\t\t\tif (isHorizontal) {\n\t\t\t\t// subtract the margins to line up with the chartArea if we are a full width scale\n\t\t\t\tminSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\n\t\t\t} else {\n\t\t\t\tminSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t\t}\n\n\t\t\t// height\n\t\t\tif (isHorizontal) {\n\t\t\t\tminSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t\t} else {\n\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t}\n\n\t\t\t// Are we showing a title for the scale?\n\t\t\tif (scaleLabelOpts.display && display) {\n\t\t\t\tvar scaleLabelLineHeight = parseLineHeight(scaleLabelOpts);\n\t\t\t\tvar scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);\n\t\t\t\tvar deltaHeight = scaleLabelLineHeight + scaleLabelPadding.height;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tminSize.height += deltaHeight;\n\t\t\t\t} else {\n\t\t\t\t\tminSize.width += deltaHeight;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Don't bother fitting the ticks if we are not showing them\n\t\t\tif (tickOpts.display && display) {\n\t\t\t\tvar largestTextWidth = helpers.longestText(me.ctx, tickFont.font, labels, me.longestTextCache);\n\t\t\t\tvar tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);\n\t\t\t\tvar lineSpace = tickFont.size * 0.5;\n\t\t\t\tvar tickPadding = me.options.ticks.padding;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t// A horizontal axis is more constrained by the height.\n\t\t\t\t\tme.longestLabelWidth = largestTextWidth;\n\n\t\t\t\t\tvar angleRadians = helpers.toRadians(me.labelRotation);\n\t\t\t\t\tvar cosRotation = Math.cos(angleRadians);\n\t\t\t\t\tvar sinRotation = Math.sin(angleRadians);\n\n\t\t\t\t\t// TODO - improve this calculation\n\t\t\t\t\tvar labelHeight = (sinRotation * largestTextWidth)\n\t\t\t\t\t\t+ (tickFont.size * tallestLabelHeightInLines)\n\t\t\t\t\t\t+ (lineSpace * (tallestLabelHeightInLines - 1))\n\t\t\t\t\t\t+ lineSpace; // padding\n\n\t\t\t\t\tminSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);\n\n\t\t\t\t\tme.ctx.font = tickFont.font;\n\t\t\t\t\tvar firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.font);\n\t\t\t\t\tvar lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.font);\n\n\t\t\t\t\t// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\n\t\t\t\t\t// which means that the right padding is dominated by the font height\n\t\t\t\t\tif (me.labelRotation !== 0) {\n\t\t\t\t\t\tme.paddingLeft = opts.position === 'bottom' ? (cosRotation * firstLabelWidth) + 3 : (cosRotation * lineSpace) + 3; // add 3 px to move away from canvas edges\n\t\t\t\t\t\tme.paddingRight = opts.position === 'bottom' ? (cosRotation * lineSpace) + 3 : (cosRotation * lastLabelWidth) + 3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tme.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges\n\t\t\t\t\t\tme.paddingRight = lastLabelWidth / 2 + 3;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// A vertical axis is more constrained by the width. Labels are the\n\t\t\t\t\t// dominant factor here, so get that length first and account for padding\n\t\t\t\t\tif (tickOpts.mirror) {\n\t\t\t\t\t\tlargestTextWidth = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// use lineSpace for consistency with horizontal axis\n\t\t\t\t\t\t// tickPadding is not implemented for horizontal\n\t\t\t\t\t\tlargestTextWidth += tickPadding + lineSpace;\n\t\t\t\t\t}\n\n\t\t\t\t\tminSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);\n\n\t\t\t\t\tme.paddingTop = tickFont.size / 2;\n\t\t\t\t\tme.paddingBottom = tickFont.size / 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.handleMargins();\n\n\t\t\tme.width = minSize.width;\n\t\t\tme.height = minSize.height;\n\t\t},\n\n\t\t/**\n\t\t * Handle margins and padding interactions\n\t\t * @private\n\t\t */\n\t\thandleMargins: function() {\n\t\t\tvar me = this;\n\t\t\tif (me.margins) {\n\t\t\t\tme.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\n\t\t\t\tme.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);\n\t\t\t\tme.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\n\t\t\t\tme.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);\n\t\t\t}\n\t\t},\n\n\t\tafterFit: function() {\n\t\t\thelpers.callback(this.options.afterFit, [this]);\n\t\t},\n\n\t\t// Shared Methods\n\t\tisHorizontal: function() {\n\t\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t\t},\n\t\tisFullWidth: function() {\n\t\t\treturn (this.options.fullWidth);\n\t\t},\n\n\t\t// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not\n\t\tgetRightValue: function(rawValue) {\n\t\t\t// Null and undefined values first\n\t\t\tif (helpers.isNullOrUndef(rawValue)) {\n\t\t\t\treturn NaN;\n\t\t\t}\n\t\t\t// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values\n\t\t\tif (typeof rawValue === 'number' && !isFinite(rawValue)) {\n\t\t\t\treturn NaN;\n\t\t\t}\n\t\t\t// If it is in fact an object, dive in one more level\n\t\t\tif (rawValue) {\n\t\t\t\tif (this.isHorizontal()) {\n\t\t\t\t\tif (rawValue.x !== undefined) {\n\t\t\t\t\t\treturn this.getRightValue(rawValue.x);\n\t\t\t\t\t}\n\t\t\t\t} else if (rawValue.y !== undefined) {\n\t\t\t\t\treturn this.getRightValue(rawValue.y);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Value is good, return it\n\t\t\treturn rawValue;\n\t\t},\n\n\t\t/**\n\t\t * Used to get the value to display in the tooltip for the data at the given index\n\t\t * @param index\n\t\t * @param datasetIndex\n\t\t */\n\t\tgetLabelForIndex: helpers.noop,\n\n\t\t/**\n\t\t * Returns the location of the given data point. Value can either be an index or a numerical value\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t * @param value\n\t\t * @param index\n\t\t * @param datasetIndex\n\t\t */\n\t\tgetPixelForValue: helpers.noop,\n\n\t\t/**\n\t\t * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t * @param pixel\n\t\t */\n\t\tgetValueForPixel: helpers.noop,\n\n\t\t/**\n\t\t * Returns the location of the tick at the given index\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t */\n\t\tgetPixelForTick: function(index) {\n\t\t\tvar me = this;\n\t\t\tvar offset = me.options.offset;\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\tvar tickWidth = innerWidth / Math.max((me._ticks.length - (offset ? 0 : 1)), 1);\n\t\t\t\tvar pixel = (tickWidth * index) + me.paddingLeft;\n\n\t\t\t\tif (offset) {\n\t\t\t\t\tpixel += tickWidth / 2;\n\t\t\t\t}\n\n\t\t\t\tvar finalVal = me.left + Math.round(pixel);\n\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\t\treturn finalVal;\n\t\t\t}\n\t\t\tvar innerHeight = me.height - (me.paddingTop + me.paddingBottom);\n\t\t\treturn me.top + (index * (innerHeight / (me._ticks.length - 1)));\n\t\t},\n\n\t\t/**\n\t\t * Utility for getting the pixel location of a percentage of scale\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t */\n\t\tgetPixelForDecimal: function(decimal) {\n\t\t\tvar me = this;\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\tvar valueOffset = (innerWidth * decimal) + me.paddingLeft;\n\n\t\t\t\tvar finalVal = me.left + Math.round(valueOffset);\n\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\t\treturn finalVal;\n\t\t\t}\n\t\t\treturn me.top + (decimal * me.height);\n\t\t},\n\n\t\t/**\n\t\t * Returns the pixel for the minimum chart value\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t */\n\t\tgetBasePixel: function() {\n\t\t\treturn this.getPixelForValue(this.getBaseValue());\n\t\t},\n\n\t\tgetBaseValue: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\n\t\t\treturn me.beginAtZero ? 0 :\n\t\t\t\tmin < 0 && max < 0 ? max :\n\t\t\t\tmin > 0 && max > 0 ? min :\n\t\t\t\t0;\n\t\t},\n\n\t\t/**\n\t\t * Returns a subset of ticks to be plotted to avoid overlapping labels.\n\t\t * @private\n\t\t */\n\t\t_autoSkip: function(ticks) {\n\t\t\tvar skipRatio;\n\t\t\tvar me = this;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar optionTicks = me.options.ticks.minor;\n\t\t\tvar tickCount = ticks.length;\n\t\t\tvar labelRotationRadians = helpers.toRadians(me.labelRotation);\n\t\t\tvar cosRotation = Math.cos(labelRotationRadians);\n\t\t\tvar longestRotatedLabel = me.longestLabelWidth * cosRotation;\n\t\t\tvar result = [];\n\t\t\tvar i, tick, shouldSkip;\n\n\t\t\t// figure out the maximum number of gridlines to show\n\t\t\tvar maxTicks;\n\t\t\tif (optionTicks.maxTicksLimit) {\n\t\t\t\tmaxTicks = optionTicks.maxTicksLimit;\n\t\t\t}\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tskipRatio = false;\n\n\t\t\t\tif ((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount > (me.width - (me.paddingLeft + me.paddingRight))) {\n\t\t\t\t\tskipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount) / (me.width - (me.paddingLeft + me.paddingRight)));\n\t\t\t\t}\n\n\t\t\t\t// if they defined a max number of optionTicks,\n\t\t\t\t// increase skipRatio until that number is met\n\t\t\t\tif (maxTicks && tickCount > maxTicks) {\n\t\t\t\t\tskipRatio = Math.max(skipRatio, Math.floor(tickCount / maxTicks));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < tickCount; i++) {\n\t\t\t\ttick = ticks[i];\n\n\t\t\t\t// Since we always show the last tick,we need may need to hide the last shown one before\n\t\t\t\tshouldSkip = (skipRatio > 1 && i % skipRatio > 0) || (i % skipRatio === 0 && i + skipRatio >= tickCount);\n\t\t\t\tif (shouldSkip && i !== tickCount - 1) {\n\t\t\t\t\t// leave tick in place but make sure it's not displayed (#4635)\n\t\t\t\t\tdelete tick.label;\n\t\t\t\t}\n\t\t\t\tresult.push(tick);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\n\t\t// Actually draw the scale on the canvas\n\t\t// @param {rectangle} chartArea : the area of the chart to draw full grid lines on\n\t\tdraw: function(chartArea) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tif (!options.display) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar context = me.ctx;\n\t\t\tvar globalDefaults = defaults.global;\n\t\t\tvar optionTicks = options.ticks.minor;\n\t\t\tvar optionMajorTicks = options.ticks.major || optionTicks;\n\t\t\tvar gridLines = options.gridLines;\n\t\t\tvar scaleLabel = options.scaleLabel;\n\n\t\t\tvar isRotated = me.labelRotation !== 0;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tvar ticks = optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();\n\t\t\tvar tickFontColor = helpers.valueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);\n\t\t\tvar tickFont = parseFontOptions(optionTicks);\n\t\t\tvar majorTickFontColor = helpers.valueOrDefault(optionMajorTicks.fontColor, globalDefaults.defaultFontColor);\n\t\t\tvar majorTickFont = parseFontOptions(optionMajorTicks);\n\n\t\t\tvar tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;\n\n\t\t\tvar scaleLabelFontColor = helpers.valueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);\n\t\t\tvar scaleLabelFont = parseFontOptions(scaleLabel);\n\t\t\tvar scaleLabelPadding = helpers.options.toPadding(scaleLabel.padding);\n\t\t\tvar labelRotationRadians = helpers.toRadians(me.labelRotation);\n\n\t\t\tvar itemsToDraw = [];\n\n\t\t\tvar axisWidth = me.options.gridLines.lineWidth;\n\t\t\tvar xTickStart = options.position === 'right' ? me.right : me.right - axisWidth - tl;\n\t\t\tvar xTickEnd = options.position === 'right' ? me.right + tl : me.right;\n\t\t\tvar yTickStart = options.position === 'bottom' ? me.top + axisWidth : me.bottom - tl - axisWidth;\n\t\t\tvar yTickEnd = options.position === 'bottom' ? me.top + axisWidth + tl : me.bottom + axisWidth;\n\n\t\t\thelpers.each(ticks, function(tick, index) {\n\t\t\t\t// autoskipper skipped this tick (#4635)\n\t\t\t\tif (helpers.isNullOrUndef(tick.label)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar label = tick.label;\n\t\t\t\tvar lineWidth, lineColor, borderDash, borderDashOffset;\n\t\t\t\tif (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {\n\t\t\t\t\t// Draw the first index specially\n\t\t\t\t\tlineWidth = gridLines.zeroLineWidth;\n\t\t\t\t\tlineColor = gridLines.zeroLineColor;\n\t\t\t\t\tborderDash = gridLines.zeroLineBorderDash;\n\t\t\t\t\tborderDashOffset = gridLines.zeroLineBorderDashOffset;\n\t\t\t\t} else {\n\t\t\t\t\tlineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, index);\n\t\t\t\t\tlineColor = helpers.valueAtIndexOrDefault(gridLines.color, index);\n\t\t\t\t\tborderDash = helpers.valueOrDefault(gridLines.borderDash, globalDefaults.borderDash);\n\t\t\t\t\tborderDashOffset = helpers.valueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);\n\t\t\t\t}\n\n\t\t\t\t// Common properties\n\t\t\t\tvar tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;\n\t\t\t\tvar textAlign = 'middle';\n\t\t\t\tvar textBaseline = 'middle';\n\t\t\t\tvar tickPadding = optionTicks.padding;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tvar labelYOffset = tl + tickPadding;\n\n\t\t\t\t\tif (options.position === 'bottom') {\n\t\t\t\t\t\t// bottom\n\t\t\t\t\t\ttextBaseline = !isRotated ? 'top' : 'middle';\n\t\t\t\t\t\ttextAlign = !isRotated ? 'center' : 'right';\n\t\t\t\t\t\tlabelY = me.top + labelYOffset;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// top\n\t\t\t\t\t\ttextBaseline = !isRotated ? 'bottom' : 'middle';\n\t\t\t\t\t\ttextAlign = !isRotated ? 'center' : 'left';\n\t\t\t\t\t\tlabelY = me.bottom - labelYOffset;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar xLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);\n\t\t\t\t\tif (xLineValue < me.left) {\n\t\t\t\t\t\tlineColor = 'rgba(0,0,0,0)';\n\t\t\t\t\t}\n\t\t\t\t\txLineValue += helpers.aliasPixel(lineWidth);\n\n\t\t\t\t\tlabelX = me.getPixelForTick(index) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)\n\n\t\t\t\t\ttx1 = tx2 = x1 = x2 = xLineValue;\n\t\t\t\t\tty1 = yTickStart;\n\t\t\t\t\tty2 = yTickEnd;\n\t\t\t\t\ty1 = chartArea.top;\n\t\t\t\t\ty2 = chartArea.bottom + axisWidth;\n\t\t\t\t} else {\n\t\t\t\t\tvar isLeft = options.position === 'left';\n\t\t\t\t\tvar labelXOffset;\n\n\t\t\t\t\tif (optionTicks.mirror) {\n\t\t\t\t\t\ttextAlign = isLeft ? 'left' : 'right';\n\t\t\t\t\t\tlabelXOffset = tickPadding;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttextAlign = isLeft ? 'right' : 'left';\n\t\t\t\t\t\tlabelXOffset = tl + tickPadding;\n\t\t\t\t\t}\n\n\t\t\t\t\tlabelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;\n\n\t\t\t\t\tvar yLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);\n\t\t\t\t\tif (yLineValue < me.top) {\n\t\t\t\t\t\tlineColor = 'rgba(0,0,0,0)';\n\t\t\t\t\t}\n\t\t\t\t\tyLineValue += helpers.aliasPixel(lineWidth);\n\n\t\t\t\t\tlabelY = me.getPixelForTick(index) + optionTicks.labelOffset;\n\n\t\t\t\t\ttx1 = xTickStart;\n\t\t\t\t\ttx2 = xTickEnd;\n\t\t\t\t\tx1 = chartArea.left;\n\t\t\t\t\tx2 = chartArea.right + axisWidth;\n\t\t\t\t\tty1 = ty2 = y1 = y2 = yLineValue;\n\t\t\t\t}\n\n\t\t\t\titemsToDraw.push({\n\t\t\t\t\ttx1: tx1,\n\t\t\t\t\tty1: ty1,\n\t\t\t\t\ttx2: tx2,\n\t\t\t\t\tty2: ty2,\n\t\t\t\t\tx1: x1,\n\t\t\t\t\ty1: y1,\n\t\t\t\t\tx2: x2,\n\t\t\t\t\ty2: y2,\n\t\t\t\t\tlabelX: labelX,\n\t\t\t\t\tlabelY: labelY,\n\t\t\t\t\tglWidth: lineWidth,\n\t\t\t\t\tglColor: lineColor,\n\t\t\t\t\tglBorderDash: borderDash,\n\t\t\t\t\tglBorderDashOffset: borderDashOffset,\n\t\t\t\t\trotation: -1 * labelRotationRadians,\n\t\t\t\t\tlabel: label,\n\t\t\t\t\tmajor: tick.major,\n\t\t\t\t\ttextBaseline: textBaseline,\n\t\t\t\t\ttextAlign: textAlign\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// Draw all of the tick labels, tick marks, and grid lines at the correct places\n\t\t\thelpers.each(itemsToDraw, function(itemToDraw) {\n\t\t\t\tif (gridLines.display) {\n\t\t\t\t\tcontext.save();\n\t\t\t\t\tcontext.lineWidth = itemToDraw.glWidth;\n\t\t\t\t\tcontext.strokeStyle = itemToDraw.glColor;\n\t\t\t\t\tif (context.setLineDash) {\n\t\t\t\t\t\tcontext.setLineDash(itemToDraw.glBorderDash);\n\t\t\t\t\t\tcontext.lineDashOffset = itemToDraw.glBorderDashOffset;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.beginPath();\n\n\t\t\t\t\tif (gridLines.drawTicks) {\n\t\t\t\t\t\tcontext.moveTo(itemToDraw.tx1, itemToDraw.ty1);\n\t\t\t\t\t\tcontext.lineTo(itemToDraw.tx2, itemToDraw.ty2);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gridLines.drawOnChartArea) {\n\t\t\t\t\t\tcontext.moveTo(itemToDraw.x1, itemToDraw.y1);\n\t\t\t\t\t\tcontext.lineTo(itemToDraw.x2, itemToDraw.y2);\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.stroke();\n\t\t\t\t\tcontext.restore();\n\t\t\t\t}\n\n\t\t\t\tif (optionTicks.display) {\n\t\t\t\t\t// Make sure we draw text in the correct color and font\n\t\t\t\t\tcontext.save();\n\t\t\t\t\tcontext.translate(itemToDraw.labelX, itemToDraw.labelY);\n\t\t\t\t\tcontext.rotate(itemToDraw.rotation);\n\t\t\t\t\tcontext.font = itemToDraw.major ? majorTickFont.font : tickFont.font;\n\t\t\t\t\tcontext.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;\n\t\t\t\t\tcontext.textBaseline = itemToDraw.textBaseline;\n\t\t\t\t\tcontext.textAlign = itemToDraw.textAlign;\n\n\t\t\t\t\tvar label = itemToDraw.label;\n\t\t\t\t\tif (helpers.isArray(label)) {\n\t\t\t\t\t\tvar lineCount = label.length;\n\t\t\t\t\t\tvar lineHeight = tickFont.size * 1.5;\n\t\t\t\t\t\tvar y = me.isHorizontal() ? 0 : -lineHeight * (lineCount - 1) / 2;\n\n\t\t\t\t\t\tfor (var i = 0; i < lineCount; ++i) {\n\t\t\t\t\t\t\t// We just make sure the multiline element is a string here..\n\t\t\t\t\t\t\tcontext.fillText('' + label[i], 0, y);\n\t\t\t\t\t\t\t// apply same lineSpacing as calculated @ L#320\n\t\t\t\t\t\t\ty += lineHeight;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.fillText(label, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\tcontext.restore();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (scaleLabel.display) {\n\t\t\t\t// Draw the scale label\n\t\t\t\tvar scaleLabelX;\n\t\t\t\tvar scaleLabelY;\n\t\t\t\tvar rotation = 0;\n\t\t\t\tvar halfLineHeight = parseLineHeight(scaleLabel) / 2;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tscaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width\n\t\t\t\t\tscaleLabelY = options.position === 'bottom'\n\t\t\t\t\t\t? me.bottom - halfLineHeight - scaleLabelPadding.bottom\n\t\t\t\t\t\t: me.top + halfLineHeight + scaleLabelPadding.top;\n\t\t\t\t} else {\n\t\t\t\t\tvar isLeft = options.position === 'left';\n\t\t\t\t\tscaleLabelX = isLeft\n\t\t\t\t\t\t? me.left + halfLineHeight + scaleLabelPadding.top\n\t\t\t\t\t\t: me.right - halfLineHeight - scaleLabelPadding.top;\n\t\t\t\t\tscaleLabelY = me.top + ((me.bottom - me.top) / 2);\n\t\t\t\t\trotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\n\t\t\t\t}\n\n\t\t\t\tcontext.save();\n\t\t\t\tcontext.translate(scaleLabelX, scaleLabelY);\n\t\t\t\tcontext.rotate(rotation);\n\t\t\t\tcontext.textAlign = 'center';\n\t\t\t\tcontext.textBaseline = 'middle';\n\t\t\t\tcontext.fillStyle = scaleLabelFontColor; // render in correct colour\n\t\t\t\tcontext.font = scaleLabelFont.font;\n\t\t\t\tcontext.fillText(scaleLabel.labelString, 0, 0);\n\t\t\t\tcontext.restore();\n\t\t\t}\n\n\t\t\tif (gridLines.drawBorder) {\n\t\t\t\t// Draw the line at the edge of the axis\n\t\t\t\tcontext.lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, 0);\n\t\t\t\tcontext.strokeStyle = helpers.valueAtIndexOrDefault(gridLines.color, 0);\n\t\t\t\tvar x1 = me.left;\n\t\t\t\tvar x2 = me.right + axisWidth;\n\t\t\t\tvar y1 = me.top;\n\t\t\t\tvar y2 = me.bottom + axisWidth;\n\n\t\t\t\tvar aliasPixel = helpers.aliasPixel(context.lineWidth);\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\ty1 = y2 = options.position === 'top' ? me.bottom : me.top;\n\t\t\t\t\ty1 += aliasPixel;\n\t\t\t\t\ty2 += aliasPixel;\n\t\t\t\t} else {\n\t\t\t\t\tx1 = x2 = options.position === 'left' ? me.right : me.left;\n\t\t\t\t\tx1 += aliasPixel;\n\t\t\t\t\tx2 += aliasPixel;\n\t\t\t\t}\n\n\t\t\t\tcontext.beginPath();\n\t\t\t\tcontext.moveTo(x1, y1);\n\t\t\t\tcontext.lineTo(x2, y2);\n\t\t\t\tcontext.stroke();\n\t\t\t}\n\t\t}\n\t});\n};\n\n},{\"../helpers/index\":53,\"./core.defaults\":33,\"./core.element\":34,\"./core.ticks\":42}],41:[function(require,module,exports){\n'use strict';\n\nvar defaults = require('./core.defaults');\nvar helpers = require('../helpers/index');\nvar layouts = require('./core.layouts');\n\nmodule.exports = function(Chart) {\n\n\tChart.scaleService = {\n\t\t// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then\n\t\t// use the new chart options to grab the correct scale\n\t\tconstructors: {},\n\t\t// Use a registration function so that we can move to an ES6 map when we no longer need to support\n\t\t// old browsers\n\n\t\t// Scale config defaults\n\t\tdefaults: {},\n\t\tregisterScaleType: function(type, scaleConstructor, scaleDefaults) {\n\t\t\tthis.constructors[type] = scaleConstructor;\n\t\t\tthis.defaults[type] = helpers.clone(scaleDefaults);\n\t\t},\n\t\tgetScaleConstructor: function(type) {\n\t\t\treturn this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;\n\t\t},\n\t\tgetScaleDefaults: function(type) {\n\t\t\t// Return the scale defaults merged with the global settings so that we always use the latest ones\n\t\t\treturn this.defaults.hasOwnProperty(type) ? helpers.merge({}, [defaults.scale, this.defaults[type]]) : {};\n\t\t},\n\t\tupdateScaleDefaults: function(type, additions) {\n\t\t\tvar me = this;\n\t\t\tif (me.defaults.hasOwnProperty(type)) {\n\t\t\t\tme.defaults[type] = helpers.extend(me.defaults[type], additions);\n\t\t\t}\n\t\t},\n\t\taddScalesToLayout: function(chart) {\n\t\t\t// Adds each scale to the chart.boxes array to be sized accordingly\n\t\t\thelpers.each(chart.scales, function(scale) {\n\t\t\t\t// Set ILayoutItem parameters for backwards compatibility\n\t\t\t\tscale.fullWidth = scale.options.fullWidth;\n\t\t\t\tscale.position = scale.options.position;\n\t\t\t\tscale.weight = scale.options.weight;\n\t\t\t\tlayouts.addBox(chart, scale);\n\t\t\t});\n\t\t}\n\t};\n};\n\n},{\"../helpers/index\":53,\"./core.defaults\":33,\"./core.layouts\":38}],42:[function(require,module,exports){\n'use strict';\n\nvar helpers = require('../helpers/index');\n\n/**\n * Namespace to hold static tick generation functions\n * @namespace Chart.Ticks\n */\nmodule.exports = {\n\t/**\n\t * Namespace to hold formatters for different types of ticks\n\t * @namespace Chart.Ticks.formatters\n\t */\n\tformatters: {\n\t\t/**\n\t\t * Formatter for value labels\n\t\t * @method Chart.Ticks.formatters.values\n\t\t * @param value the value to display\n\t\t * @return {String|Array} the label to display\n\t\t */\n\t\tvalues: function(value) {\n\t\t\treturn helpers.isArray(value) ? value : '' + value;\n\t\t},\n\n\t\t/**\n\t\t * Formatter for linear numeric ticks\n\t\t * @method Chart.Ticks.formatters.linear\n\t\t * @param tickValue {Number} the value to be formatted\n\t\t * @param index {Number} the position of the tickValue parameter in the ticks array\n\t\t * @param ticks {Array<Number>} the list of ticks being converted\n\t\t * @return {String} string representation of the tickValue parameter\n\t\t */\n\t\tlinear: function(tickValue, index, ticks) {\n\t\t\t// If we have lots of ticks, don't use the ones\n\t\t\tvar delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];\n\n\t\t\t// If we have a number like 2.5 as the delta, figure out how many decimal places we need\n\t\t\tif (Math.abs(delta) > 1) {\n\t\t\t\tif (tickValue !== Math.floor(tickValue)) {\n\t\t\t\t\t// not an integer\n\t\t\t\t\tdelta = tickValue - Math.floor(tickValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar logDelta = helpers.log10(Math.abs(delta));\n\t\t\tvar tickString = '';\n\n\t\t\tif (tickValue !== 0) {\n\t\t\t\tvar numDecimal = -1 * Math.floor(logDelta);\n\t\t\t\tnumDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\n\t\t\t\ttickString = tickValue.toFixed(numDecimal);\n\t\t\t} else {\n\t\t\t\ttickString = '0'; // never show decimal places for 0\n\t\t\t}\n\n\t\t\treturn tickString;\n\t\t},\n\n\t\tlogarithmic: function(tickValue, index, ticks) {\n\t\t\tvar remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));\n\n\t\t\tif (tickValue === 0) {\n\t\t\t\treturn '0';\n\t\t\t} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\n\t\t\t\treturn tickValue.toExponential();\n\t\t\t}\n\t\t\treturn '';\n\t\t}\n\t}\n};\n\n},{\"../helpers/index\":53}],43:[function(require,module,exports){\n'use strict';\n\nvar defaults = require('./core.defaults');\nvar Element = require('./core.element');\nvar helpers = require('../helpers/index');\n\ndefaults._set('global', {\n\ttooltips: {\n\t\tenabled: true,\n\t\tcustom: null,\n\t\tmode: 'nearest',\n\t\tposition: 'average',\n\t\tintersect: true,\n\t\tbackgroundColor: 'rgba(0,0,0,0.8)',\n\t\ttitleFontStyle: 'bold',\n\t\ttitleSpacing: 2,\n\t\ttitleMarginBottom: 6,\n\t\ttitleFontColor: '#fff',\n\t\ttitleAlign: 'left',\n\t\tbodySpacing: 2,\n\t\tbodyFontColor: '#fff',\n\t\tbodyAlign: 'left',\n\t\tfooterFontStyle: 'bold',\n\t\tfooterSpacing: 2,\n\t\tfooterMarginTop: 6,\n\t\tfooterFontColor: '#fff',\n\t\tfooterAlign: 'left',\n\t\tyPadding: 6,\n\t\txPadding: 6,\n\t\tcaretPadding: 2,\n\t\tcaretSize: 5,\n\t\tcornerRadius: 6,\n\t\tmultiKeyBackground: '#fff',\n\t\tdisplayColors: true,\n\t\tborderColor: 'rgba(0,0,0,0)',\n\t\tborderWidth: 0,\n\t\tcallbacks: {\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tbeforeTitle: helpers.noop,\n\t\t\ttitle: function(tooltipItems, data) {\n\t\t\t\t// Pick first xLabel for now\n\t\t\t\tvar title = '';\n\t\t\t\tvar labels = data.labels;\n\t\t\t\tvar labelCount = labels ? labels.length : 0;\n\n\t\t\t\tif (tooltipItems.length > 0) {\n\t\t\t\t\tvar item = tooltipItems[0];\n\n\t\t\t\t\tif (item.xLabel) {\n\t\t\t\t\t\ttitle = item.xLabel;\n\t\t\t\t\t} else if (labelCount > 0 && item.index < labelCount) {\n\t\t\t\t\t\ttitle = labels[item.index];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn title;\n\t\t\t},\n\t\t\tafterTitle: helpers.noop,\n\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tbeforeBody: helpers.noop,\n\n\t\t\t// Args are: (tooltipItem, data)\n\t\t\tbeforeLabel: helpers.noop,\n\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\tvar label = data.datasets[tooltipItem.datasetIndex].label || '';\n\n\t\t\t\tif (label) {\n\t\t\t\t\tlabel += ': ';\n\t\t\t\t}\n\t\t\t\tlabel += tooltipItem.yLabel;\n\t\t\t\treturn label;\n\t\t\t},\n\t\t\tlabelColor: function(tooltipItem, chart) {\n\t\t\t\tvar meta = chart.getDatasetMeta(tooltipItem.datasetIndex);\n\t\t\t\tvar activeElement = meta.data[tooltipItem.index];\n\t\t\t\tvar view = activeElement._view;\n\t\t\t\treturn {\n\t\t\t\t\tborderColor: view.borderColor,\n\t\t\t\t\tbackgroundColor: view.backgroundColor\n\t\t\t\t};\n\t\t\t},\n\t\t\tlabelTextColor: function() {\n\t\t\t\treturn this._options.bodyFontColor;\n\t\t\t},\n\t\t\tafterLabel: helpers.noop,\n\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tafterBody: helpers.noop,\n\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tbeforeFooter: helpers.noop,\n\t\t\tfooter: helpers.noop,\n\t\t\tafterFooter: helpers.noop\n\t\t}\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\t/**\n \t * Helper method to merge the opacity into a color\n \t */\n\tfunction mergeOpacity(colorString, opacity) {\n\t\tvar color = helpers.color(colorString);\n\t\treturn color.alpha(opacity * color.alpha()).rgbaString();\n\t}\n\n\t// Helper to push or concat based on if the 2nd parameter is an array or not\n\tfunction pushOrConcat(base, toPush) {\n\t\tif (toPush) {\n\t\t\tif (helpers.isArray(toPush)) {\n\t\t\t\t// base = base.concat(toPush);\n\t\t\t\tArray.prototype.push.apply(base, toPush);\n\t\t\t} else {\n\t\t\t\tbase.push(toPush);\n\t\t\t}\n\t\t}\n\n\t\treturn base;\n\t}\n\n\t// Private helper to create a tooltip item model\n\t// @param element : the chart element (point, arc, bar) to create the tooltip item for\n\t// @return : new tooltip item\n\tfunction createTooltipItem(element) {\n\t\tvar xScale = element._xScale;\n\t\tvar yScale = element._yScale || element._scale; // handle radar || polarArea charts\n\t\tvar index = element._index;\n\t\tvar datasetIndex = element._datasetIndex;\n\n\t\treturn {\n\t\t\txLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',\n\t\t\tyLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',\n\t\t\tindex: index,\n\t\t\tdatasetIndex: datasetIndex,\n\t\t\tx: element._model.x,\n\t\t\ty: element._model.y\n\t\t};\n\t}\n\n\t/**\n\t * Helper to get the reset model for the tooltip\n\t * @param tooltipOpts {Object} the tooltip options\n\t */\n\tfunction getBaseModel(tooltipOpts) {\n\t\tvar globalDefaults = defaults.global;\n\t\tvar valueOrDefault = helpers.valueOrDefault;\n\n\t\treturn {\n\t\t\t// Positioning\n\t\t\txPadding: tooltipOpts.xPadding,\n\t\t\tyPadding: tooltipOpts.yPadding,\n\t\t\txAlign: tooltipOpts.xAlign,\n\t\t\tyAlign: tooltipOpts.yAlign,\n\n\t\t\t// Body\n\t\t\tbodyFontColor: tooltipOpts.bodyFontColor,\n\t\t\t_bodyFontFamily: valueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t_bodyFontStyle: valueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),\n\t\t\t_bodyAlign: tooltipOpts.bodyAlign,\n\t\t\tbodyFontSize: valueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),\n\t\t\tbodySpacing: tooltipOpts.bodySpacing,\n\n\t\t\t// Title\n\t\t\ttitleFontColor: tooltipOpts.titleFontColor,\n\t\t\t_titleFontFamily: valueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t_titleFontStyle: valueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),\n\t\t\ttitleFontSize: valueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),\n\t\t\t_titleAlign: tooltipOpts.titleAlign,\n\t\t\ttitleSpacing: tooltipOpts.titleSpacing,\n\t\t\ttitleMarginBottom: tooltipOpts.titleMarginBottom,\n\n\t\t\t// Footer\n\t\t\tfooterFontColor: tooltipOpts.footerFontColor,\n\t\t\t_footerFontFamily: valueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t_footerFontStyle: valueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),\n\t\t\tfooterFontSize: valueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),\n\t\t\t_footerAlign: tooltipOpts.footerAlign,\n\t\t\tfooterSpacing: tooltipOpts.footerSpacing,\n\t\t\tfooterMarginTop: tooltipOpts.footerMarginTop,\n\n\t\t\t// Appearance\n\t\t\tcaretSize: tooltipOpts.caretSize,\n\t\t\tcornerRadius: tooltipOpts.cornerRadius,\n\t\t\tbackgroundColor: tooltipOpts.backgroundColor,\n\t\t\topacity: 0,\n\t\t\tlegendColorBackground: tooltipOpts.multiKeyBackground,\n\t\t\tdisplayColors: tooltipOpts.displayColors,\n\t\t\tborderColor: tooltipOpts.borderColor,\n\t\t\tborderWidth: tooltipOpts.borderWidth\n\t\t};\n\t}\n\n\t/**\n\t * Get the size of the tooltip\n\t */\n\tfunction getTooltipSize(tooltip, model) {\n\t\tvar ctx = tooltip._chart.ctx;\n\n\t\tvar height = model.yPadding * 2; // Tooltip Padding\n\t\tvar width = 0;\n\n\t\t// Count of all lines in the body\n\t\tvar body = model.body;\n\t\tvar combinedBodyLength = body.reduce(function(count, bodyItem) {\n\t\t\treturn count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;\n\t\t}, 0);\n\t\tcombinedBodyLength += model.beforeBody.length + model.afterBody.length;\n\n\t\tvar titleLineCount = model.title.length;\n\t\tvar footerLineCount = model.footer.length;\n\t\tvar titleFontSize = model.titleFontSize;\n\t\tvar bodyFontSize = model.bodyFontSize;\n\t\tvar footerFontSize = model.footerFontSize;\n\n\t\theight += titleLineCount * titleFontSize; // Title Lines\n\t\theight += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing\n\t\theight += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin\n\t\theight += combinedBodyLength * bodyFontSize; // Body Lines\n\t\theight += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing\n\t\theight += footerLineCount ? model.footerMarginTop : 0; // Footer Margin\n\t\theight += footerLineCount * (footerFontSize); // Footer Lines\n\t\theight += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing\n\n\t\t// Title width\n\t\tvar widthPadding = 0;\n\t\tvar maxLineWidth = function(line) {\n\t\t\twidth = Math.max(width, ctx.measureText(line).width + widthPadding);\n\t\t};\n\n\t\tctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);\n\t\thelpers.each(model.title, maxLineWidth);\n\n\t\t// Body width\n\t\tctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);\n\t\thelpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);\n\n\t\t// Body lines may include some extra width due to the color box\n\t\twidthPadding = model.displayColors ? (bodyFontSize + 2) : 0;\n\t\thelpers.each(body, function(bodyItem) {\n\t\t\thelpers.each(bodyItem.before, maxLineWidth);\n\t\t\thelpers.each(bodyItem.lines, maxLineWidth);\n\t\t\thelpers.each(bodyItem.after, maxLineWidth);\n\t\t});\n\n\t\t// Reset back to 0\n\t\twidthPadding = 0;\n\n\t\t// Footer width\n\t\tctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);\n\t\thelpers.each(model.footer, maxLineWidth);\n\n\t\t// Add padding\n\t\twidth += 2 * model.xPadding;\n\n\t\treturn {\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\t}\n\n\t/**\n\t * Helper to get the alignment of a tooltip given the size\n\t */\n\tfunction determineAlignment(tooltip, size) {\n\t\tvar model = tooltip._model;\n\t\tvar chart = tooltip._chart;\n\t\tvar chartArea = tooltip._chart.chartArea;\n\t\tvar xAlign = 'center';\n\t\tvar yAlign = 'center';\n\n\t\tif (model.y < size.height) {\n\t\t\tyAlign = 'top';\n\t\t} else if (model.y > (chart.height - size.height)) {\n\t\t\tyAlign = 'bottom';\n\t\t}\n\n\t\tvar lf, rf; // functions to determine left, right alignment\n\t\tvar olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart\n\t\tvar yf; // function to get the y alignment if the tooltip goes outside of the left or right edges\n\t\tvar midX = (chartArea.left + chartArea.right) / 2;\n\t\tvar midY = (chartArea.top + chartArea.bottom) / 2;\n\n\t\tif (yAlign === 'center') {\n\t\t\tlf = function(x) {\n\t\t\t\treturn x <= midX;\n\t\t\t};\n\t\t\trf = function(x) {\n\t\t\t\treturn x > midX;\n\t\t\t};\n\t\t} else {\n\t\t\tlf = function(x) {\n\t\t\t\treturn x <= (size.width / 2);\n\t\t\t};\n\t\t\trf = function(x) {\n\t\t\t\treturn x >= (chart.width - (size.width / 2));\n\t\t\t};\n\t\t}\n\n\t\tolf = function(x) {\n\t\t\treturn x + size.width + model.caretSize + model.caretPadding > chart.width;\n\t\t};\n\t\torf = function(x) {\n\t\t\treturn x - size.width - model.caretSize - model.caretPadding < 0;\n\t\t};\n\t\tyf = function(y) {\n\t\t\treturn y <= midY ? 'top' : 'bottom';\n\t\t};\n\n\t\tif (lf(model.x)) {\n\t\t\txAlign = 'left';\n\n\t\t\t// Is tooltip too wide and goes over the right side of the chart.?\n\t\t\tif (olf(model.x)) {\n\t\t\t\txAlign = 'center';\n\t\t\t\tyAlign = yf(model.y);\n\t\t\t}\n\t\t} else if (rf(model.x)) {\n\t\t\txAlign = 'right';\n\n\t\t\t// Is tooltip too wide and goes outside left edge of canvas?\n\t\t\tif (orf(model.x)) {\n\t\t\t\txAlign = 'center';\n\t\t\t\tyAlign = yf(model.y);\n\t\t\t}\n\t\t}\n\n\t\tvar opts = tooltip._options;\n\t\treturn {\n\t\t\txAlign: opts.xAlign ? opts.xAlign : xAlign,\n\t\t\tyAlign: opts.yAlign ? opts.yAlign : yAlign\n\t\t};\n\t}\n\n\t/**\n\t * @Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\n\t */\n\tfunction getBackgroundPoint(vm, size, alignment, chart) {\n\t\t// Background Position\n\t\tvar x = vm.x;\n\t\tvar y = vm.y;\n\n\t\tvar caretSize = vm.caretSize;\n\t\tvar caretPadding = vm.caretPadding;\n\t\tvar cornerRadius = vm.cornerRadius;\n\t\tvar xAlign = alignment.xAlign;\n\t\tvar yAlign = alignment.yAlign;\n\t\tvar paddingAndSize = caretSize + caretPadding;\n\t\tvar radiusAndPadding = cornerRadius + caretPadding;\n\n\t\tif (xAlign === 'right') {\n\t\t\tx -= size.width;\n\t\t} else if (xAlign === 'center') {\n\t\t\tx -= (size.width / 2);\n\t\t\tif (x + size.width > chart.width) {\n\t\t\t\tx = chart.width - size.width;\n\t\t\t}\n\t\t\tif (x < 0) {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (yAlign === 'top') {\n\t\t\ty += paddingAndSize;\n\t\t} else if (yAlign === 'bottom') {\n\t\t\ty -= size.height + paddingAndSize;\n\t\t} else {\n\t\t\ty -= (size.height / 2);\n\t\t}\n\n\t\tif (yAlign === 'center') {\n\t\t\tif (xAlign === 'left') {\n\t\t\t\tx += paddingAndSize;\n\t\t\t} else if (xAlign === 'right') {\n\t\t\t\tx -= paddingAndSize;\n\t\t\t}\n\t\t} else if (xAlign === 'left') {\n\t\t\tx -= radiusAndPadding;\n\t\t} else if (xAlign === 'right') {\n\t\t\tx += radiusAndPadding;\n\t\t}\n\n\t\treturn {\n\t\t\tx: x,\n\t\t\ty: y\n\t\t};\n\t}\n\n\tChart.Tooltip = Element.extend({\n\t\tinitialize: function() {\n\t\t\tthis._model = getBaseModel(this._options);\n\t\t\tthis._lastActive = [];\n\t\t},\n\n\t\t// Get the title\n\t\t// Args are: (tooltipItem, data)\n\t\tgetTitle: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me._options;\n\t\t\tvar callbacks = opts.callbacks;\n\n\t\t\tvar beforeTitle = callbacks.beforeTitle.apply(me, arguments);\n\t\t\tvar title = callbacks.title.apply(me, arguments);\n\t\t\tvar afterTitle = callbacks.afterTitle.apply(me, arguments);\n\n\t\t\tvar lines = [];\n\t\t\tlines = pushOrConcat(lines, beforeTitle);\n\t\t\tlines = pushOrConcat(lines, title);\n\t\t\tlines = pushOrConcat(lines, afterTitle);\n\n\t\t\treturn lines;\n\t\t},\n\n\t\t// Args are: (tooltipItem, data)\n\t\tgetBeforeBody: function() {\n\t\t\tvar lines = this._options.callbacks.beforeBody.apply(this, arguments);\n\t\t\treturn helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\n\t\t},\n\n\t\t// Args are: (tooltipItem, data)\n\t\tgetBody: function(tooltipItems, data) {\n\t\t\tvar me = this;\n\t\t\tvar callbacks = me._options.callbacks;\n\t\t\tvar bodyItems = [];\n\n\t\t\thelpers.each(tooltipItems, function(tooltipItem) {\n\t\t\t\tvar bodyItem = {\n\t\t\t\t\tbefore: [],\n\t\t\t\t\tlines: [],\n\t\t\t\t\tafter: []\n\t\t\t\t};\n\t\t\t\tpushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));\n\t\t\t\tpushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));\n\t\t\t\tpushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));\n\n\t\t\t\tbodyItems.push(bodyItem);\n\t\t\t});\n\n\t\t\treturn bodyItems;\n\t\t},\n\n\t\t// Args are: (tooltipItem, data)\n\t\tgetAfterBody: function() {\n\t\t\tvar lines = this._options.callbacks.afterBody.apply(this, arguments);\n\t\t\treturn helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\n\t\t},\n\n\t\t// Get the footer and beforeFooter and afterFooter lines\n\t\t// Args are: (tooltipItem, data)\n\t\tgetFooter: function() {\n\t\t\tvar me = this;\n\t\t\tvar callbacks = me._options.callbacks;\n\n\t\t\tvar beforeFooter = callbacks.beforeFooter.apply(me, arguments);\n\t\t\tvar footer = callbacks.footer.apply(me, arguments);\n\t\t\tvar afterFooter = callbacks.afterFooter.apply(me, arguments);\n\n\t\t\tvar lines = [];\n\t\t\tlines = pushOrConcat(lines, beforeFooter);\n\t\t\tlines = pushOrConcat(lines, footer);\n\t\t\tlines = pushOrConcat(lines, afterFooter);\n\n\t\t\treturn lines;\n\t\t},\n\n\t\tupdate: function(changed) {\n\t\t\tvar me = this;\n\t\t\tvar opts = me._options;\n\n\t\t\t// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition\n\t\t\t// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time\n\t\t\t// which breaks any animations.\n\t\t\tvar existingModel = me._model;\n\t\t\tvar model = me._model = getBaseModel(opts);\n\t\t\tvar active = me._active;\n\n\t\t\tvar data = me._data;\n\n\t\t\t// In the case where active.length === 0 we need to keep these at existing values for good animations\n\t\t\tvar alignment = {\n\t\t\t\txAlign: existingModel.xAlign,\n\t\t\t\tyAlign: existingModel.yAlign\n\t\t\t};\n\t\t\tvar backgroundPoint = {\n\t\t\t\tx: existingModel.x,\n\t\t\t\ty: existingModel.y\n\t\t\t};\n\t\t\tvar tooltipSize = {\n\t\t\t\twidth: existingModel.width,\n\t\t\t\theight: existingModel.height\n\t\t\t};\n\t\t\tvar tooltipPosition = {\n\t\t\t\tx: existingModel.caretX,\n\t\t\t\ty: existingModel.caretY\n\t\t\t};\n\n\t\t\tvar i, len;\n\n\t\t\tif (active.length) {\n\t\t\t\tmodel.opacity = 1;\n\n\t\t\t\tvar labelColors = [];\n\t\t\t\tvar labelTextColors = [];\n\t\t\t\ttooltipPosition = Chart.Tooltip.positioners[opts.position].call(me, active, me._eventPosition);\n\n\t\t\t\tvar tooltipItems = [];\n\t\t\t\tfor (i = 0, len = active.length; i < len; ++i) {\n\t\t\t\t\ttooltipItems.push(createTooltipItem(active[i]));\n\t\t\t\t}\n\n\t\t\t\t// If the user provided a filter function, use it to modify the tooltip items\n\t\t\t\tif (opts.filter) {\n\t\t\t\t\ttooltipItems = tooltipItems.filter(function(a) {\n\t\t\t\t\t\treturn opts.filter(a, data);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// If the user provided a sorting function, use it to modify the tooltip items\n\t\t\t\tif (opts.itemSort) {\n\t\t\t\t\ttooltipItems = tooltipItems.sort(function(a, b) {\n\t\t\t\t\t\treturn opts.itemSort(a, b, data);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Determine colors for boxes\n\t\t\t\thelpers.each(tooltipItems, function(tooltipItem) {\n\t\t\t\t\tlabelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));\n\t\t\t\t\tlabelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));\n\t\t\t\t});\n\n\n\t\t\t\t// Build the Text Lines\n\t\t\t\tmodel.title = me.getTitle(tooltipItems, data);\n\t\t\t\tmodel.beforeBody = me.getBeforeBody(tooltipItems, data);\n\t\t\t\tmodel.body = me.getBody(tooltipItems, data);\n\t\t\t\tmodel.afterBody = me.getAfterBody(tooltipItems, data);\n\t\t\t\tmodel.footer = me.getFooter(tooltipItems, data);\n\n\t\t\t\t// Initial positioning and colors\n\t\t\t\tmodel.x = Math.round(tooltipPosition.x);\n\t\t\t\tmodel.y = Math.round(tooltipPosition.y);\n\t\t\t\tmodel.caretPadding = opts.caretPadding;\n\t\t\t\tmodel.labelColors = labelColors;\n\t\t\t\tmodel.labelTextColors = labelTextColors;\n\n\t\t\t\t// data points\n\t\t\t\tmodel.dataPoints = tooltipItems;\n\n\t\t\t\t// We need to determine alignment of the tooltip\n\t\t\t\ttooltipSize = getTooltipSize(this, model);\n\t\t\t\talignment = determineAlignment(this, tooltipSize);\n\t\t\t\t// Final Size and Position\n\t\t\t\tbackgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);\n\t\t\t} else {\n\t\t\t\tmodel.opacity = 0;\n\t\t\t}\n\n\t\t\tmodel.xAlign = alignment.xAlign;\n\t\t\tmodel.yAlign = alignment.yAlign;\n\t\t\tmodel.x = backgroundPoint.x;\n\t\t\tmodel.y = backgroundPoint.y;\n\t\t\tmodel.width = tooltipSize.width;\n\t\t\tmodel.height = tooltipSize.height;\n\n\t\t\t// Point where the caret on the tooltip points to\n\t\t\tmodel.caretX = tooltipPosition.x;\n\t\t\tmodel.caretY = tooltipPosition.y;\n\n\t\t\tme._model = model;\n\n\t\t\tif (changed && opts.custom) {\n\t\t\t\topts.custom.call(me, model);\n\t\t\t}\n\n\t\t\treturn me;\n\t\t},\n\t\tdrawCaret: function(tooltipPoint, size) {\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar vm = this._view;\n\t\t\tvar caretPosition = this.getCaretPosition(tooltipPoint, size, vm);\n\n\t\t\tctx.lineTo(caretPosition.x1, caretPosition.y1);\n\t\t\tctx.lineTo(caretPosition.x2, caretPosition.y2);\n\t\t\tctx.lineTo(caretPosition.x3, caretPosition.y3);\n\t\t},\n\t\tgetCaretPosition: function(tooltipPoint, size, vm) {\n\t\t\tvar x1, x2, x3, y1, y2, y3;\n\t\t\tvar caretSize = vm.caretSize;\n\t\t\tvar cornerRadius = vm.cornerRadius;\n\t\t\tvar xAlign = vm.xAlign;\n\t\t\tvar yAlign = vm.yAlign;\n\t\t\tvar ptX = tooltipPoint.x;\n\t\t\tvar ptY = tooltipPoint.y;\n\t\t\tvar width = size.width;\n\t\t\tvar height = size.height;\n\n\t\t\tif (yAlign === 'center') {\n\t\t\t\ty2 = ptY + (height / 2);\n\n\t\t\t\tif (xAlign === 'left') {\n\t\t\t\t\tx1 = ptX;\n\t\t\t\t\tx2 = x1 - caretSize;\n\t\t\t\t\tx3 = x1;\n\n\t\t\t\t\ty1 = y2 + caretSize;\n\t\t\t\t\ty3 = y2 - caretSize;\n\t\t\t\t} else {\n\t\t\t\t\tx1 = ptX + width;\n\t\t\t\t\tx2 = x1 + caretSize;\n\t\t\t\t\tx3 = x1;\n\n\t\t\t\t\ty1 = y2 - caretSize;\n\t\t\t\t\ty3 = y2 + caretSize;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (xAlign === 'left') {\n\t\t\t\t\tx2 = ptX + cornerRadius + (caretSize);\n\t\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t} else if (xAlign === 'right') {\n\t\t\t\t\tx2 = ptX + width - cornerRadius - caretSize;\n\t\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t} else {\n\t\t\t\t\tx2 = vm.caretX;\n\t\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t}\n\t\t\t\tif (yAlign === 'top') {\n\t\t\t\t\ty1 = ptY;\n\t\t\t\t\ty2 = y1 - caretSize;\n\t\t\t\t\ty3 = y1;\n\t\t\t\t} else {\n\t\t\t\t\ty1 = ptY + height;\n\t\t\t\t\ty2 = y1 + caretSize;\n\t\t\t\t\ty3 = y1;\n\t\t\t\t\t// invert drawing order\n\t\t\t\t\tvar tmp = x3;\n\t\t\t\t\tx3 = x1;\n\t\t\t\t\tx1 = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3};\n\t\t},\n\t\tdrawTitle: function(pt, vm, ctx, opacity) {\n\t\t\tvar title = vm.title;\n\n\t\t\tif (title.length) {\n\t\t\t\tctx.textAlign = vm._titleAlign;\n\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\tvar titleFontSize = vm.titleFontSize;\n\t\t\t\tvar titleSpacing = vm.titleSpacing;\n\n\t\t\t\tctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);\n\t\t\t\tctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);\n\n\t\t\t\tvar i, len;\n\t\t\t\tfor (i = 0, len = title.length; i < len; ++i) {\n\t\t\t\t\tctx.fillText(title[i], pt.x, pt.y);\n\t\t\t\t\tpt.y += titleFontSize + titleSpacing; // Line Height and spacing\n\n\t\t\t\t\tif (i + 1 === title.length) {\n\t\t\t\t\t\tpt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tdrawBody: function(pt, vm, ctx, opacity) {\n\t\t\tvar bodyFontSize = vm.bodyFontSize;\n\t\t\tvar bodySpacing = vm.bodySpacing;\n\t\t\tvar body = vm.body;\n\n\t\t\tctx.textAlign = vm._bodyAlign;\n\t\t\tctx.textBaseline = 'top';\n\t\t\tctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);\n\n\t\t\t// Before Body\n\t\t\tvar xLinePadding = 0;\n\t\t\tvar fillLineOfText = function(line) {\n\t\t\t\tctx.fillText(line, pt.x + xLinePadding, pt.y);\n\t\t\t\tpt.y += bodyFontSize + bodySpacing;\n\t\t\t};\n\n\t\t\t// Before body lines\n\t\t\tctx.fillStyle = mergeOpacity(vm.bodyFontColor, opacity);\n\t\t\thelpers.each(vm.beforeBody, fillLineOfText);\n\n\t\t\tvar drawColorBoxes = vm.displayColors;\n\t\t\txLinePadding = drawColorBoxes ? (bodyFontSize + 2) : 0;\n\n\t\t\t// Draw body lines now\n\t\t\thelpers.each(body, function(bodyItem, i) {\n\t\t\t\tvar textColor = mergeOpacity(vm.labelTextColors[i], opacity);\n\t\t\t\tctx.fillStyle = textColor;\n\t\t\t\thelpers.each(bodyItem.before, fillLineOfText);\n\n\t\t\t\thelpers.each(bodyItem.lines, function(line) {\n\t\t\t\t\t// Draw Legend-like boxes if needed\n\t\t\t\t\tif (drawColorBoxes) {\n\t\t\t\t\t\t// Fill a white rect so that colours merge nicely if the opacity is < 1\n\t\t\t\t\t\tctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);\n\t\t\t\t\t\tctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\n\n\t\t\t\t\t\t// Border\n\t\t\t\t\t\tctx.lineWidth = 1;\n\t\t\t\t\t\tctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);\n\t\t\t\t\t\tctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\n\n\t\t\t\t\t\t// Inner square\n\t\t\t\t\t\tctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);\n\t\t\t\t\t\tctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\n\t\t\t\t\t\tctx.fillStyle = textColor;\n\t\t\t\t\t}\n\n\t\t\t\t\tfillLineOfText(line);\n\t\t\t\t});\n\n\t\t\t\thelpers.each(bodyItem.after, fillLineOfText);\n\t\t\t});\n\n\t\t\t// Reset back to 0 for after body\n\t\t\txLinePadding = 0;\n\n\t\t\t// After body lines\n\t\t\thelpers.each(vm.afterBody, fillLineOfText);\n\t\t\tpt.y -= bodySpacing; // Remove last body spacing\n\t\t},\n\t\tdrawFooter: function(pt, vm, ctx, opacity) {\n\t\t\tvar footer = vm.footer;\n\n\t\t\tif (footer.length) {\n\t\t\t\tpt.y += vm.footerMarginTop;\n\n\t\t\t\tctx.textAlign = vm._footerAlign;\n\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\tctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);\n\t\t\t\tctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);\n\n\t\t\t\thelpers.each(footer, function(line) {\n\t\t\t\t\tctx.fillText(line, pt.x, pt.y);\n\t\t\t\t\tpt.y += vm.footerFontSize + vm.footerSpacing;\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\tdrawBackground: function(pt, vm, ctx, tooltipSize, opacity) {\n\t\t\tctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);\n\t\t\tctx.strokeStyle = mergeOpacity(vm.borderColor, opacity);\n\t\t\tctx.lineWidth = vm.borderWidth;\n\t\t\tvar xAlign = vm.xAlign;\n\t\t\tvar yAlign = vm.yAlign;\n\t\t\tvar x = pt.x;\n\t\t\tvar y = pt.y;\n\t\t\tvar width = tooltipSize.width;\n\t\t\tvar height = tooltipSize.height;\n\t\t\tvar radius = vm.cornerRadius;\n\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x + radius, y);\n\t\t\tif (yAlign === 'top') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x + width - radius, y);\n\t\t\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n\t\t\tif (yAlign === 'center' && xAlign === 'right') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x + width, y + height - radius);\n\t\t\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n\t\t\tif (yAlign === 'bottom') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x + radius, y + height);\n\t\t\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n\t\t\tif (yAlign === 'center' && xAlign === 'left') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x, y + radius);\n\t\t\tctx.quadraticCurveTo(x, y, x + radius, y);\n\t\t\tctx.closePath();\n\n\t\t\tctx.fill();\n\n\t\t\tif (vm.borderWidth > 0) {\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t},\n\t\tdraw: function() {\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar vm = this._view;\n\n\t\t\tif (vm.opacity === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar tooltipSize = {\n\t\t\t\twidth: vm.width,\n\t\t\t\theight: vm.height\n\t\t\t};\n\t\t\tvar pt = {\n\t\t\t\tx: vm.x,\n\t\t\t\ty: vm.y\n\t\t\t};\n\n\t\t\t// IE11/Edge does not like very small opacities, so snap to 0\n\t\t\tvar opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;\n\n\t\t\t// Truthy/falsey value for empty tooltip\n\t\t\tvar hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;\n\n\t\t\tif (this._options.enabled && hasTooltipContent) {\n\t\t\t\t// Draw Background\n\t\t\t\tthis.drawBackground(pt, vm, ctx, tooltipSize, opacity);\n\n\t\t\t\t// Draw Title, Body, and Footer\n\t\t\t\tpt.x += vm.xPadding;\n\t\t\t\tpt.y += vm.yPadding;\n\n\t\t\t\t// Titles\n\t\t\t\tthis.drawTitle(pt, vm, ctx, opacity);\n\n\t\t\t\t// Body\n\t\t\t\tthis.drawBody(pt, vm, ctx, opacity);\n\n\t\t\t\t// Footer\n\t\t\t\tthis.drawFooter(pt, vm, ctx, opacity);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Handle an event\n\t\t * @private\n\t\t * @param {IEvent} event - The event to handle\n\t\t * @returns {Boolean} true if the tooltip changed\n\t\t */\n\t\thandleEvent: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar options = me._options;\n\t\t\tvar changed = false;\n\n\t\t\tme._lastActive = me._lastActive || [];\n\n\t\t\t// Find Active Elements for tooltips\n\t\t\tif (e.type === 'mouseout') {\n\t\t\t\tme._active = [];\n\t\t\t} else {\n\t\t\t\tme._active = me._chart.getElementsAtEventForMode(e, options.mode, options);\n\t\t\t}\n\n\t\t\t// Remember Last Actives\n\t\t\tchanged = !helpers.arrayEquals(me._active, me._lastActive);\n\n\t\t\t// Only handle target event on tooltip change\n\t\t\tif (changed) {\n\t\t\t\tme._lastActive = me._active;\n\n\t\t\t\tif (options.enabled || options.custom) {\n\t\t\t\t\tme._eventPosition = {\n\t\t\t\t\t\tx: e.x,\n\t\t\t\t\t\ty: e.y\n\t\t\t\t\t};\n\n\t\t\t\t\tme.update(true);\n\t\t\t\t\tme.pivot();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn changed;\n\t\t}\n\t});\n\n\t/**\n\t * @namespace Chart.Tooltip.positioners\n\t */\n\tChart.Tooltip.positioners = {\n\t\t/**\n\t\t * Average mode places the tooltip at the average position of the elements shown\n\t\t * @function Chart.Tooltip.positioners.average\n\t\t * @param elements {ChartElement[]} the elements being displayed in the tooltip\n\t\t * @returns {Point} tooltip position\n\t\t */\n\t\taverage: function(elements) {\n\t\t\tif (!elements.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar i, len;\n\t\t\tvar x = 0;\n\t\t\tvar y = 0;\n\t\t\tvar count = 0;\n\n\t\t\tfor (i = 0, len = elements.length; i < len; ++i) {\n\t\t\t\tvar el = elements[i];\n\t\t\t\tif (el && el.hasValue()) {\n\t\t\t\t\tvar pos = el.tooltipPosition();\n\t\t\t\t\tx += pos.x;\n\t\t\t\t\ty += pos.y;\n\t\t\t\t\t++count;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: Math.round(x / count),\n\t\t\t\ty: Math.round(y / count)\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Gets the tooltip position nearest of the item nearest to the event position\n\t\t * @function Chart.Tooltip.positioners.nearest\n\t\t * @param elements {Chart.Element[]} the tooltip elements\n\t\t * @param eventPosition {Point} the position of the event in canvas coordinates\n\t\t * @returns {Point} the tooltip position\n\t\t */\n\t\tnearest: function(elements, eventPosition) {\n\t\t\tvar x = eventPosition.x;\n\t\t\tvar y = eventPosition.y;\n\t\t\tvar minDistance = Number.POSITIVE_INFINITY;\n\t\t\tvar i, len, nearestElement;\n\n\t\t\tfor (i = 0, len = elements.length; i < len; ++i) {\n\t\t\t\tvar el = elements[i];\n\t\t\t\tif (el && el.hasValue()) {\n\t\t\t\t\tvar center = el.getCenterPoint();\n\t\t\t\t\tvar d = helpers.distanceBetweenPoints(eventPosition, center);\n\n\t\t\t\t\tif (d < minDistance) {\n\t\t\t\t\t\tminDistance = d;\n\t\t\t\t\t\tnearestElement = el;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nearestElement) {\n\t\t\t\tvar tp = nearestElement.tooltipPosition();\n\t\t\t\tx = tp.x;\n\t\t\t\ty = tp.y;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: x,\n\t\t\t\ty: y\n\t\t\t};\n\t\t}\n\t};\n};\n\n},{\"../helpers/index\":53,\"./core.defaults\":33,\"./core.element\":34}],44:[function(require,module,exports){\n'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar Element = require('../core/core.element');\nvar helpers = require('../helpers/index');\n\ndefaults._set('global', {\n\telements: {\n\t\tarc: {\n\t\t\tbackgroundColor: defaults.global.defaultColor,\n\t\t\tborderColor: '#fff',\n\t\t\tborderWidth: 2\n\t\t}\n\t}\n});\n\nmodule.exports = Element.extend({\n\tinLabelRange: function(mouseX) {\n\t\tvar vm = this._view;\n\n\t\tif (vm) {\n\t\t\treturn (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));\n\t\t}\n\t\treturn false;\n\t},\n\n\tinRange: function(chartX, chartY) {\n\t\tvar vm = this._view;\n\n\t\tif (vm) {\n\t\t\tvar pointRelativePosition = helpers.getAngleFromPoint(vm, {x: chartX, y: chartY});\n\t\t\tvar\tangle = pointRelativePosition.angle;\n\t\t\tvar distance = pointRelativePosition.distance;\n\n\t\t\t// Sanitise angle range\n\t\t\tvar startAngle = vm.startAngle;\n\t\t\tvar endAngle = vm.endAngle;\n\t\t\twhile (endAngle < startAngle) {\n\t\t\t\tendAngle += 2.0 * Math.PI;\n\t\t\t}\n\t\t\twhile (angle > endAngle) {\n\t\t\t\tangle -= 2.0 * Math.PI;\n\t\t\t}\n\t\t\twhile (angle < startAngle) {\n\t\t\t\tangle += 2.0 * Math.PI;\n\t\t\t}\n\n\t\t\t// Check if within the range of the open/close angle\n\t\t\tvar betweenAngles = (angle >= startAngle && angle <= endAngle);\n\t\t\tvar withinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);\n\n\t\t\treturn (betweenAngles && withinRadius);\n\t\t}\n\t\treturn false;\n\t},\n\n\tgetCenterPoint: function() {\n\t\tvar vm = this._view;\n\t\tvar halfAngle = (vm.startAngle + vm.endAngle) / 2;\n\t\tvar halfRadius = (vm.innerRadius + vm.outerRadius) / 2;\n\t\treturn {\n\t\t\tx: vm.x + Math.cos(halfAngle) * halfRadius,\n\t\t\ty: vm.y + Math.sin(halfAngle) * halfRadius\n\t\t};\n\t},\n\n\tgetArea: function() {\n\t\tvar vm = this._view;\n\t\treturn Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));\n\t},\n\n\ttooltipPosition: function() {\n\t\tvar vm = this._view;\n\t\tvar centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2);\n\t\tvar rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;\n\n\t\treturn {\n\t\t\tx: vm.x + (Math.cos(centreAngle) * rangeFromCentre),\n\t\t\ty: vm.y + (Math.sin(centreAngle) * rangeFromCentre)\n\t\t};\n\t},\n\n\tdraw: function() {\n\t\tvar ctx = this._chart.ctx;\n\t\tvar vm = this._view;\n\t\tvar sA = vm.startAngle;\n\t\tvar eA = vm.endAngle;\n\n\t\tctx.beginPath();\n\n\t\tctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);\n\t\tctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);\n\n\t\tctx.closePath();\n\t\tctx.strokeStyle = vm.borderColor;\n\t\tctx.lineWidth = vm.borderWidth;\n\n\t\tctx.fillStyle = vm.backgroundColor;\n\n\t\tctx.fill();\n\t\tctx.lineJoin = 'bevel';\n\n\t\tif (vm.borderWidth) {\n\t\t\tctx.stroke();\n\t\t}\n\t}\n});\n\n},{\"../core/core.defaults\":33,\"../core/core.element\":34,\"../helpers/index\":53}],45:[function(require,module,exports){\n'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar Element = require('../core/core.element');\nvar helpers = require('../helpers/index');\n\nvar globalDefaults = defaults.global;\n\ndefaults._set('global', {\n\telements: {\n\t\tline: {\n\t\t\ttension: 0.4,\n\t\t\tbackgroundColor: globalDefaults.defaultColor,\n\t\t\tborderWidth: 3,\n\t\t\tborderColor: globalDefaults.defaultColor,\n\t\t\tborderCapStyle: 'butt',\n\t\t\tborderDash: [],\n\t\t\tborderDashOffset: 0.0,\n\t\t\tborderJoinStyle: 'miter',\n\t\t\tcapBezierPoints: true,\n\t\t\tfill: true, // do we fill in the area between the line and its base axis\n\t\t}\n\t}\n});\n\nmodule.exports = Element.extend({\n\tdraw: function() {\n\t\tvar me = this;\n\t\tvar vm = me._view;\n\t\tvar ctx = me._chart.ctx;\n\t\tvar spanGaps = vm.spanGaps;\n\t\tvar points = me._children.slice(); // clone array\n\t\tvar globalOptionLineElements = globalDefaults.elements.line;\n\t\tvar lastDrawnIndex = -1;\n\t\tvar index, current, previous, currentVM;\n\n\t\t// If we are looping, adding the first point again\n\t\tif (me._loop && points.length) {\n\t\t\tpoints.push(points[0]);\n\t\t}\n\n\t\tctx.save();\n\n\t\t// Stroke Line Options\n\t\tctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;\n\n\t\t// IE 9 and 10 do not support line dash\n\t\tif (ctx.setLineDash) {\n\t\t\tctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\n\t\t}\n\n\t\tctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;\n\t\tctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\n\t\tctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;\n\t\tctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;\n\n\t\t// Stroke Line\n\t\tctx.beginPath();\n\t\tlastDrawnIndex = -1;\n\n\t\tfor (index = 0; index < points.length; ++index) {\n\t\t\tcurrent = points[index];\n\t\t\tprevious = helpers.previousItem(points, index);\n\t\t\tcurrentVM = current._view;\n\n\t\t\t// First point moves to it's starting position no matter what\n\t\t\tif (index === 0) {\n\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprevious = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n\n\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\tif ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {\n\t\t\t\t\t\t// There was a gap and this is the first point after the gap\n\t\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Line to next point\n\t\t\t\t\t\thelpers.canvas.lineTo(ctx, previous._view, current._view);\n\t\t\t\t\t}\n\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tctx.stroke();\n\t\tctx.restore();\n\t}\n});\n\n},{\"../core/core.defaults\":33,\"../core/core.element\":34,\"../helpers/index\":53}],46:[function(require,module,exports){\n'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar Element = require('../core/core.element');\nvar helpers = require('../helpers/index');\n\nvar defaultColor = defaults.global.defaultColor;\n\ndefaults._set('global', {\n\telements: {\n\t\tpoint: {\n\t\t\tradius: 3,\n\t\t\tpointStyle: 'circle',\n\t\t\tbackgroundColor: defaultColor,\n\t\t\tborderColor: defaultColor,\n\t\t\tborderWidth: 1,\n\t\t\t// Hover\n\t\t\thitRadius: 1,\n\t\t\thoverRadius: 4,\n\t\t\thoverBorderWidth: 1\n\t\t}\n\t}\n});\n\nfunction xRange(mouseX) {\n\tvar vm = this._view;\n\treturn vm ? (Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius) : false;\n}\n\nfunction yRange(mouseY) {\n\tvar vm = this._view;\n\treturn vm ? (Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius) : false;\n}\n\nmodule.exports = Element.extend({\n\tinRange: function(mouseX, mouseY) {\n\t\tvar vm = this._view;\n\t\treturn vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;\n\t},\n\n\tinLabelRange: xRange,\n\tinXRange: xRange,\n\tinYRange: yRange,\n\n\tgetCenterPoint: function() {\n\t\tvar vm = this._view;\n\t\treturn {\n\t\t\tx: vm.x,\n\t\t\ty: vm.y\n\t\t};\n\t},\n\n\tgetArea: function() {\n\t\treturn Math.PI * Math.pow(this._view.radius, 2);\n\t},\n\n\ttooltipPosition: function() {\n\t\tvar vm = this._view;\n\t\treturn {\n\t\t\tx: vm.x,\n\t\t\ty: vm.y,\n\t\t\tpadding: vm.radius + vm.borderWidth\n\t\t};\n\t},\n\n\tdraw: function(chartArea) {\n\t\tvar vm = this._view;\n\t\tvar model = this._model;\n\t\tvar ctx = this._chart.ctx;\n\t\tvar pointStyle = vm.pointStyle;\n\t\tvar radius = vm.radius;\n\t\tvar x = vm.x;\n\t\tvar y = vm.y;\n\t\tvar color = helpers.color;\n\t\tvar errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)\n\t\tvar ratio = 0;\n\n\t\tif (vm.skip) {\n\t\t\treturn;\n\t\t}\n\n\t\tctx.strokeStyle = vm.borderColor || defaultColor;\n\t\tctx.lineWidth = helpers.valueOrDefault(vm.borderWidth, defaults.global.elements.point.borderWidth);\n\t\tctx.fillStyle = vm.backgroundColor || defaultColor;\n\n\t\t// Cliping for Points.\n\t\t// going out from inner charArea?\n\t\tif ((chartArea !== undefined) && ((model.x < chartArea.left) || (chartArea.right * errMargin < model.x) || (model.y < chartArea.top) || (chartArea.bottom * errMargin < model.y))) {\n\t\t\t// Point fade out\n\t\t\tif (model.x < chartArea.left) {\n\t\t\t\tratio = (x - model.x) / (chartArea.left - model.x);\n\t\t\t} else if (chartArea.right * errMargin < model.x) {\n\t\t\t\tratio = (model.x - x) / (model.x - chartArea.right);\n\t\t\t} else if (model.y < chartArea.top) {\n\t\t\t\tratio = (y - model.y) / (chartArea.top - model.y);\n\t\t\t} else if (chartArea.bottom * errMargin < model.y) {\n\t\t\t\tratio = (model.y - y) / (model.y - chartArea.bottom);\n\t\t\t}\n\t\t\tratio = Math.round(ratio * 100) / 100;\n\t\t\tctx.strokeStyle = color(ctx.strokeStyle).alpha(ratio).rgbString();\n\t\t\tctx.fillStyle = color(ctx.fillStyle).alpha(ratio).rgbString();\n\t\t}\n\n\t\thelpers.canvas.drawPoint(ctx, pointStyle, radius, x, y);\n\t}\n});\n\n},{\"../core/core.defaults\":33,\"../core/core.element\":34,\"../helpers/index\":53}],47:[function(require,module,exports){\n'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar Element = require('../core/core.element');\n\ndefaults._set('global', {\n\telements: {\n\t\trectangle: {\n\t\t\tbackgroundColor: defaults.global.defaultColor,\n\t\t\tborderColor: defaults.global.defaultColor,\n\t\t\tborderSkipped: 'bottom',\n\t\t\tborderWidth: 0\n\t\t}\n\t}\n});\n\nfunction isVertical(bar) {\n\treturn bar._view.width !== undefined;\n}\n\n/**\n * Helper function to get the bounds of the bar regardless of the orientation\n * @param bar {Chart.Element.Rectangle} the bar\n * @return {Bounds} bounds of the bar\n * @private\n */\nfunction getBarBounds(bar) {\n\tvar vm = bar._view;\n\tvar x1, x2, y1, y2;\n\n\tif (isVertical(bar)) {\n\t\t// vertical\n\t\tvar halfWidth = vm.width / 2;\n\t\tx1 = vm.x - halfWidth;\n\t\tx2 = vm.x + halfWidth;\n\t\ty1 = Math.min(vm.y, vm.base);\n\t\ty2 = Math.max(vm.y, vm.base);\n\t} else {\n\t\t// horizontal bar\n\t\tvar halfHeight = vm.height / 2;\n\t\tx1 = Math.min(vm.x, vm.base);\n\t\tx2 = Math.max(vm.x, vm.base);\n\t\ty1 = vm.y - halfHeight;\n\t\ty2 = vm.y + halfHeight;\n\t}\n\n\treturn {\n\t\tleft: x1,\n\t\ttop: y1,\n\t\tright: x2,\n\t\tbottom: y2\n\t};\n}\n\nmodule.exports = Element.extend({\n\tdraw: function() {\n\t\tvar ctx = this._chart.ctx;\n\t\tvar vm = this._view;\n\t\tvar left, right, top, bottom, signX, signY, borderSkipped;\n\t\tvar borderWidth = vm.borderWidth;\n\n\t\tif (!vm.horizontal) {\n\t\t\t// bar\n\t\t\tleft = vm.x - vm.width / 2;\n\t\t\tright = vm.x + vm.width / 2;\n\t\t\ttop = vm.y;\n\t\t\tbottom = vm.base;\n\t\t\tsignX = 1;\n\t\t\tsignY = bottom > top ? 1 : -1;\n\t\t\tborderSkipped = vm.borderSkipped || 'bottom';\n\t\t} else {\n\t\t\t// horizontal bar\n\t\t\tleft = vm.base;\n\t\t\tright = vm.x;\n\t\t\ttop = vm.y - vm.height / 2;\n\t\t\tbottom = vm.y + vm.height / 2;\n\t\t\tsignX = right > left ? 1 : -1;\n\t\t\tsignY = 1;\n\t\t\tborderSkipped = vm.borderSkipped || 'left';\n\t\t}\n\n\t\t// Canvas doesn't allow us to stroke inside the width so we can\n\t\t// adjust the sizes to fit if we're setting a stroke on the line\n\t\tif (borderWidth) {\n\t\t\t// borderWidth shold be less than bar width and bar height.\n\t\t\tvar barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));\n\t\t\tborderWidth = borderWidth > barSize ? barSize : borderWidth;\n\t\t\tvar halfStroke = borderWidth / 2;\n\t\t\t// Adjust borderWidth when bar top position is near vm.base(zero).\n\t\t\tvar borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);\n\t\t\tvar borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);\n\t\t\tvar borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);\n\t\t\tvar borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0);\n\t\t\t// not become a vertical line?\n\t\t\tif (borderLeft !== borderRight) {\n\t\t\t\ttop = borderTop;\n\t\t\t\tbottom = borderBottom;\n\t\t\t}\n\t\t\t// not become a horizontal line?\n\t\t\tif (borderTop !== borderBottom) {\n\t\t\t\tleft = borderLeft;\n\t\t\t\tright = borderRight;\n\t\t\t}\n\t\t}\n\n\t\tctx.beginPath();\n\t\tctx.fillStyle = vm.backgroundColor;\n\t\tctx.strokeStyle = vm.borderColor;\n\t\tctx.lineWidth = borderWidth;\n\n\t\t// Corner points, from bottom-left to bottom-right clockwise\n\t\t// | 1 2 |\n\t\t// | 0 3 |\n\t\tvar corners = [\n\t\t\t[left, bottom],\n\t\t\t[left, top],\n\t\t\t[right, top],\n\t\t\t[right, bottom]\n\t\t];\n\n\t\t// Find first (starting) corner with fallback to 'bottom'\n\t\tvar borders = ['bottom', 'left', 'top', 'right'];\n\t\tvar startCorner = borders.indexOf(borderSkipped, 0);\n\t\tif (startCorner === -1) {\n\t\t\tstartCorner = 0;\n\t\t}\n\n\t\tfunction cornerAt(index) {\n\t\t\treturn corners[(startCorner + index) % 4];\n\t\t}\n\n\t\t// Draw rectangle from 'startCorner'\n\t\tvar corner = cornerAt(0);\n\t\tctx.moveTo(corner[0], corner[1]);\n\n\t\tfor (var i = 1; i < 4; i++) {\n\t\t\tcorner = cornerAt(i);\n\t\t\tctx.lineTo(corner[0], corner[1]);\n\t\t}\n\n\t\tctx.fill();\n\t\tif (borderWidth) {\n\t\t\tctx.stroke();\n\t\t}\n\t},\n\n\theight: function() {\n\t\tvar vm = this._view;\n\t\treturn vm.base - vm.y;\n\t},\n\n\tinRange: function(mouseX, mouseY) {\n\t\tvar inRange = false;\n\n\t\tif (this._view) {\n\t\t\tvar bounds = getBarBounds(this);\n\t\t\tinRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t}\n\n\t\treturn inRange;\n\t},\n\n\tinLabelRange: function(mouseX, mouseY) {\n\t\tvar me = this;\n\t\tif (!me._view) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar inRange = false;\n\t\tvar bounds = getBarBounds(me);\n\n\t\tif (isVertical(me)) {\n\t\t\tinRange = mouseX >= bounds.left && mouseX <= bounds.right;\n\t\t} else {\n\t\t\tinRange = mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t}\n\n\t\treturn inRange;\n\t},\n\n\tinXRange: function(mouseX) {\n\t\tvar bounds = getBarBounds(this);\n\t\treturn mouseX >= bounds.left && mouseX <= bounds.right;\n\t},\n\n\tinYRange: function(mouseY) {\n\t\tvar bounds = getBarBounds(this);\n\t\treturn mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t},\n\n\tgetCenterPoint: function() {\n\t\tvar vm = this._view;\n\t\tvar x, y;\n\t\tif (isVertical(this)) {\n\t\t\tx = vm.x;\n\t\t\ty = (vm.y + vm.base) / 2;\n\t\t} else {\n\t\t\tx = (vm.x + vm.base) / 2;\n\t\t\ty = vm.y;\n\t\t}\n\n\t\treturn {x: x, y: y};\n\t},\n\n\tgetArea: function() {\n\t\tvar vm = this._view;\n\t\treturn vm.width * Math.abs(vm.y - vm.base);\n\t},\n\n\ttooltipPosition: function() {\n\t\tvar vm = this._view;\n\t\treturn {\n\t\t\tx: vm.x,\n\t\t\ty: vm.y\n\t\t};\n\t}\n});\n\n},{\"../core/core.defaults\":33,\"../core/core.element\":34}],48:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {};\nmodule.exports.Arc = require('./element.arc');\nmodule.exports.Line = require('./element.line');\nmodule.exports.Point = require('./element.point');\nmodule.exports.Rectangle = require('./element.rectangle');\n\n},{\"./element.arc\":44,\"./element.line\":45,\"./element.point\":46,\"./element.rectangle\":47}],49:[function(require,module,exports){\n'use strict';\n\nvar helpers = require('./helpers.core');\n\n/**\n * @namespace Chart.helpers.canvas\n */\nvar exports = module.exports = {\n\t/**\n\t * Clears the entire canvas associated to the given `chart`.\n\t * @param {Chart} chart - The chart for which to clear the canvas.\n\t */\n\tclear: function(chart) {\n\t\tchart.ctx.clearRect(0, 0, chart.width, chart.height);\n\t},\n\n\t/**\n\t * Creates a \"path\" for a rectangle with rounded corners at position (x, y) with a\n\t * given size (width, height) and the same `radius` for all corners.\n\t * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.\n\t * @param {Number} x - The x axis of the coordinate for the rectangle starting point.\n\t * @param {Number} y - The y axis of the coordinate for the rectangle starting point.\n\t * @param {Number} width - The rectangle's width.\n\t * @param {Number} height - The rectangle's height.\n\t * @param {Number} radius - The rounded amount (in pixels) for the four corners.\n\t * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?\n\t */\n\troundedRect: function(ctx, x, y, width, height, radius) {\n\t\tif (radius) {\n\t\t\tvar rx = Math.min(radius, width / 2);\n\t\t\tvar ry = Math.min(radius, height / 2);\n\n\t\t\tctx.moveTo(x + rx, y);\n\t\t\tctx.lineTo(x + width - rx, y);\n\t\t\tctx.quadraticCurveTo(x + width, y, x + width, y + ry);\n\t\t\tctx.lineTo(x + width, y + height - ry);\n\t\t\tctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height);\n\t\t\tctx.lineTo(x + rx, y + height);\n\t\t\tctx.quadraticCurveTo(x, y + height, x, y + height - ry);\n\t\t\tctx.lineTo(x, y + ry);\n\t\t\tctx.quadraticCurveTo(x, y, x + rx, y);\n\t\t} else {\n\t\t\tctx.rect(x, y, width, height);\n\t\t}\n\t},\n\n\tdrawPoint: function(ctx, style, radius, x, y) {\n\t\tvar type, edgeLength, xOffset, yOffset, height, size;\n\n\t\tif (style && typeof style === 'object') {\n\t\t\ttype = style.toString();\n\t\t\tif (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n\t\t\t\tctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (isNaN(radius) || radius <= 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (style) {\n\t\t// Default includes circle\n\t\tdefault:\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(x, y, radius, 0, Math.PI * 2);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'triangle':\n\t\t\tctx.beginPath();\n\t\t\tedgeLength = 3 * radius / Math.sqrt(3);\n\t\t\theight = edgeLength * Math.sqrt(3) / 2;\n\t\t\tctx.moveTo(x - edgeLength / 2, y + height / 3);\n\t\t\tctx.lineTo(x + edgeLength / 2, y + height / 3);\n\t\t\tctx.lineTo(x, y - 2 * height / 3);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'rect':\n\t\t\tsize = 1 / Math.SQRT2 * radius;\n\t\t\tctx.beginPath();\n\t\t\tctx.fillRect(x - size, y - size, 2 * size, 2 * size);\n\t\t\tctx.strokeRect(x - size, y - size, 2 * size, 2 * size);\n\t\t\tbreak;\n\t\tcase 'rectRounded':\n\t\t\tvar offset = radius / Math.SQRT2;\n\t\t\tvar leftX = x - offset;\n\t\t\tvar topY = y - offset;\n\t\t\tvar sideSize = Math.SQRT2 * radius;\n\t\t\tctx.beginPath();\n\t\t\tthis.roundedRect(ctx, leftX, topY, sideSize, sideSize, radius / 2);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'rectRot':\n\t\t\tsize = 1 / Math.SQRT2 * radius;\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x - size, y);\n\t\t\tctx.lineTo(x, y + size);\n\t\t\tctx.lineTo(x + size, y);\n\t\t\tctx.lineTo(x, y - size);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'cross':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, y + radius);\n\t\t\tctx.lineTo(x, y - radius);\n\t\t\tctx.moveTo(x - radius, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'crossRot':\n\t\t\tctx.beginPath();\n\t\t\txOffset = Math.cos(Math.PI / 4) * radius;\n\t\t\tyOffset = Math.sin(Math.PI / 4) * radius;\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\tctx.moveTo(x - xOffset, y + yOffset);\n\t\t\tctx.lineTo(x + xOffset, y - yOffset);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'star':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, y + radius);\n\t\t\tctx.lineTo(x, y - radius);\n\t\t\tctx.moveTo(x - radius, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\txOffset = Math.cos(Math.PI / 4) * radius;\n\t\t\tyOffset = Math.sin(Math.PI / 4) * radius;\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\tctx.moveTo(x - xOffset, y + yOffset);\n\t\t\tctx.lineTo(x + xOffset, y - yOffset);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'line':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x - radius, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'dash':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\t}\n\n\t\tctx.stroke();\n\t},\n\n\tclipArea: function(ctx, area) {\n\t\tctx.save();\n\t\tctx.beginPath();\n\t\tctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n\t\tctx.clip();\n\t},\n\n\tunclipArea: function(ctx) {\n\t\tctx.restore();\n\t},\n\n\tlineTo: function(ctx, previous, target, flip) {\n\t\tif (target.steppedLine) {\n\t\t\tif ((target.steppedLine === 'after' && !flip) || (target.steppedLine !== 'after' && flip)) {\n\t\t\t\tctx.lineTo(previous.x, target.y);\n\t\t\t} else {\n\t\t\t\tctx.lineTo(target.x, previous.y);\n\t\t\t}\n\t\t\tctx.lineTo(target.x, target.y);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!target.tension) {\n\t\t\tctx.lineTo(target.x, target.y);\n\t\t\treturn;\n\t\t}\n\n\t\tctx.bezierCurveTo(\n\t\t\tflip ? previous.controlPointPreviousX : previous.controlPointNextX,\n\t\t\tflip ? previous.controlPointPreviousY : previous.controlPointNextY,\n\t\t\tflip ? target.controlPointNextX : target.controlPointPreviousX,\n\t\t\tflip ? target.controlPointNextY : target.controlPointPreviousY,\n\t\t\ttarget.x,\n\t\t\ttarget.y);\n\t}\n};\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.\n * @namespace Chart.helpers.clear\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.clear = exports.clear;\n\n/**\n * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.\n * @namespace Chart.helpers.drawRoundedRectangle\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.drawRoundedRectangle = function(ctx) {\n\tctx.beginPath();\n\texports.roundedRect.apply(exports, arguments);\n\tctx.closePath();\n};\n\n},{\"./helpers.core\":50}],50:[function(require,module,exports){\n'use strict';\n\n/**\n * @namespace Chart.helpers\n */\nvar helpers = {\n\t/**\n\t * An empty function that can be used, for example, for optional callback.\n\t */\n\tnoop: function() {},\n\n\t/**\n\t * Returns a unique id, sequentially generated from a global variable.\n\t * @returns {Number}\n\t * @function\n\t */\n\tuid: (function() {\n\t\tvar id = 0;\n\t\treturn function() {\n\t\t\treturn id++;\n\t\t};\n\t}()),\n\n\t/**\n\t * Returns true if `value` is neither null nor undefined, else returns false.\n\t * @param {*} value - The value to test.\n\t * @returns {Boolean}\n\t * @since 2.7.0\n\t */\n\tisNullOrUndef: function(value) {\n\t\treturn value === null || typeof value === 'undefined';\n\t},\n\n\t/**\n\t * Returns true if `value` is an array, else returns false.\n\t * @param {*} value - The value to test.\n\t * @returns {Boolean}\n\t * @function\n\t */\n\tisArray: Array.isArray ? Array.isArray : function(value) {\n\t\treturn Object.prototype.toString.call(value) === '[object Array]';\n\t},\n\n\t/**\n\t * Returns true if `value` is an object (excluding null), else returns false.\n\t * @param {*} value - The value to test.\n\t * @returns {Boolean}\n\t * @since 2.7.0\n\t */\n\tisObject: function(value) {\n\t\treturn value !== null && Object.prototype.toString.call(value) === '[object Object]';\n\t},\n\n\t/**\n\t * Returns `value` if defined, else returns `defaultValue`.\n\t * @param {*} value - The value to return if defined.\n\t * @param {*} defaultValue - The value to return if `value` is undefined.\n\t * @returns {*}\n\t */\n\tvalueOrDefault: function(value, defaultValue) {\n\t\treturn typeof value === 'undefined' ? defaultValue : value;\n\t},\n\n\t/**\n\t * Returns value at the given `index` in array if defined, else returns `defaultValue`.\n\t * @param {Array} value - The array to lookup for value at `index`.\n\t * @param {Number} index - The index in `value` to lookup for value.\n\t * @param {*} defaultValue - The value to return if `value[index]` is undefined.\n\t * @returns {*}\n\t */\n\tvalueAtIndexOrDefault: function(value, index, defaultValue) {\n\t\treturn helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);\n\t},\n\n\t/**\n\t * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n\t * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n\t * @param {Function} fn - The function to call.\n\t * @param {Array|undefined|null} args - The arguments with which `fn` should be called.\n\t * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.\n\t * @returns {*}\n\t */\n\tcallback: function(fn, args, thisArg) {\n\t\tif (fn && typeof fn.call === 'function') {\n\t\t\treturn fn.apply(thisArg, args);\n\t\t}\n\t},\n\n\t/**\n\t * Note(SB) for performance sake, this method should only be used when loopable type\n\t * is unknown or in none intensive code (not called often and small loopable). Else\n\t * it's preferable to use a regular for() loop and save extra function calls.\n\t * @param {Object|Array} loopable - The object or array to be iterated.\n\t * @param {Function} fn - The function to call for each item.\n\t * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.\n\t * @param {Boolean} [reverse] - If true, iterates backward on the loopable.\n\t */\n\teach: function(loopable, fn, thisArg, reverse) {\n\t\tvar i, len, keys;\n\t\tif (helpers.isArray(loopable)) {\n\t\t\tlen = loopable.length;\n\t\t\tif (reverse) {\n\t\t\t\tfor (i = len - 1; i >= 0; i--) {\n\t\t\t\t\tfn.call(thisArg, loopable[i], i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tfn.call(thisArg, loopable[i], i);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (helpers.isObject(loopable)) {\n\t\t\tkeys = Object.keys(loopable);\n\t\t\tlen = keys.length;\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tfn.call(thisArg, loopable[keys[i]], keys[i]);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n\t * @see http://stackoverflow.com/a/14853974\n\t * @param {Array} a0 - The array to compare\n\t * @param {Array} a1 - The array to compare\n\t * @returns {Boolean}\n\t */\n\tarrayEquals: function(a0, a1) {\n\t\tvar i, ilen, v0, v1;\n\n\t\tif (!a0 || !a1 || a0.length !== a1.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (i = 0, ilen = a0.length; i < ilen; ++i) {\n\t\t\tv0 = a0[i];\n\t\t\tv1 = a1[i];\n\n\t\t\tif (v0 instanceof Array && v1 instanceof Array) {\n\t\t\t\tif (!helpers.arrayEquals(v0, v1)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if (v0 !== v1) {\n\t\t\t\t// NOTE: two different object instances will never be equal: {x:20} != {x:20}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/**\n\t * Returns a deep copy of `source` without keeping references on objects and arrays.\n\t * @param {*} source - The value to clone.\n\t * @returns {*}\n\t */\n\tclone: function(source) {\n\t\tif (helpers.isArray(source)) {\n\t\t\treturn source.map(helpers.clone);\n\t\t}\n\n\t\tif (helpers.isObject(source)) {\n\t\t\tvar target = {};\n\t\t\tvar keys = Object.keys(source);\n\t\t\tvar klen = keys.length;\n\t\t\tvar k = 0;\n\n\t\t\tfor (; k < klen; ++k) {\n\t\t\t\ttarget[keys[k]] = helpers.clone(source[keys[k]]);\n\t\t\t}\n\n\t\t\treturn target;\n\t\t}\n\n\t\treturn source;\n\t},\n\n\t/**\n\t * The default merger when Chart.helpers.merge is called without merger option.\n\t * Note(SB): this method is also used by configMerge and scaleMerge as fallback.\n\t * @private\n\t */\n\t_merger: function(key, target, source, options) {\n\t\tvar tval = target[key];\n\t\tvar sval = source[key];\n\n\t\tif (helpers.isObject(tval) && helpers.isObject(sval)) {\n\t\t\thelpers.merge(tval, sval, options);\n\t\t} else {\n\t\t\ttarget[key] = helpers.clone(sval);\n\t\t}\n\t},\n\n\t/**\n\t * Merges source[key] in target[key] only if target[key] is undefined.\n\t * @private\n\t */\n\t_mergerIf: function(key, target, source) {\n\t\tvar tval = target[key];\n\t\tvar sval = source[key];\n\n\t\tif (helpers.isObject(tval) && helpers.isObject(sval)) {\n\t\t\thelpers.mergeIf(tval, sval);\n\t\t} else if (!target.hasOwnProperty(key)) {\n\t\t\ttarget[key] = helpers.clone(sval);\n\t\t}\n\t},\n\n\t/**\n\t * Recursively deep copies `source` properties into `target` with the given `options`.\n\t * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n\t * @param {Object} target - The target object in which all sources are merged into.\n\t * @param {Object|Array(Object)} source - Object(s) to merge into `target`.\n\t * @param {Object} [options] - Merging options:\n\t * @param {Function} [options.merger] - The merge method (key, target, source, options)\n\t * @returns {Object} The `target` object.\n\t */\n\tmerge: function(target, source, options) {\n\t\tvar sources = helpers.isArray(source) ? source : [source];\n\t\tvar ilen = sources.length;\n\t\tvar merge, i, keys, klen, k;\n\n\t\tif (!helpers.isObject(target)) {\n\t\t\treturn target;\n\t\t}\n\n\t\toptions = options || {};\n\t\tmerge = options.merger || helpers._merger;\n\n\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\tsource = sources[i];\n\t\t\tif (!helpers.isObject(source)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tkeys = Object.keys(source);\n\t\t\tfor (k = 0, klen = keys.length; k < klen; ++k) {\n\t\t\t\tmerge(keys[k], target, source, options);\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t},\n\n\t/**\n\t * Recursively deep copies `source` properties into `target` *only* if not defined in target.\n\t * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n\t * @param {Object} target - The target object in which all sources are merged into.\n\t * @param {Object|Array(Object)} source - Object(s) to merge into `target`.\n\t * @returns {Object} The `target` object.\n\t */\n\tmergeIf: function(target, source) {\n\t\treturn helpers.merge(target, source, {merger: helpers._mergerIf});\n\t},\n\n\t/**\n\t * Applies the contents of two or more objects together into the first object.\n\t * @param {Object} target - The target object in which all objects are merged into.\n\t * @param {Object} arg1 - Object containing additional properties to merge in target.\n\t * @param {Object} argN - Additional objects containing properties to merge in target.\n\t * @returns {Object} The `target` object.\n\t */\n\textend: function(target) {\n\t\tvar setFn = function(value, key) {\n\t\t\ttarget[key] = value;\n\t\t};\n\t\tfor (var i = 1, ilen = arguments.length; i < ilen; ++i) {\n\t\t\thelpers.each(arguments[i], setFn);\n\t\t}\n\t\treturn target;\n\t},\n\n\t/**\n\t * Basic javascript inheritance based on the model created in Backbone.js\n\t */\n\tinherits: function(extensions) {\n\t\tvar me = this;\n\t\tvar ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {\n\t\t\treturn me.apply(this, arguments);\n\t\t};\n\n\t\tvar Surrogate = function() {\n\t\t\tthis.constructor = ChartElement;\n\t\t};\n\n\t\tSurrogate.prototype = me.prototype;\n\t\tChartElement.prototype = new Surrogate();\n\t\tChartElement.extend = helpers.inherits;\n\n\t\tif (extensions) {\n\t\t\thelpers.extend(ChartElement.prototype, extensions);\n\t\t}\n\n\t\tChartElement.__super__ = me.prototype;\n\t\treturn ChartElement;\n\t}\n};\n\nmodule.exports = helpers;\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, use Chart.helpers.callback instead.\n * @function Chart.helpers.callCallback\n * @deprecated since version 2.6.0\n * @todo remove at version 3\n * @private\n */\nhelpers.callCallback = helpers.callback;\n\n/**\n * Provided for backward compatibility, use Array.prototype.indexOf instead.\n * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+\n * @function Chart.helpers.indexOf\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.indexOf = function(array, item, fromIndex) {\n\treturn Array.prototype.indexOf.call(array, item, fromIndex);\n};\n\n/**\n * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.\n * @function Chart.helpers.getValueOrDefault\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.getValueOrDefault = helpers.valueOrDefault;\n\n/**\n * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.\n * @function Chart.helpers.getValueAtIndexOrDefault\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n\n},{}],51:[function(require,module,exports){\n'use strict';\n\nvar helpers = require('./helpers.core');\n\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easingEffects\n * @see http://www.robertpenner.com/easing/\n */\nvar effects = {\n\tlinear: function(t) {\n\t\treturn t;\n\t},\n\n\teaseInQuad: function(t) {\n\t\treturn t * t;\n\t},\n\n\teaseOutQuad: function(t) {\n\t\treturn -t * (t - 2);\n\t},\n\n\teaseInOutQuad: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * t * t;\n\t\t}\n\t\treturn -0.5 * ((--t) * (t - 2) - 1);\n\t},\n\n\teaseInCubic: function(t) {\n\t\treturn t * t * t;\n\t},\n\n\teaseOutCubic: function(t) {\n\t\treturn (t = t - 1) * t * t + 1;\n\t},\n\n\teaseInOutCubic: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * t * t * t;\n\t\t}\n\t\treturn 0.5 * ((t -= 2) * t * t + 2);\n\t},\n\n\teaseInQuart: function(t) {\n\t\treturn t * t * t * t;\n\t},\n\n\teaseOutQuart: function(t) {\n\t\treturn -((t = t - 1) * t * t * t - 1);\n\t},\n\n\teaseInOutQuart: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * t * t * t * t;\n\t\t}\n\t\treturn -0.5 * ((t -= 2) * t * t * t - 2);\n\t},\n\n\teaseInQuint: function(t) {\n\t\treturn t * t * t * t * t;\n\t},\n\n\teaseOutQuint: function(t) {\n\t\treturn (t = t - 1) * t * t * t * t + 1;\n\t},\n\n\teaseInOutQuint: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * t * t * t * t * t;\n\t\t}\n\t\treturn 0.5 * ((t -= 2) * t * t * t * t + 2);\n\t},\n\n\teaseInSine: function(t) {\n\t\treturn -Math.cos(t * (Math.PI / 2)) + 1;\n\t},\n\n\teaseOutSine: function(t) {\n\t\treturn Math.sin(t * (Math.PI / 2));\n\t},\n\n\teaseInOutSine: function(t) {\n\t\treturn -0.5 * (Math.cos(Math.PI * t) - 1);\n\t},\n\n\teaseInExpo: function(t) {\n\t\treturn (t === 0) ? 0 : Math.pow(2, 10 * (t - 1));\n\t},\n\n\teaseOutExpo: function(t) {\n\t\treturn (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1;\n\t},\n\n\teaseInOutExpo: function(t) {\n\t\tif (t === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (t === 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * Math.pow(2, 10 * (t - 1));\n\t\t}\n\t\treturn 0.5 * (-Math.pow(2, -10 * --t) + 2);\n\t},\n\n\teaseInCirc: function(t) {\n\t\tif (t >= 1) {\n\t\t\treturn t;\n\t\t}\n\t\treturn -(Math.sqrt(1 - t * t) - 1);\n\t},\n\n\teaseOutCirc: function(t) {\n\t\treturn Math.sqrt(1 - (t = t - 1) * t);\n\t},\n\n\teaseInOutCirc: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn -0.5 * (Math.sqrt(1 - t * t) - 1);\n\t\t}\n\t\treturn 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n\t},\n\n\teaseInElastic: function(t) {\n\t\tvar s = 1.70158;\n\t\tvar p = 0;\n\t\tvar a = 1;\n\t\tif (t === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (t === 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (!p) {\n\t\t\tp = 0.3;\n\t\t}\n\t\tif (a < 1) {\n\t\t\ta = 1;\n\t\t\ts = p / 4;\n\t\t} else {\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t}\n\t\treturn -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\n\t},\n\n\teaseOutElastic: function(t) {\n\t\tvar s = 1.70158;\n\t\tvar p = 0;\n\t\tvar a = 1;\n\t\tif (t === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (t === 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (!p) {\n\t\t\tp = 0.3;\n\t\t}\n\t\tif (a < 1) {\n\t\t\ta = 1;\n\t\t\ts = p / 4;\n\t\t} else {\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t}\n\t\treturn a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;\n\t},\n\n\teaseInOutElastic: function(t) {\n\t\tvar s = 1.70158;\n\t\tvar p = 0;\n\t\tvar a = 1;\n\t\tif (t === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif ((t /= 0.5) === 2) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (!p) {\n\t\t\tp = 0.45;\n\t\t}\n\t\tif (a < 1) {\n\t\t\ta = 1;\n\t\t\ts = p / 4;\n\t\t} else {\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t}\n\t\tif (t < 1) {\n\t\t\treturn -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\n\t\t}\n\t\treturn a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t},\n\teaseInBack: function(t) {\n\t\tvar s = 1.70158;\n\t\treturn t * t * ((s + 1) * t - s);\n\t},\n\n\teaseOutBack: function(t) {\n\t\tvar s = 1.70158;\n\t\treturn (t = t - 1) * t * ((s + 1) * t + s) + 1;\n\t},\n\n\teaseInOutBack: function(t) {\n\t\tvar s = 1.70158;\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n\t\t}\n\t\treturn 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n\t},\n\n\teaseInBounce: function(t) {\n\t\treturn 1 - effects.easeOutBounce(1 - t);\n\t},\n\n\teaseOutBounce: function(t) {\n\t\tif (t < (1 / 2.75)) {\n\t\t\treturn 7.5625 * t * t;\n\t\t}\n\t\tif (t < (2 / 2.75)) {\n\t\t\treturn 7.5625 * (t -= (1.5 / 2.75)) * t + 0.75;\n\t\t}\n\t\tif (t < (2.5 / 2.75)) {\n\t\t\treturn 7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375;\n\t\t}\n\t\treturn 7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375;\n\t},\n\n\teaseInOutBounce: function(t) {\n\t\tif (t < 0.5) {\n\t\t\treturn effects.easeInBounce(t * 2) * 0.5;\n\t\t}\n\t\treturn effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;\n\t}\n};\n\nmodule.exports = {\n\teffects: effects\n};\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, use Chart.helpers.easing.effects instead.\n * @function Chart.helpers.easingEffects\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.easingEffects = effects;\n\n},{\"./helpers.core\":50}],52:[function(require,module,exports){\n'use strict';\n\nvar helpers = require('./helpers.core');\n\n/**\n * @alias Chart.helpers.options\n * @namespace\n */\nmodule.exports = {\n\t/**\n\t * Converts the given line height `value` in pixels for a specific font `size`.\n\t * @param {Number|String} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n\t * @param {Number} size - The font size (in pixels) used to resolve relative `value`.\n\t * @returns {Number} The effective line height in pixels (size * 1.2 if value is invalid).\n\t * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n\t * @since 2.7.0\n\t */\n\ttoLineHeight: function(value, size) {\n\t\tvar matches = ('' + value).match(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\n\t\tif (!matches || matches[1] === 'normal') {\n\t\t\treturn size * 1.2;\n\t\t}\n\n\t\tvalue = +matches[2];\n\n\t\tswitch (matches[3]) {\n\t\tcase 'px':\n\t\t\treturn value;\n\t\tcase '%':\n\t\t\tvalue /= 100;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\treturn size * value;\n\t},\n\n\t/**\n\t * Converts the given value into a padding object with pre-computed width/height.\n\t * @param {Number|Object} value - If a number, set the value to all TRBL component,\n\t *  else, if and object, use defined properties and sets undefined ones to 0.\n\t * @returns {Object} The padding values (top, right, bottom, left, width, height)\n\t * @since 2.7.0\n\t */\n\ttoPadding: function(value) {\n\t\tvar t, r, b, l;\n\n\t\tif (helpers.isObject(value)) {\n\t\t\tt = +value.top || 0;\n\t\t\tr = +value.right || 0;\n\t\t\tb = +value.bottom || 0;\n\t\t\tl = +value.left || 0;\n\t\t} else {\n\t\t\tt = r = b = l = +value || 0;\n\t\t}\n\n\t\treturn {\n\t\t\ttop: t,\n\t\t\tright: r,\n\t\t\tbottom: b,\n\t\t\tleft: l,\n\t\t\theight: t + b,\n\t\t\twidth: l + r\n\t\t};\n\t},\n\n\t/**\n\t * Evaluates the given `inputs` sequentially and returns the first defined value.\n\t * @param {Array[]} inputs - An array of values, falling back to the last value.\n\t * @param {Object} [context] - If defined and the current value is a function, the value\n\t * is called with `context` as first argument and the result becomes the new input.\n\t * @param {Number} [index] - If defined and the current value is an array, the value\n\t * at `index` become the new input.\n\t * @since 2.7.0\n\t */\n\tresolve: function(inputs, context, index) {\n\t\tvar i, ilen, value;\n\n\t\tfor (i = 0, ilen = inputs.length; i < ilen; ++i) {\n\t\t\tvalue = inputs[i];\n\t\t\tif (value === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (context !== undefined && typeof value === 'function') {\n\t\t\t\tvalue = value(context);\n\t\t\t}\n\t\t\tif (index !== undefined && helpers.isArray(value)) {\n\t\t\t\tvalue = value[index];\n\t\t\t}\n\t\t\tif (value !== undefined) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t}\n};\n\n},{\"./helpers.core\":50}],53:[function(require,module,exports){\n'use strict';\n\nmodule.exports = require('./helpers.core');\nmodule.exports.easing = require('./helpers.easing');\nmodule.exports.canvas = require('./helpers.canvas');\nmodule.exports.options = require('./helpers.options');\n\n},{\"./helpers.canvas\":49,\"./helpers.core\":50,\"./helpers.easing\":51,\"./helpers.options\":52}],54:[function(require,module,exports){\n/**\n * Platform fallback implementation (minimal).\n * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939\n */\n\nmodule.exports = {\n\tacquireContext: function(item) {\n\t\tif (item && item.canvas) {\n\t\t\t// Support for any object associated to a canvas (including a context2d)\n\t\t\titem = item.canvas;\n\t\t}\n\n\t\treturn item && item.getContext('2d') || null;\n\t}\n};\n\n},{}],55:[function(require,module,exports){\n/**\n * Chart.Platform implementation for targeting a web browser\n */\n\n'use strict';\n\nvar helpers = require('../helpers/index');\n\nvar EXPANDO_KEY = '$chartjs';\nvar CSS_PREFIX = 'chartjs-';\nvar CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';\nvar CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';\nvar ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];\n\n/**\n * DOM event types -> Chart.js event types.\n * Note: only events with different types are mapped.\n * @see https://developer.mozilla.org/en-US/docs/Web/Events\n */\nvar EVENT_TYPES = {\n\ttouchstart: 'mousedown',\n\ttouchmove: 'mousemove',\n\ttouchend: 'mouseup',\n\tpointerenter: 'mouseenter',\n\tpointerdown: 'mousedown',\n\tpointermove: 'mousemove',\n\tpointerup: 'mouseup',\n\tpointerleave: 'mouseout',\n\tpointerout: 'mouseout'\n};\n\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns {Number} Size in pixels or undefined if unknown.\n */\nfunction readUsedSize(element, property) {\n\tvar value = helpers.getStyle(element, property);\n\tvar matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n\treturn matches ? Number(matches[1]) : undefined;\n}\n\n/**\n * Initializes the canvas style and render size without modifying the canvas display size,\n * since responsiveness is handled by the controller.resize() method. The config is used\n * to determine the aspect ratio to apply in case no explicit height has been specified.\n */\nfunction initCanvas(canvas, config) {\n\tvar style = canvas.style;\n\n\t// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\n\t// returns null or '' if no explicit value has been set to the canvas attribute.\n\tvar renderHeight = canvas.getAttribute('height');\n\tvar renderWidth = canvas.getAttribute('width');\n\n\t// Chart.js modifies some canvas values that we want to restore on destroy\n\tcanvas[EXPANDO_KEY] = {\n\t\tinitial: {\n\t\t\theight: renderHeight,\n\t\t\twidth: renderWidth,\n\t\t\tstyle: {\n\t\t\t\tdisplay: style.display,\n\t\t\t\theight: style.height,\n\t\t\t\twidth: style.width\n\t\t\t}\n\t\t}\n\t};\n\n\t// Force canvas to display as block to avoid extra space caused by inline\n\t// elements, which would interfere with the responsive resize process.\n\t// https://github.com/chartjs/Chart.js/issues/2538\n\tstyle.display = style.display || 'block';\n\n\tif (renderWidth === null || renderWidth === '') {\n\t\tvar displayWidth = readUsedSize(canvas, 'width');\n\t\tif (displayWidth !== undefined) {\n\t\t\tcanvas.width = displayWidth;\n\t\t}\n\t}\n\n\tif (renderHeight === null || renderHeight === '') {\n\t\tif (canvas.style.height === '') {\n\t\t\t// If no explicit render height and style height, let's apply the aspect ratio,\n\t\t\t// which one can be specified by the user but also by charts as default option\n\t\t\t// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\n\t\t\tcanvas.height = canvas.width / (config.options.aspectRatio || 2);\n\t\t} else {\n\t\t\tvar displayHeight = readUsedSize(canvas, 'height');\n\t\t\tif (displayWidth !== undefined) {\n\t\t\t\tcanvas.height = displayHeight;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn canvas;\n}\n\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */\nvar supportsEventListenerOptions = (function() {\n\tvar supports = false;\n\ttry {\n\t\tvar options = Object.defineProperty({}, 'passive', {\n\t\t\tget: function() {\n\t\t\t\tsupports = true;\n\t\t\t}\n\t\t});\n\t\twindow.addEventListener('e', null, options);\n\t} catch (e) {\n\t\t// continue regardless of error\n\t}\n\treturn supports;\n}());\n\n// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.\n// https://github.com/chartjs/Chart.js/issues/4287\nvar eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\n\nfunction addEventListener(node, type, listener) {\n\tnode.addEventListener(type, listener, eventListenerOptions);\n}\n\nfunction removeEventListener(node, type, listener) {\n\tnode.removeEventListener(type, listener, eventListenerOptions);\n}\n\nfunction createEvent(type, chart, x, y, nativeEvent) {\n\treturn {\n\t\ttype: type,\n\t\tchart: chart,\n\t\tnative: nativeEvent || null,\n\t\tx: x !== undefined ? x : null,\n\t\ty: y !== undefined ? y : null,\n\t};\n}\n\nfunction fromNativeEvent(event, chart) {\n\tvar type = EVENT_TYPES[event.type] || event.type;\n\tvar pos = helpers.getRelativePosition(event, chart);\n\treturn createEvent(type, chart, pos.x, pos.y, event);\n}\n\nfunction throttled(fn, thisArg) {\n\tvar ticking = false;\n\tvar args = [];\n\n\treturn function() {\n\t\targs = Array.prototype.slice.call(arguments);\n\t\tthisArg = thisArg || this;\n\n\t\tif (!ticking) {\n\t\t\tticking = true;\n\t\t\thelpers.requestAnimFrame.call(window, function() {\n\t\t\t\tticking = false;\n\t\t\t\tfn.apply(thisArg, args);\n\t\t\t});\n\t\t}\n\t};\n}\n\n// Implementation based on https://github.com/marcj/css-element-queries\nfunction createResizer(handler) {\n\tvar resizer = document.createElement('div');\n\tvar cls = CSS_PREFIX + 'size-monitor';\n\tvar maxSize = 1000000;\n\tvar style =\n\t\t'position:absolute;' +\n\t\t'left:0;' +\n\t\t'top:0;' +\n\t\t'right:0;' +\n\t\t'bottom:0;' +\n\t\t'overflow:hidden;' +\n\t\t'pointer-events:none;' +\n\t\t'visibility:hidden;' +\n\t\t'z-index:-1;';\n\n\tresizer.style.cssText = style;\n\tresizer.className = cls;\n\tresizer.innerHTML =\n\t\t'<div class=\"' + cls + '-expand\" style=\"' + style + '\">' +\n\t\t\t'<div style=\"' +\n\t\t\t\t'position:absolute;' +\n\t\t\t\t'width:' + maxSize + 'px;' +\n\t\t\t\t'height:' + maxSize + 'px;' +\n\t\t\t\t'left:0;' +\n\t\t\t\t'top:0\">' +\n\t\t\t'</div>' +\n\t\t'</div>' +\n\t\t'<div class=\"' + cls + '-shrink\" style=\"' + style + '\">' +\n\t\t\t'<div style=\"' +\n\t\t\t\t'position:absolute;' +\n\t\t\t\t'width:200%;' +\n\t\t\t\t'height:200%;' +\n\t\t\t\t'left:0; ' +\n\t\t\t\t'top:0\">' +\n\t\t\t'</div>' +\n\t\t'</div>';\n\n\tvar expand = resizer.childNodes[0];\n\tvar shrink = resizer.childNodes[1];\n\n\tresizer._reset = function() {\n\t\texpand.scrollLeft = maxSize;\n\t\texpand.scrollTop = maxSize;\n\t\tshrink.scrollLeft = maxSize;\n\t\tshrink.scrollTop = maxSize;\n\t};\n\tvar onScroll = function() {\n\t\tresizer._reset();\n\t\thandler();\n\t};\n\n\taddEventListener(expand, 'scroll', onScroll.bind(expand, 'expand'));\n\taddEventListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));\n\n\treturn resizer;\n}\n\n// https://davidwalsh.name/detect-node-insertion\nfunction watchForRender(node, handler) {\n\tvar expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});\n\tvar proxy = expando.renderProxy = function(e) {\n\t\tif (e.animationName === CSS_RENDER_ANIMATION) {\n\t\t\thandler();\n\t\t}\n\t};\n\n\thelpers.each(ANIMATION_START_EVENTS, function(type) {\n\t\taddEventListener(node, type, proxy);\n\t});\n\n\t// #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class\n\t// is removed then added back immediately (same animation frame?). Accessing the\n\t// `offsetParent` property will force a reflow and re-evaluate the CSS animation.\n\t// https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics\n\t// https://github.com/chartjs/Chart.js/issues/4737\n\texpando.reflow = !!node.offsetParent;\n\n\tnode.classList.add(CSS_RENDER_MONITOR);\n}\n\nfunction unwatchForRender(node) {\n\tvar expando = node[EXPANDO_KEY] || {};\n\tvar proxy = expando.renderProxy;\n\n\tif (proxy) {\n\t\thelpers.each(ANIMATION_START_EVENTS, function(type) {\n\t\t\tremoveEventListener(node, type, proxy);\n\t\t});\n\n\t\tdelete expando.renderProxy;\n\t}\n\n\tnode.classList.remove(CSS_RENDER_MONITOR);\n}\n\nfunction addResizeListener(node, listener, chart) {\n\tvar expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});\n\n\t// Let's keep track of this added resizer and thus avoid DOM query when removing it.\n\tvar resizer = expando.resizer = createResizer(throttled(function() {\n\t\tif (expando.resizer) {\n\t\t\treturn listener(createEvent('resize', chart));\n\t\t}\n\t}));\n\n\t// The resizer needs to be attached to the node parent, so we first need to be\n\t// sure that `node` is attached to the DOM before injecting the resizer element.\n\twatchForRender(node, function() {\n\t\tif (expando.resizer) {\n\t\t\tvar container = node.parentNode;\n\t\t\tif (container && container !== resizer.parentNode) {\n\t\t\t\tcontainer.insertBefore(resizer, container.firstChild);\n\t\t\t}\n\n\t\t\t// The container size might have changed, let's reset the resizer state.\n\t\t\tresizer._reset();\n\t\t}\n\t});\n}\n\nfunction removeResizeListener(node) {\n\tvar expando = node[EXPANDO_KEY] || {};\n\tvar resizer = expando.resizer;\n\n\tdelete expando.resizer;\n\tunwatchForRender(node);\n\n\tif (resizer && resizer.parentNode) {\n\t\tresizer.parentNode.removeChild(resizer);\n\t}\n}\n\nfunction injectCSS(platform, css) {\n\t// http://stackoverflow.com/q/3922139\n\tvar style = platform._style || document.createElement('style');\n\tif (!platform._style) {\n\t\tplatform._style = style;\n\t\tcss = '/* Chart.js */\\n' + css;\n\t\tstyle.setAttribute('type', 'text/css');\n\t\tdocument.getElementsByTagName('head')[0].appendChild(style);\n\t}\n\n\tstyle.appendChild(document.createTextNode(css));\n}\n\nmodule.exports = {\n\t/**\n\t * This property holds whether this platform is enabled for the current environment.\n\t * Currently used by platform.js to select the proper implementation.\n\t * @private\n\t */\n\t_enabled: typeof window !== 'undefined' && typeof document !== 'undefined',\n\n\tinitialize: function() {\n\t\tvar keyframes = 'from{opacity:0.99}to{opacity:1}';\n\n\t\tinjectCSS(this,\n\t\t\t// DOM rendering detection\n\t\t\t// https://davidwalsh.name/detect-node-insertion\n\t\t\t'@-webkit-keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' +\n\t\t\t'@keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' +\n\t\t\t'.' + CSS_RENDER_MONITOR + '{' +\n\t\t\t\t'-webkit-animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' +\n\t\t\t\t'animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' +\n\t\t\t'}'\n\t\t);\n\t},\n\n\tacquireContext: function(item, config) {\n\t\tif (typeof item === 'string') {\n\t\t\titem = document.getElementById(item);\n\t\t} else if (item.length) {\n\t\t\t// Support for array based queries (such as jQuery)\n\t\t\titem = item[0];\n\t\t}\n\n\t\tif (item && item.canvas) {\n\t\t\t// Support for any object associated to a canvas (including a context2d)\n\t\t\titem = item.canvas;\n\t\t}\n\n\t\t// To prevent canvas fingerprinting, some add-ons undefine the getContext\n\t\t// method, for example: https://github.com/kkapsner/CanvasBlocker\n\t\t// https://github.com/chartjs/Chart.js/issues/2807\n\t\tvar context = item && item.getContext && item.getContext('2d');\n\n\t\t// `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is\n\t\t// inside an iframe or when running in a protected environment. We could guess the\n\t\t// types from their toString() value but let's keep things flexible and assume it's\n\t\t// a sufficient condition if the item has a context2D which has item as `canvas`.\n\t\t// https://github.com/chartjs/Chart.js/issues/3887\n\t\t// https://github.com/chartjs/Chart.js/issues/4102\n\t\t// https://github.com/chartjs/Chart.js/issues/4152\n\t\tif (context && context.canvas === item) {\n\t\t\tinitCanvas(item, config);\n\t\t\treturn context;\n\t\t}\n\n\t\treturn null;\n\t},\n\n\treleaseContext: function(context) {\n\t\tvar canvas = context.canvas;\n\t\tif (!canvas[EXPANDO_KEY]) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar initial = canvas[EXPANDO_KEY].initial;\n\t\t['height', 'width'].forEach(function(prop) {\n\t\t\tvar value = initial[prop];\n\t\t\tif (helpers.isNullOrUndef(value)) {\n\t\t\t\tcanvas.removeAttribute(prop);\n\t\t\t} else {\n\t\t\t\tcanvas.setAttribute(prop, value);\n\t\t\t}\n\t\t});\n\n\t\thelpers.each(initial.style || {}, function(value, key) {\n\t\t\tcanvas.style[key] = value;\n\t\t});\n\n\t\t// The canvas render size might have been changed (and thus the state stack discarded),\n\t\t// we can't use save() and restore() to restore the initial state. So make sure that at\n\t\t// least the canvas context is reset to the default state by setting the canvas width.\n\t\t// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\n\t\tcanvas.width = canvas.width;\n\n\t\tdelete canvas[EXPANDO_KEY];\n\t},\n\n\taddEventListener: function(chart, type, listener) {\n\t\tvar canvas = chart.canvas;\n\t\tif (type === 'resize') {\n\t\t\t// Note: the resize event is not supported on all browsers.\n\t\t\taddResizeListener(canvas, listener, chart);\n\t\t\treturn;\n\t\t}\n\n\t\tvar expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});\n\t\tvar proxies = expando.proxies || (expando.proxies = {});\n\t\tvar proxy = proxies[chart.id + '_' + type] = function(event) {\n\t\t\tlistener(fromNativeEvent(event, chart));\n\t\t};\n\n\t\taddEventListener(canvas, type, proxy);\n\t},\n\n\tremoveEventListener: function(chart, type, listener) {\n\t\tvar canvas = chart.canvas;\n\t\tif (type === 'resize') {\n\t\t\t// Note: the resize event is not supported on all browsers.\n\t\t\tremoveResizeListener(canvas, listener);\n\t\t\treturn;\n\t\t}\n\n\t\tvar expando = listener[EXPANDO_KEY] || {};\n\t\tvar proxies = expando.proxies || {};\n\t\tvar proxy = proxies[chart.id + '_' + type];\n\t\tif (!proxy) {\n\t\t\treturn;\n\t\t}\n\n\t\tremoveEventListener(canvas, type, proxy);\n\t}\n};\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, use EventTarget.addEventListener instead.\n * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n * @function Chart.helpers.addEvent\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.addEvent = addEventListener;\n\n/**\n * Provided for backward compatibility, use EventTarget.removeEventListener instead.\n * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener\n * @function Chart.helpers.removeEvent\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.removeEvent = removeEventListener;\n\n},{\"../helpers/index\":53}],56:[function(require,module,exports){\n'use strict';\n\nvar helpers = require('../helpers/index');\nvar basic = require('./platform.basic');\nvar dom = require('./platform.dom');\n\n// @TODO Make possible to select another platform at build time.\nvar implementation = dom._enabled ? dom : basic;\n\n/**\n * @namespace Chart.platform\n * @see https://chartjs.gitbooks.io/proposals/content/Platform.html\n * @since 2.4.0\n */\nmodule.exports = helpers.extend({\n\t/**\n\t * @since 2.7.0\n\t */\n\tinitialize: function() {},\n\n\t/**\n\t * Called at chart construction time, returns a context2d instance implementing\n\t * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\n\t * @param {*} item - The native item from which to acquire context (platform specific)\n\t * @param {Object} options - The chart options\n\t * @returns {CanvasRenderingContext2D} context2d instance\n\t */\n\tacquireContext: function() {},\n\n\t/**\n\t * Called at chart destruction time, releases any resources associated to the context\n\t * previously returned by the acquireContext() method.\n\t * @param {CanvasRenderingContext2D} context - The context2d instance\n\t * @returns {Boolean} true if the method succeeded, else false\n\t */\n\treleaseContext: function() {},\n\n\t/**\n\t * Registers the specified listener on the given chart.\n\t * @param {Chart} chart - Chart from which to listen for event\n\t * @param {String} type - The ({@link IEvent}) type to listen for\n\t * @param {Function} listener - Receives a notification (an object that implements\n\t * the {@link IEvent} interface) when an event of the specified type occurs.\n\t */\n\taddEventListener: function() {},\n\n\t/**\n\t * Removes the specified listener previously registered with addEventListener.\n\t * @param {Chart} chart -Chart from which to remove the listener\n\t * @param {String} type - The ({@link IEvent}) type to remove\n\t * @param {Function} listener - The listener function to remove from the event target.\n\t */\n\tremoveEventListener: function() {}\n\n}, implementation);\n\n/**\n * @interface IPlatform\n * Allows abstracting platform dependencies away from the chart\n * @borrows Chart.platform.acquireContext as acquireContext\n * @borrows Chart.platform.releaseContext as releaseContext\n * @borrows Chart.platform.addEventListener as addEventListener\n * @borrows Chart.platform.removeEventListener as removeEventListener\n */\n\n/**\n * @interface IEvent\n * @prop {String} type - The event type name, possible values are:\n * 'contextmenu', 'mouseenter', 'mousedown', 'mousemove', 'mouseup', 'mouseout',\n * 'click', 'dblclick', 'keydown', 'keypress', 'keyup' and 'resize'\n * @prop {*} native - The original native event (null for emulated events, e.g. 'resize')\n * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)\n * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)\n */\n\n},{\"../helpers/index\":53,\"./platform.basic\":54,\"./platform.dom\":55}],57:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {};\nmodule.exports.filler = require('./plugin.filler');\nmodule.exports.legend = require('./plugin.legend');\nmodule.exports.title = require('./plugin.title');\n\n},{\"./plugin.filler\":58,\"./plugin.legend\":59,\"./plugin.title\":60}],58:[function(require,module,exports){\n/**\n * Plugin based on discussion from the following Chart.js issues:\n * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569\n * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897\n */\n\n'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('global', {\n\tplugins: {\n\t\tfiller: {\n\t\t\tpropagate: true\n\t\t}\n\t}\n});\n\nvar mappers = {\n\tdataset: function(source) {\n\t\tvar index = source.fill;\n\t\tvar chart = source.chart;\n\t\tvar meta = chart.getDatasetMeta(index);\n\t\tvar visible = meta && chart.isDatasetVisible(index);\n\t\tvar points = (visible && meta.dataset._children) || [];\n\t\tvar length = points.length || 0;\n\n\t\treturn !length ? null : function(point, i) {\n\t\t\treturn (i < length && points[i]._view) || null;\n\t\t};\n\t},\n\n\tboundary: function(source) {\n\t\tvar boundary = source.boundary;\n\t\tvar x = boundary ? boundary.x : null;\n\t\tvar y = boundary ? boundary.y : null;\n\n\t\treturn function(point) {\n\t\t\treturn {\n\t\t\t\tx: x === null ? point.x : x,\n\t\t\t\ty: y === null ? point.y : y,\n\t\t\t};\n\t\t};\n\t}\n};\n\n// @todo if (fill[0] === '#')\nfunction decodeFill(el, index, count) {\n\tvar model = el._model || {};\n\tvar fill = model.fill;\n\tvar target;\n\n\tif (fill === undefined) {\n\t\tfill = !!model.backgroundColor;\n\t}\n\n\tif (fill === false || fill === null) {\n\t\treturn false;\n\t}\n\n\tif (fill === true) {\n\t\treturn 'origin';\n\t}\n\n\ttarget = parseFloat(fill, 10);\n\tif (isFinite(target) && Math.floor(target) === target) {\n\t\tif (fill[0] === '-' || fill[0] === '+') {\n\t\t\ttarget = index + target;\n\t\t}\n\n\t\tif (target === index || target < 0 || target >= count) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn target;\n\t}\n\n\tswitch (fill) {\n\t// compatibility\n\tcase 'bottom':\n\t\treturn 'start';\n\tcase 'top':\n\t\treturn 'end';\n\tcase 'zero':\n\t\treturn 'origin';\n\t// supported boundaries\n\tcase 'origin':\n\tcase 'start':\n\tcase 'end':\n\t\treturn fill;\n\t// invalid fill values\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nfunction computeBoundary(source) {\n\tvar model = source.el._model || {};\n\tvar scale = source.el._scale || {};\n\tvar fill = source.fill;\n\tvar target = null;\n\tvar horizontal;\n\n\tif (isFinite(fill)) {\n\t\treturn null;\n\t}\n\n\t// Backward compatibility: until v3, we still need to support boundary values set on\n\t// the model (scaleTop, scaleBottom and scaleZero) because some external plugins and\n\t// controllers might still use it (e.g. the Smith chart).\n\n\tif (fill === 'start') {\n\t\ttarget = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;\n\t} else if (fill === 'end') {\n\t\ttarget = model.scaleTop === undefined ? scale.top : model.scaleTop;\n\t} else if (model.scaleZero !== undefined) {\n\t\ttarget = model.scaleZero;\n\t} else if (scale.getBasePosition) {\n\t\ttarget = scale.getBasePosition();\n\t} else if (scale.getBasePixel) {\n\t\ttarget = scale.getBasePixel();\n\t}\n\n\tif (target !== undefined && target !== null) {\n\t\tif (target.x !== undefined && target.y !== undefined) {\n\t\t\treturn target;\n\t\t}\n\n\t\tif (typeof target === 'number' && isFinite(target)) {\n\t\t\thorizontal = scale.isHorizontal();\n\t\t\treturn {\n\t\t\t\tx: horizontal ? target : null,\n\t\t\t\ty: horizontal ? null : target\n\t\t\t};\n\t\t}\n\t}\n\n\treturn null;\n}\n\nfunction resolveTarget(sources, index, propagate) {\n\tvar source = sources[index];\n\tvar fill = source.fill;\n\tvar visited = [index];\n\tvar target;\n\n\tif (!propagate) {\n\t\treturn fill;\n\t}\n\n\twhile (fill !== false && visited.indexOf(fill) === -1) {\n\t\tif (!isFinite(fill)) {\n\t\t\treturn fill;\n\t\t}\n\n\t\ttarget = sources[fill];\n\t\tif (!target) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (target.visible) {\n\t\t\treturn fill;\n\t\t}\n\n\t\tvisited.push(fill);\n\t\tfill = target.fill;\n\t}\n\n\treturn false;\n}\n\nfunction createMapper(source) {\n\tvar fill = source.fill;\n\tvar type = 'dataset';\n\n\tif (fill === false) {\n\t\treturn null;\n\t}\n\n\tif (!isFinite(fill)) {\n\t\ttype = 'boundary';\n\t}\n\n\treturn mappers[type](source);\n}\n\nfunction isDrawable(point) {\n\treturn point && !point.skip;\n}\n\nfunction drawArea(ctx, curve0, curve1, len0, len1) {\n\tvar i;\n\n\tif (!len0 || !len1) {\n\t\treturn;\n\t}\n\n\t// building first area curve (normal)\n\tctx.moveTo(curve0[0].x, curve0[0].y);\n\tfor (i = 1; i < len0; ++i) {\n\t\thelpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);\n\t}\n\n\t// joining the two area curves\n\tctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);\n\n\t// building opposite area curve (reverse)\n\tfor (i = len1 - 1; i > 0; --i) {\n\t\thelpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);\n\t}\n}\n\nfunction doFill(ctx, points, mapper, view, color, loop) {\n\tvar count = points.length;\n\tvar span = view.spanGaps;\n\tvar curve0 = [];\n\tvar curve1 = [];\n\tvar len0 = 0;\n\tvar len1 = 0;\n\tvar i, ilen, index, p0, p1, d0, d1;\n\n\tctx.beginPath();\n\n\tfor (i = 0, ilen = (count + !!loop); i < ilen; ++i) {\n\t\tindex = i % count;\n\t\tp0 = points[index]._view;\n\t\tp1 = mapper(p0, index, view);\n\t\td0 = isDrawable(p0);\n\t\td1 = isDrawable(p1);\n\n\t\tif (d0 && d1) {\n\t\t\tlen0 = curve0.push(p0);\n\t\t\tlen1 = curve1.push(p1);\n\t\t} else if (len0 && len1) {\n\t\t\tif (!span) {\n\t\t\t\tdrawArea(ctx, curve0, curve1, len0, len1);\n\t\t\t\tlen0 = len1 = 0;\n\t\t\t\tcurve0 = [];\n\t\t\t\tcurve1 = [];\n\t\t\t} else {\n\t\t\t\tif (d0) {\n\t\t\t\t\tcurve0.push(p0);\n\t\t\t\t}\n\t\t\t\tif (d1) {\n\t\t\t\t\tcurve1.push(p1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdrawArea(ctx, curve0, curve1, len0, len1);\n\n\tctx.closePath();\n\tctx.fillStyle = color;\n\tctx.fill();\n}\n\nmodule.exports = {\n\tid: 'filler',\n\n\tafterDatasetsUpdate: function(chart, options) {\n\t\tvar count = (chart.data.datasets || []).length;\n\t\tvar propagate = options.propagate;\n\t\tvar sources = [];\n\t\tvar meta, i, el, source;\n\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\tel = meta.dataset;\n\t\t\tsource = null;\n\n\t\t\tif (el && el._model && el instanceof elements.Line) {\n\t\t\t\tsource = {\n\t\t\t\t\tvisible: chart.isDatasetVisible(i),\n\t\t\t\t\tfill: decodeFill(el, i, count),\n\t\t\t\t\tchart: chart,\n\t\t\t\t\tel: el\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tmeta.$filler = source;\n\t\t\tsources.push(source);\n\t\t}\n\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tsource = sources[i];\n\t\t\tif (!source) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsource.fill = resolveTarget(sources, i, propagate);\n\t\t\tsource.boundary = computeBoundary(source);\n\t\t\tsource.mapper = createMapper(source);\n\t\t}\n\t},\n\n\tbeforeDatasetDraw: function(chart, args) {\n\t\tvar meta = args.meta.$filler;\n\t\tif (!meta) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar ctx = chart.ctx;\n\t\tvar el = meta.el;\n\t\tvar view = el._view;\n\t\tvar points = el._children || [];\n\t\tvar mapper = meta.mapper;\n\t\tvar color = view.backgroundColor || defaults.global.defaultColor;\n\n\t\tif (mapper && color && points.length) {\n\t\t\thelpers.canvas.clipArea(ctx, chart.chartArea);\n\t\t\tdoFill(ctx, points, mapper, view, color, el._loop);\n\t\t\thelpers.canvas.unclipArea(ctx);\n\t\t}\n\t}\n};\n\n},{\"../core/core.defaults\":33,\"../elements/index\":48,\"../helpers/index\":53}],59:[function(require,module,exports){\n'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar Element = require('../core/core.element');\nvar helpers = require('../helpers/index');\nvar layouts = require('../core/core.layouts');\n\nvar noop = helpers.noop;\n\ndefaults._set('global', {\n\tlegend: {\n\t\tdisplay: true,\n\t\tposition: 'top',\n\t\tfullWidth: true,\n\t\treverse: false,\n\t\tweight: 1000,\n\n\t\t// a callback that will handle\n\t\tonClick: function(e, legendItem) {\n\t\t\tvar index = legendItem.datasetIndex;\n\t\t\tvar ci = this.chart;\n\t\t\tvar meta = ci.getDatasetMeta(index);\n\n\t\t\t// See controller.isDatasetVisible comment\n\t\t\tmeta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;\n\n\t\t\t// We hid a dataset ... rerender the chart\n\t\t\tci.update();\n\t\t},\n\n\t\tonHover: null,\n\n\t\tlabels: {\n\t\t\tboxWidth: 40,\n\t\t\tpadding: 10,\n\t\t\t// Generates labels shown in the legend\n\t\t\t// Valid properties to return:\n\t\t\t// text : text to display\n\t\t\t// fillStyle : fill of coloured box\n\t\t\t// strokeStyle: stroke of coloured box\n\t\t\t// hidden : if this legend item refers to a hidden item\n\t\t\t// lineCap : cap style for line\n\t\t\t// lineDash\n\t\t\t// lineDashOffset :\n\t\t\t// lineJoin :\n\t\t\t// lineWidth :\n\t\t\tgenerateLabels: function(chart) {\n\t\t\t\tvar data = chart.data;\n\t\t\t\treturn helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttext: dataset.label,\n\t\t\t\t\t\tfillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),\n\t\t\t\t\t\thidden: !chart.isDatasetVisible(i),\n\t\t\t\t\t\tlineCap: dataset.borderCapStyle,\n\t\t\t\t\t\tlineDash: dataset.borderDash,\n\t\t\t\t\t\tlineDashOffset: dataset.borderDashOffset,\n\t\t\t\t\t\tlineJoin: dataset.borderJoinStyle,\n\t\t\t\t\t\tlineWidth: dataset.borderWidth,\n\t\t\t\t\t\tstrokeStyle: dataset.borderColor,\n\t\t\t\t\t\tpointStyle: dataset.pointStyle,\n\n\t\t\t\t\t\t// Below is extra data used for toggling the datasets\n\t\t\t\t\t\tdatasetIndex: i\n\t\t\t\t\t};\n\t\t\t\t}, this) : [];\n\t\t\t}\n\t\t}\n\t},\n\n\tlegendCallback: function(chart) {\n\t\tvar text = [];\n\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\t\tfor (var i = 0; i < chart.data.datasets.length; i++) {\n\t\t\ttext.push('<li><span style=\"background-color:' + chart.data.datasets[i].backgroundColor + '\"></span>');\n\t\t\tif (chart.data.datasets[i].label) {\n\t\t\t\ttext.push(chart.data.datasets[i].label);\n\t\t\t}\n\t\t\ttext.push('</li>');\n\t\t}\n\t\ttext.push('</ul>');\n\t\treturn text.join('');\n\t}\n});\n\n/**\n * Helper function to get the box width based on the usePointStyle option\n * @param labelopts {Object} the label options on the legend\n * @param fontSize {Number} the label font size\n * @return {Number} width of the color box area\n */\nfunction getBoxWidth(labelOpts, fontSize) {\n\treturn labelOpts.usePointStyle ?\n\t\tfontSize * Math.SQRT2 :\n\t\tlabelOpts.boxWidth;\n}\n\n/**\n * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!\n */\nvar Legend = Element.extend({\n\n\tinitialize: function(config) {\n\t\thelpers.extend(this, config);\n\n\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\tthis.legendHitBoxes = [];\n\n\t\t// Are we in doughnut mode which has a different data type\n\t\tthis.doughnutMode = false;\n\t},\n\n\t// These methods are ordered by lifecycle. Utilities then follow.\n\t// Any function defined here is inherited by all legend types.\n\t// Any function can be extended by the legend type\n\n\tbeforeUpdate: noop,\n\tupdate: function(maxWidth, maxHeight, margins) {\n\t\tvar me = this;\n\n\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\tme.beforeUpdate();\n\n\t\t// Absorb the master measurements\n\t\tme.maxWidth = maxWidth;\n\t\tme.maxHeight = maxHeight;\n\t\tme.margins = margins;\n\n\t\t// Dimensions\n\t\tme.beforeSetDimensions();\n\t\tme.setDimensions();\n\t\tme.afterSetDimensions();\n\t\t// Labels\n\t\tme.beforeBuildLabels();\n\t\tme.buildLabels();\n\t\tme.afterBuildLabels();\n\n\t\t// Fit\n\t\tme.beforeFit();\n\t\tme.fit();\n\t\tme.afterFit();\n\t\t//\n\t\tme.afterUpdate();\n\n\t\treturn me.minSize;\n\t},\n\tafterUpdate: noop,\n\n\t//\n\n\tbeforeSetDimensions: noop,\n\tsetDimensions: function() {\n\t\tvar me = this;\n\t\t// Set the unconstrained dimension before label rotation\n\t\tif (me.isHorizontal()) {\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.left = 0;\n\t\t\tme.right = me.width;\n\t\t} else {\n\t\t\tme.height = me.maxHeight;\n\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.top = 0;\n\t\t\tme.bottom = me.height;\n\t\t}\n\n\t\t// Reset padding\n\t\tme.paddingLeft = 0;\n\t\tme.paddingTop = 0;\n\t\tme.paddingRight = 0;\n\t\tme.paddingBottom = 0;\n\n\t\t// Reset minSize\n\t\tme.minSize = {\n\t\t\twidth: 0,\n\t\t\theight: 0\n\t\t};\n\t},\n\tafterSetDimensions: noop,\n\n\t//\n\n\tbeforeBuildLabels: noop,\n\tbuildLabels: function() {\n\t\tvar me = this;\n\t\tvar labelOpts = me.options.labels || {};\n\t\tvar legendItems = helpers.callback(labelOpts.generateLabels, [me.chart], me) || [];\n\n\t\tif (labelOpts.filter) {\n\t\t\tlegendItems = legendItems.filter(function(item) {\n\t\t\t\treturn labelOpts.filter(item, me.chart.data);\n\t\t\t});\n\t\t}\n\n\t\tif (me.options.reverse) {\n\t\t\tlegendItems.reverse();\n\t\t}\n\n\t\tme.legendItems = legendItems;\n\t},\n\tafterBuildLabels: noop,\n\n\t//\n\n\tbeforeFit: noop,\n\tfit: function() {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\t\tvar labelOpts = opts.labels;\n\t\tvar display = opts.display;\n\n\t\tvar ctx = me.ctx;\n\n\t\tvar globalDefault = defaults.global;\n\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\tvar fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);\n\t\tvar fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);\n\t\tvar fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);\n\t\tvar labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\t// Reset hit boxes\n\t\tvar hitboxes = me.legendHitBoxes = [];\n\n\t\tvar minSize = me.minSize;\n\t\tvar isHorizontal = me.isHorizontal();\n\n\t\tif (isHorizontal) {\n\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\tminSize.height = display ? 10 : 0;\n\t\t} else {\n\t\t\tminSize.width = display ? 10 : 0;\n\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t}\n\n\t\t// Increase sizes here\n\t\tif (display) {\n\t\t\tctx.font = labelFont;\n\n\t\t\tif (isHorizontal) {\n\t\t\t\t// Labels\n\n\t\t\t\t// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n\t\t\t\tvar lineWidths = me.lineWidths = [0];\n\t\t\t\tvar totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;\n\n\t\t\t\tctx.textAlign = 'left';\n\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\tvar width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n\t\t\t\t\tif (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {\n\t\t\t\t\t\ttotalHeight += fontSize + (labelOpts.padding);\n\t\t\t\t\t\tlineWidths[lineWidths.length] = me.left;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\twidth: width,\n\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t};\n\n\t\t\t\t\tlineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n\t\t\t\t});\n\n\t\t\t\tminSize.height += totalHeight;\n\n\t\t\t} else {\n\t\t\t\tvar vPadding = labelOpts.padding;\n\t\t\t\tvar columnWidths = me.columnWidths = [];\n\t\t\t\tvar totalWidth = labelOpts.padding;\n\t\t\t\tvar currentColWidth = 0;\n\t\t\t\tvar currentColHeight = 0;\n\t\t\t\tvar itemHeight = fontSize + vPadding;\n\n\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\tvar itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n\t\t\t\t\t// If too tall, go to new column\n\t\t\t\t\tif (currentColHeight + itemHeight > minSize.height) {\n\t\t\t\t\t\ttotalWidth += currentColWidth + labelOpts.padding;\n\t\t\t\t\t\tcolumnWidths.push(currentColWidth); // previous column width\n\n\t\t\t\t\t\tcurrentColWidth = 0;\n\t\t\t\t\t\tcurrentColHeight = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get max width\n\t\t\t\t\tcurrentColWidth = Math.max(currentColWidth, itemWidth);\n\t\t\t\t\tcurrentColHeight += itemHeight;\n\n\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\twidth: itemWidth,\n\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t};\n\t\t\t\t});\n\n\t\t\t\ttotalWidth += currentColWidth;\n\t\t\t\tcolumnWidths.push(currentColWidth);\n\t\t\t\tminSize.width += totalWidth;\n\t\t\t}\n\t\t}\n\n\t\tme.width = minSize.width;\n\t\tme.height = minSize.height;\n\t},\n\tafterFit: noop,\n\n\t// Shared Methods\n\tisHorizontal: function() {\n\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t},\n\n\t// Actually draw the legend on the canvas\n\tdraw: function() {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\t\tvar labelOpts = opts.labels;\n\t\tvar globalDefault = defaults.global;\n\t\tvar lineDefault = globalDefault.elements.line;\n\t\tvar legendWidth = me.width;\n\t\tvar lineWidths = me.lineWidths;\n\n\t\tif (opts.display) {\n\t\t\tvar ctx = me.ctx;\n\t\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\t\tvar fontColor = valueOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor);\n\t\t\tvar fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);\n\t\t\tvar fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);\n\t\t\tvar fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);\n\t\t\tvar labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\t\t\tvar cursor;\n\n\t\t\t// Canvas setup\n\t\t\tctx.textAlign = 'left';\n\t\t\tctx.textBaseline = 'middle';\n\t\t\tctx.lineWidth = 0.5;\n\t\t\tctx.strokeStyle = fontColor; // for strikethrough effect\n\t\t\tctx.fillStyle = fontColor; // render in correct colour\n\t\t\tctx.font = labelFont;\n\n\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\tvar hitboxes = me.legendHitBoxes;\n\n\t\t\t// current position\n\t\t\tvar drawLegendBox = function(x, y, legendItem) {\n\t\t\t\tif (isNaN(boxWidth) || boxWidth <= 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Set the ctx for the box\n\t\t\t\tctx.save();\n\n\t\t\t\tctx.fillStyle = valueOrDefault(legendItem.fillStyle, globalDefault.defaultColor);\n\t\t\t\tctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\n\t\t\t\tctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n\t\t\t\tctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\n\t\t\t\tctx.lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\n\t\t\t\tctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);\n\t\t\t\tvar isLineWidthZero = (valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);\n\n\t\t\t\tif (ctx.setLineDash) {\n\t\t\t\t\t// IE 9 and 10 do not support line dash\n\t\t\t\t\tctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));\n\t\t\t\t}\n\n\t\t\t\tif (opts.labels && opts.labels.usePointStyle) {\n\t\t\t\t\t// Recalculate x and y for drawPoint() because its expecting\n\t\t\t\t\t// x and y to be center of figure (instead of top left)\n\t\t\t\t\tvar radius = fontSize * Math.SQRT2 / 2;\n\t\t\t\t\tvar offSet = radius / Math.SQRT2;\n\t\t\t\t\tvar centerX = x + offSet;\n\t\t\t\t\tvar centerY = y + offSet;\n\n\t\t\t\t\t// Draw pointStyle as legend symbol\n\t\t\t\t\thelpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\n\t\t\t\t} else {\n\t\t\t\t\t// Draw box as legend symbol\n\t\t\t\t\tif (!isLineWidthZero) {\n\t\t\t\t\t\tctx.strokeRect(x, y, boxWidth, fontSize);\n\t\t\t\t\t}\n\t\t\t\t\tctx.fillRect(x, y, boxWidth, fontSize);\n\t\t\t\t}\n\n\t\t\t\tctx.restore();\n\t\t\t};\n\t\t\tvar fillText = function(x, y, legendItem, textWidth) {\n\t\t\t\tvar halfFontSize = fontSize / 2;\n\t\t\t\tvar xLeft = boxWidth + halfFontSize + x;\n\t\t\t\tvar yMiddle = y + halfFontSize;\n\n\t\t\t\tctx.fillText(legendItem.text, xLeft, yMiddle);\n\n\t\t\t\tif (legendItem.hidden) {\n\t\t\t\t\t// Strikethrough the text if hidden\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.lineWidth = 2;\n\t\t\t\t\tctx.moveTo(xLeft, yMiddle);\n\t\t\t\t\tctx.lineTo(xLeft + textWidth, yMiddle);\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Horizontal\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tif (isHorizontal) {\n\t\t\t\tcursor = {\n\t\t\t\t\tx: me.left + ((legendWidth - lineWidths[0]) / 2),\n\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\tline: 0\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tcursor = {\n\t\t\t\t\tx: me.left + labelOpts.padding,\n\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\tline: 0\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tvar itemHeight = fontSize + labelOpts.padding;\n\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\tvar textWidth = ctx.measureText(legendItem.text).width;\n\t\t\t\tvar width = boxWidth + (fontSize / 2) + textWidth;\n\t\t\t\tvar x = cursor.x;\n\t\t\t\tvar y = cursor.y;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tif (x + width >= legendWidth) {\n\t\t\t\t\t\ty = cursor.y += itemHeight;\n\t\t\t\t\t\tcursor.line++;\n\t\t\t\t\t\tx = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);\n\t\t\t\t\t}\n\t\t\t\t} else if (y + itemHeight > me.bottom) {\n\t\t\t\t\tx = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\n\t\t\t\t\ty = cursor.y = me.top + labelOpts.padding;\n\t\t\t\t\tcursor.line++;\n\t\t\t\t}\n\n\t\t\t\tdrawLegendBox(x, y, legendItem);\n\n\t\t\t\thitboxes[i].left = x;\n\t\t\t\thitboxes[i].top = y;\n\n\t\t\t\t// Fill the actual label\n\t\t\t\tfillText(x, y, legendItem, textWidth);\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tcursor.x += width + (labelOpts.padding);\n\t\t\t\t} else {\n\t\t\t\t\tcursor.y += itemHeight;\n\t\t\t\t}\n\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * Handle an event\n\t * @private\n\t * @param {IEvent} event - The event to handle\n\t * @return {Boolean} true if a change occured\n\t */\n\thandleEvent: function(e) {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\t\tvar type = e.type === 'mouseup' ? 'click' : e.type;\n\t\tvar changed = false;\n\n\t\tif (type === 'mousemove') {\n\t\t\tif (!opts.onHover) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (type === 'click') {\n\t\t\tif (!opts.onClick) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\t// Chart event already has relative position in it\n\t\tvar x = e.x;\n\t\tvar y = e.y;\n\n\t\tif (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n\t\t\t// See if we are touching one of the dataset boxes\n\t\t\tvar lh = me.legendHitBoxes;\n\t\t\tfor (var i = 0; i < lh.length; ++i) {\n\t\t\t\tvar hitBox = lh[i];\n\n\t\t\t\tif (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n\t\t\t\t\t// Touching an element\n\t\t\t\t\tif (type === 'click') {\n\t\t\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\t\t\topts.onClick.call(me, e.native, me.legendItems[i]);\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (type === 'mousemove') {\n\t\t\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\t\t\topts.onHover.call(me, e.native, me.legendItems[i]);\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn changed;\n\t}\n});\n\nfunction createNewLegendAndAttach(chart, legendOpts) {\n\tvar legend = new Legend({\n\t\tctx: chart.ctx,\n\t\toptions: legendOpts,\n\t\tchart: chart\n\t});\n\n\tlayouts.configure(chart, legend, legendOpts);\n\tlayouts.addBox(chart, legend);\n\tchart.legend = legend;\n}\n\nmodule.exports = {\n\tid: 'legend',\n\n\t/**\n\t * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making\n\t * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of\n\t * the plugin, which one will be re-exposed in the chart.js file.\n\t * https://github.com/chartjs/Chart.js/pull/2640\n\t * @private\n\t */\n\t_element: Legend,\n\n\tbeforeInit: function(chart) {\n\t\tvar legendOpts = chart.options.legend;\n\n\t\tif (legendOpts) {\n\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\n\t\t}\n\t},\n\n\tbeforeUpdate: function(chart) {\n\t\tvar legendOpts = chart.options.legend;\n\t\tvar legend = chart.legend;\n\n\t\tif (legendOpts) {\n\t\t\thelpers.mergeIf(legendOpts, defaults.global.legend);\n\n\t\t\tif (legend) {\n\t\t\t\tlayouts.configure(chart, legend, legendOpts);\n\t\t\t\tlegend.options = legendOpts;\n\t\t\t} else {\n\t\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\n\t\t\t}\n\t\t} else if (legend) {\n\t\t\tlayouts.removeBox(chart, legend);\n\t\t\tdelete chart.legend;\n\t\t}\n\t},\n\n\tafterEvent: function(chart, e) {\n\t\tvar legend = chart.legend;\n\t\tif (legend) {\n\t\t\tlegend.handleEvent(e);\n\t\t}\n\t}\n};\n\n},{\"../core/core.defaults\":33,\"../core/core.element\":34,\"../core/core.layouts\":38,\"../helpers/index\":53}],60:[function(require,module,exports){\n'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar Element = require('../core/core.element');\nvar helpers = require('../helpers/index');\nvar layouts = require('../core/core.layouts');\n\nvar noop = helpers.noop;\n\ndefaults._set('global', {\n\ttitle: {\n\t\tdisplay: false,\n\t\tfontStyle: 'bold',\n\t\tfullWidth: true,\n\t\tlineHeight: 1.2,\n\t\tpadding: 10,\n\t\tposition: 'top',\n\t\ttext: '',\n\t\tweight: 2000         // by default greater than legend (1000) to be above\n\t}\n});\n\n/**\n * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!\n */\nvar Title = Element.extend({\n\tinitialize: function(config) {\n\t\tvar me = this;\n\t\thelpers.extend(me, config);\n\n\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\tme.legendHitBoxes = [];\n\t},\n\n\t// These methods are ordered by lifecycle. Utilities then follow.\n\n\tbeforeUpdate: noop,\n\tupdate: function(maxWidth, maxHeight, margins) {\n\t\tvar me = this;\n\n\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\tme.beforeUpdate();\n\n\t\t// Absorb the master measurements\n\t\tme.maxWidth = maxWidth;\n\t\tme.maxHeight = maxHeight;\n\t\tme.margins = margins;\n\n\t\t// Dimensions\n\t\tme.beforeSetDimensions();\n\t\tme.setDimensions();\n\t\tme.afterSetDimensions();\n\t\t// Labels\n\t\tme.beforeBuildLabels();\n\t\tme.buildLabels();\n\t\tme.afterBuildLabels();\n\n\t\t// Fit\n\t\tme.beforeFit();\n\t\tme.fit();\n\t\tme.afterFit();\n\t\t//\n\t\tme.afterUpdate();\n\n\t\treturn me.minSize;\n\n\t},\n\tafterUpdate: noop,\n\n\t//\n\n\tbeforeSetDimensions: noop,\n\tsetDimensions: function() {\n\t\tvar me = this;\n\t\t// Set the unconstrained dimension before label rotation\n\t\tif (me.isHorizontal()) {\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.left = 0;\n\t\t\tme.right = me.width;\n\t\t} else {\n\t\t\tme.height = me.maxHeight;\n\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.top = 0;\n\t\t\tme.bottom = me.height;\n\t\t}\n\n\t\t// Reset padding\n\t\tme.paddingLeft = 0;\n\t\tme.paddingTop = 0;\n\t\tme.paddingRight = 0;\n\t\tme.paddingBottom = 0;\n\n\t\t// Reset minSize\n\t\tme.minSize = {\n\t\t\twidth: 0,\n\t\t\theight: 0\n\t\t};\n\t},\n\tafterSetDimensions: noop,\n\n\t//\n\n\tbeforeBuildLabels: noop,\n\tbuildLabels: noop,\n\tafterBuildLabels: noop,\n\n\t//\n\n\tbeforeFit: noop,\n\tfit: function() {\n\t\tvar me = this;\n\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\tvar opts = me.options;\n\t\tvar display = opts.display;\n\t\tvar fontSize = valueOrDefault(opts.fontSize, defaults.global.defaultFontSize);\n\t\tvar minSize = me.minSize;\n\t\tvar lineCount = helpers.isArray(opts.text) ? opts.text.length : 1;\n\t\tvar lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);\n\t\tvar textSize = display ? (lineCount * lineHeight) + (opts.padding * 2) : 0;\n\n\t\tif (me.isHorizontal()) {\n\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\tminSize.height = textSize;\n\t\t} else {\n\t\t\tminSize.width = textSize;\n\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t}\n\n\t\tme.width = minSize.width;\n\t\tme.height = minSize.height;\n\n\t},\n\tafterFit: noop,\n\n\t// Shared Methods\n\tisHorizontal: function() {\n\t\tvar pos = this.options.position;\n\t\treturn pos === 'top' || pos === 'bottom';\n\t},\n\n\t// Actually draw the title block on the canvas\n\tdraw: function() {\n\t\tvar me = this;\n\t\tvar ctx = me.ctx;\n\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\tvar opts = me.options;\n\t\tvar globalDefaults = defaults.global;\n\n\t\tif (opts.display) {\n\t\t\tvar fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize);\n\t\t\tvar fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle);\n\t\t\tvar fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily);\n\t\t\tvar titleFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\t\t\tvar lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);\n\t\t\tvar offset = lineHeight / 2 + opts.padding;\n\t\t\tvar rotation = 0;\n\t\t\tvar top = me.top;\n\t\t\tvar left = me.left;\n\t\t\tvar bottom = me.bottom;\n\t\t\tvar right = me.right;\n\t\t\tvar maxWidth, titleX, titleY;\n\n\t\t\tctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour\n\t\t\tctx.font = titleFont;\n\n\t\t\t// Horizontal\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\ttitleX = left + ((right - left) / 2); // midpoint of the width\n\t\t\t\ttitleY = top + offset;\n\t\t\t\tmaxWidth = right - left;\n\t\t\t} else {\n\t\t\t\ttitleX = opts.position === 'left' ? left + offset : right - offset;\n\t\t\t\ttitleY = top + ((bottom - top) / 2);\n\t\t\t\tmaxWidth = bottom - top;\n\t\t\t\trotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);\n\t\t\t}\n\n\t\t\tctx.save();\n\t\t\tctx.translate(titleX, titleY);\n\t\t\tctx.rotate(rotation);\n\t\t\tctx.textAlign = 'center';\n\t\t\tctx.textBaseline = 'middle';\n\n\t\t\tvar text = opts.text;\n\t\t\tif (helpers.isArray(text)) {\n\t\t\t\tvar y = 0;\n\t\t\t\tfor (var i = 0; i < text.length; ++i) {\n\t\t\t\t\tctx.fillText(text[i], 0, y, maxWidth);\n\t\t\t\t\ty += lineHeight;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tctx.fillText(text, 0, 0, maxWidth);\n\t\t\t}\n\n\t\t\tctx.restore();\n\t\t}\n\t}\n});\n\nfunction createNewTitleBlockAndAttach(chart, titleOpts) {\n\tvar title = new Title({\n\t\tctx: chart.ctx,\n\t\toptions: titleOpts,\n\t\tchart: chart\n\t});\n\n\tlayouts.configure(chart, title, titleOpts);\n\tlayouts.addBox(chart, title);\n\tchart.titleBlock = title;\n}\n\nmodule.exports = {\n\tid: 'title',\n\n\t/**\n\t * Backward compatibility: since 2.1.5, the title is registered as a plugin, making\n\t * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of\n\t * the plugin, which one will be re-exposed in the chart.js file.\n\t * https://github.com/chartjs/Chart.js/pull/2640\n\t * @private\n\t */\n\t_element: Title,\n\n\tbeforeInit: function(chart) {\n\t\tvar titleOpts = chart.options.title;\n\n\t\tif (titleOpts) {\n\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\n\t\t}\n\t},\n\n\tbeforeUpdate: function(chart) {\n\t\tvar titleOpts = chart.options.title;\n\t\tvar titleBlock = chart.titleBlock;\n\n\t\tif (titleOpts) {\n\t\t\thelpers.mergeIf(titleOpts, defaults.global.title);\n\n\t\t\tif (titleBlock) {\n\t\t\t\tlayouts.configure(chart, titleBlock, titleOpts);\n\t\t\t\ttitleBlock.options = titleOpts;\n\t\t\t} else {\n\t\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\n\t\t\t}\n\t\t} else if (titleBlock) {\n\t\t\tlayouts.removeBox(chart, titleBlock);\n\t\t\tdelete chart.titleBlock;\n\t\t}\n\t}\n};\n\n},{\"../core/core.defaults\":33,\"../core/core.element\":34,\"../core/core.layouts\":38,\"../helpers/index\":53}],61:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\t// Default config for a category scale\n\tvar defaultConfig = {\n\t\tposition: 'bottom'\n\t};\n\n\tvar DatasetScale = Chart.Scale.extend({\n\t\t/**\n\t\t* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those\n\t\t* else fall back to data.labels\n\t\t* @private\n\t\t*/\n\t\tgetLabels: function() {\n\t\t\tvar data = this.chart.data;\n\t\t\treturn this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;\n\t\t},\n\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar labels = me.getLabels();\n\t\t\tme.minIndex = 0;\n\t\t\tme.maxIndex = labels.length - 1;\n\t\t\tvar findIndex;\n\n\t\t\tif (me.options.ticks.min !== undefined) {\n\t\t\t\t// user specified min value\n\t\t\t\tfindIndex = labels.indexOf(me.options.ticks.min);\n\t\t\t\tme.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\n\t\t\t}\n\n\t\t\tif (me.options.ticks.max !== undefined) {\n\t\t\t\t// user specified max value\n\t\t\t\tfindIndex = labels.indexOf(me.options.ticks.max);\n\t\t\t\tme.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\n\t\t\t}\n\n\t\t\tme.min = labels[me.minIndex];\n\t\t\tme.max = labels[me.maxIndex];\n\t\t},\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar labels = me.getLabels();\n\t\t\t// If we are viewing some subset of labels, slice the original array\n\t\t\tme.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);\n\t\t},\n\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar data = me.chart.data;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tif (data.yLabels && !isHorizontal) {\n\t\t\t\treturn me.getRightValue(data.datasets[datasetIndex].data[index]);\n\t\t\t}\n\t\t\treturn me.ticks[index - me.minIndex];\n\t\t},\n\n\t\t// Used to get data value locations.  Value can either be an index or a numerical value\n\t\tgetPixelForValue: function(value, index) {\n\t\t\tvar me = this;\n\t\t\tvar offset = me.options.offset;\n\t\t\t// 1 is added because we need the length but we have the indexes\n\t\t\tvar offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1)), 1);\n\n\t\t\t// If value is a data object, then index is the index in the data array,\n\t\t\t// not the index of the scale. We need to change that.\n\t\t\tvar valueCategory;\n\t\t\tif (value !== undefined && value !== null) {\n\t\t\t\tvalueCategory = me.isHorizontal() ? value.x : value.y;\n\t\t\t}\n\t\t\tif (valueCategory !== undefined || (value !== undefined && isNaN(index))) {\n\t\t\t\tvar labels = me.getLabels();\n\t\t\t\tvalue = valueCategory || value;\n\t\t\t\tvar idx = labels.indexOf(value);\n\t\t\t\tindex = idx !== -1 ? idx : index;\n\t\t\t}\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar valueWidth = me.width / offsetAmt;\n\t\t\t\tvar widthOffset = (valueWidth * (index - me.minIndex));\n\n\t\t\t\tif (offset) {\n\t\t\t\t\twidthOffset += (valueWidth / 2);\n\t\t\t\t}\n\n\t\t\t\treturn me.left + Math.round(widthOffset);\n\t\t\t}\n\t\t\tvar valueHeight = me.height / offsetAmt;\n\t\t\tvar heightOffset = (valueHeight * (index - me.minIndex));\n\n\t\t\tif (offset) {\n\t\t\t\theightOffset += (valueHeight / 2);\n\t\t\t}\n\n\t\t\treturn me.top + Math.round(heightOffset);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.ticks[index], index + this.minIndex, null);\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar offset = me.options.offset;\n\t\t\tvar value;\n\t\t\tvar offsetAmt = Math.max((me._ticks.length - (offset ? 0 : 1)), 1);\n\t\t\tvar horz = me.isHorizontal();\n\t\t\tvar valueDimension = (horz ? me.width : me.height) / offsetAmt;\n\n\t\t\tpixel -= horz ? me.left : me.top;\n\n\t\t\tif (offset) {\n\t\t\t\tpixel -= (valueDimension / 2);\n\t\t\t}\n\n\t\t\tif (pixel <= 0) {\n\t\t\t\tvalue = 0;\n\t\t\t} else {\n\t\t\t\tvalue = Math.round(pixel / valueDimension);\n\t\t\t}\n\n\t\t\treturn value + me.minIndex;\n\t\t},\n\t\tgetBasePixel: function() {\n\t\t\treturn this.bottom;\n\t\t}\n\t});\n\n\tChart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);\n\n};\n\n},{}],62:[function(require,module,exports){\n'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar helpers = require('../helpers/index');\nvar Ticks = require('../core/core.ticks');\n\nmodule.exports = function(Chart) {\n\n\tvar defaultConfig = {\n\t\tposition: 'left',\n\t\tticks: {\n\t\t\tcallback: Ticks.formatters.linear\n\t\t}\n\t};\n\n\tvar LinearScale = Chart.LinearScaleBase.extend({\n\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar chart = me.chart;\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar DEFAULT_MIN = 0;\n\t\t\tvar DEFAULT_MAX = 1;\n\n\t\t\tfunction IDMatches(meta) {\n\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t}\n\n\t\t\t// First Calculate the range\n\t\t\tme.min = null;\n\t\t\tme.max = null;\n\n\t\t\tvar hasStacks = opts.stacked;\n\t\t\tif (hasStacks === undefined) {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (hasStacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n\t\t\t\t\t\tmeta.stack !== undefined) {\n\t\t\t\t\t\thasStacks = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (opts.stacked || hasStacks) {\n\t\t\t\tvar valuesPerStack = {};\n\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tvar key = [\n\t\t\t\t\t\tmeta.type,\n\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n\t\t\t\t\t\tmeta.stack\n\t\t\t\t\t].join('.');\n\n\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\tvaluesPerStack[key] = {\n\t\t\t\t\t\t\tpositiveValues: [],\n\t\t\t\t\t\t\tnegativeValues: []\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Store these per type\n\t\t\t\t\tvar positiveValues = valuesPerStack[key].positiveValues;\n\t\t\t\t\tvar negativeValues = valuesPerStack[key].negativeValues;\n\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpositiveValues[index] = positiveValues[index] || 0;\n\t\t\t\t\t\t\tnegativeValues[index] = negativeValues[index] || 0;\n\n\t\t\t\t\t\t\tif (opts.relativePoints) {\n\t\t\t\t\t\t\t\tpositiveValues[index] = 100;\n\t\t\t\t\t\t\t} else if (value < 0) {\n\t\t\t\t\t\t\t\tnegativeValues[index] += value;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpositiveValues[index] += value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thelpers.each(valuesPerStack, function(valuesForType) {\n\t\t\t\t\tvar values = valuesForType.positiveValues.concat(valuesForType.negativeValues);\n\t\t\t\t\tvar minVal = helpers.min(values);\n\t\t\t\t\tvar maxVal = helpers.max(values);\n\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tme.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;\n\t\t\tme.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;\n\n\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\t\tthis.handleTickRangeOptions();\n\t\t},\n\t\tgetTickLimit: function() {\n\t\t\tvar maxTicks;\n\t\t\tvar me = this;\n\t\t\tvar tickOpts = me.options.ticks;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));\n\t\t\t} else {\n\t\t\t\t// The factor of 2 used to scale the font size has been experimentally determined.\n\t\t\t\tvar tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize);\n\t\t\t\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));\n\t\t\t}\n\n\t\t\treturn maxTicks;\n\t\t},\n\t\t// Called after the ticks are built. We need\n\t\thandleDirectionalChanges: function() {\n\t\t\tif (!this.isHorizontal()) {\n\t\t\t\t// We are in a vertical orientation. The top value is the highest. So reverse the array\n\t\t\t\tthis.ticks.reverse();\n\t\t\t}\n\t\t},\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\t// Utils\n\t\tgetPixelForValue: function(value) {\n\t\t\t// This must be called after fit has been run so that\n\t\t\t// this.left, this.top, this.right, and this.bottom have been defined\n\t\t\tvar me = this;\n\t\t\tvar start = me.start;\n\n\t\t\tvar rightValue = +me.getRightValue(value);\n\t\t\tvar pixel;\n\t\t\tvar range = me.end - start;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tpixel = me.left + (me.width / range * (rightValue - start));\n\t\t\t} else {\n\t\t\t\tpixel = me.bottom - (me.height / range * (rightValue - start));\n\t\t\t}\n\t\t\treturn pixel;\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar innerDimension = isHorizontal ? me.width : me.height;\n\t\t\tvar offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;\n\t\t\treturn me.start + ((me.end - me.start) * offset);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.ticksAsNumbers[index]);\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);\n\n};\n\n},{\"../core/core.defaults\":33,\"../core/core.ticks\":42,\"../helpers/index\":53}],63:[function(require,module,exports){\n'use strict';\n\nvar helpers = require('../helpers/index');\n\n/**\n * Generate a set of linear ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {Array<Number>} array of tick values\n */\nfunction generateTicks(generationOptions, dataRange) {\n\tvar ticks = [];\n\t// To get a \"nice\" value for the tick spacing, we will use the appropriately named\n\t// \"nice number\" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n\t// for details.\n\n\tvar spacing;\n\tif (generationOptions.stepSize && generationOptions.stepSize > 0) {\n\t\tspacing = generationOptions.stepSize;\n\t} else {\n\t\tvar niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);\n\t\tspacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);\n\t}\n\tvar niceMin = Math.floor(dataRange.min / spacing) * spacing;\n\tvar niceMax = Math.ceil(dataRange.max / spacing) * spacing;\n\n\t// If min, max and stepSize is set and they make an evenly spaced scale use it.\n\tif (generationOptions.min && generationOptions.max && generationOptions.stepSize) {\n\t\t// If very close to our whole number, use it.\n\t\tif (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {\n\t\t\tniceMin = generationOptions.min;\n\t\t\tniceMax = generationOptions.max;\n\t\t}\n\t}\n\n\tvar numSpaces = (niceMax - niceMin) / spacing;\n\t// If very close to our rounded value, use it.\n\tif (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n\t\tnumSpaces = Math.round(numSpaces);\n\t} else {\n\t\tnumSpaces = Math.ceil(numSpaces);\n\t}\n\n\tvar precision = 1;\n\tif (spacing < 1) {\n\t\tprecision = Math.pow(10, spacing.toString().length - 2);\n\t\tniceMin = Math.round(niceMin * precision) / precision;\n\t\tniceMax = Math.round(niceMax * precision) / precision;\n\t}\n\tticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);\n\tfor (var j = 1; j < numSpaces; ++j) {\n\t\tticks.push(Math.round((niceMin + j * spacing) * precision) / precision);\n\t}\n\tticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);\n\n\treturn ticks;\n}\n\n\nmodule.exports = function(Chart) {\n\n\tvar noop = helpers.noop;\n\n\tChart.LinearScaleBase = Chart.Scale.extend({\n\t\tgetRightValue: function(value) {\n\t\t\tif (typeof value === 'string') {\n\t\t\t\treturn +value;\n\t\t\t}\n\t\t\treturn Chart.Scale.prototype.getRightValue.call(this, value);\n\t\t},\n\n\t\thandleTickRangeOptions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\n\t\t\t// do nothing since that would make the chart weird. If the user really wants a weird chart\n\t\t\t// axis, they can manually override it\n\t\t\tif (tickOpts.beginAtZero) {\n\t\t\t\tvar minSign = helpers.sign(me.min);\n\t\t\t\tvar maxSign = helpers.sign(me.max);\n\n\t\t\t\tif (minSign < 0 && maxSign < 0) {\n\t\t\t\t\t// move the top up to 0\n\t\t\t\t\tme.max = 0;\n\t\t\t\t} else if (minSign > 0 && maxSign > 0) {\n\t\t\t\t\t// move the bottom down to 0\n\t\t\t\t\tme.min = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;\n\t\t\tvar setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;\n\n\t\t\tif (tickOpts.min !== undefined) {\n\t\t\t\tme.min = tickOpts.min;\n\t\t\t} else if (tickOpts.suggestedMin !== undefined) {\n\t\t\t\tif (me.min === null) {\n\t\t\t\t\tme.min = tickOpts.suggestedMin;\n\t\t\t\t} else {\n\t\t\t\t\tme.min = Math.min(me.min, tickOpts.suggestedMin);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tickOpts.max !== undefined) {\n\t\t\t\tme.max = tickOpts.max;\n\t\t\t} else if (tickOpts.suggestedMax !== undefined) {\n\t\t\t\tif (me.max === null) {\n\t\t\t\t\tme.max = tickOpts.suggestedMax;\n\t\t\t\t} else {\n\t\t\t\t\tme.max = Math.max(me.max, tickOpts.suggestedMax);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (setMin !== setMax) {\n\t\t\t\t// We set the min or the max but not both.\n\t\t\t\t// So ensure that our range is good\n\t\t\t\t// Inverted or 0 length range can happen when\n\t\t\t\t// ticks.min is set, and no datasets are visible\n\t\t\t\tif (me.min >= me.max) {\n\t\t\t\t\tif (setMin) {\n\t\t\t\t\t\tme.max = me.min + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tme.min = me.max - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (me.min === me.max) {\n\t\t\t\tme.max++;\n\n\t\t\t\tif (!tickOpts.beginAtZero) {\n\t\t\t\t\tme.min--;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tgetTickLimit: noop,\n\t\thandleDirectionalChanges: noop,\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t// Figure out what the max number of ticks we can support it is based on the size of\n\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t\t\t// the graph. Make sure we always have at least 2 ticks\n\t\t\tvar maxTicks = me.getTickLimit();\n\t\t\tmaxTicks = Math.max(2, maxTicks);\n\n\t\t\tvar numericGeneratorOptions = {\n\t\t\t\tmaxTicks: maxTicks,\n\t\t\t\tmin: tickOpts.min,\n\t\t\t\tmax: tickOpts.max,\n\t\t\t\tstepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\n\t\t\t};\n\t\t\tvar ticks = me.ticks = generateTicks(numericGeneratorOptions, me);\n\n\t\t\tme.handleDirectionalChanges();\n\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers.max(ticks);\n\t\t\tme.min = helpers.min(ticks);\n\n\t\t\tif (tickOpts.reverse) {\n\t\t\t\tticks.reverse();\n\n\t\t\t\tme.start = me.max;\n\t\t\t\tme.end = me.min;\n\t\t\t} else {\n\t\t\t\tme.start = me.min;\n\t\t\t\tme.end = me.max;\n\t\t\t}\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\tme.ticksAsNumbers = me.ticks.slice();\n\t\t\tme.zeroLineIndex = me.ticks.indexOf(0);\n\n\t\t\tChart.Scale.prototype.convertTicksToLabels.call(me);\n\t\t}\n\t});\n};\n\n},{\"../helpers/index\":53}],64:[function(require,module,exports){\n'use strict';\n\nvar helpers = require('../helpers/index');\nvar Ticks = require('../core/core.ticks');\n\n/**\n * Generate a set of logarithmic ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {Array<Number>} array of tick values\n */\nfunction generateTicks(generationOptions, dataRange) {\n\tvar ticks = [];\n\tvar valueOrDefault = helpers.valueOrDefault;\n\n\t// Figure out what the max number of ticks we can support it is based on the size of\n\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t// the graph\n\tvar tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));\n\n\tvar endExp = Math.floor(helpers.log10(dataRange.max));\n\tvar endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n\tvar exp, significand;\n\n\tif (tickVal === 0) {\n\t\texp = Math.floor(helpers.log10(dataRange.minNotZero));\n\t\tsignificand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\n\n\t\tticks.push(tickVal);\n\t\ttickVal = significand * Math.pow(10, exp);\n\t} else {\n\t\texp = Math.floor(helpers.log10(tickVal));\n\t\tsignificand = Math.floor(tickVal / Math.pow(10, exp));\n\t}\n\tvar precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n\n\tdo {\n\t\tticks.push(tickVal);\n\n\t\t++significand;\n\t\tif (significand === 10) {\n\t\t\tsignificand = 1;\n\t\t\t++exp;\n\t\t\tprecision = exp >= 0 ? 1 : precision;\n\t\t}\n\n\t\ttickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n\t} while (exp < endExp || (exp === endExp && significand < endSignificand));\n\n\tvar lastTick = valueOrDefault(generationOptions.max, tickVal);\n\tticks.push(lastTick);\n\n\treturn ticks;\n}\n\n\nmodule.exports = function(Chart) {\n\n\tvar defaultConfig = {\n\t\tposition: 'left',\n\n\t\t// label settings\n\t\tticks: {\n\t\t\tcallback: Ticks.formatters.logarithmic\n\t\t}\n\t};\n\n\tvar LogarithmicScale = Chart.Scale.extend({\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar chart = me.chart;\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tfunction IDMatches(meta) {\n\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t}\n\n\t\t\t// Calculate Range\n\t\t\tme.min = null;\n\t\t\tme.max = null;\n\t\t\tme.minNotZero = null;\n\n\t\t\tvar hasStacks = opts.stacked;\n\t\t\tif (hasStacks === undefined) {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (hasStacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n\t\t\t\t\t\tmeta.stack !== undefined) {\n\t\t\t\t\t\thasStacks = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (opts.stacked || hasStacks) {\n\t\t\t\tvar valuesPerStack = {};\n\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tvar key = [\n\t\t\t\t\t\tmeta.type,\n\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n\t\t\t\t\t\tmeta.stack\n\t\t\t\t\t].join('.');\n\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\t\tvaluesPerStack[key] = [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar values = valuesPerStack[key];\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\t// invalid, hidden and negative values are ignored\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden || value < 0) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvalues[index] = values[index] || 0;\n\t\t\t\t\t\t\tvalues[index] += value;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thelpers.each(valuesPerStack, function(valuesForType) {\n\t\t\t\t\tif (valuesForType.length > 0) {\n\t\t\t\t\t\tvar minVal = helpers.min(valuesForType);\n\t\t\t\t\t\tvar maxVal = helpers.max(valuesForType);\n\t\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\t// invalid, hidden and negative values are ignored\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden || value < 0) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\n\t\t\t\t\t\t\t\tme.minNotZero = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Common base implementation to handle ticks.min, ticks.max\n\t\t\tthis.handleTickRangeOptions();\n\t\t},\n\t\thandleTickRangeOptions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\t\tvar DEFAULT_MIN = 1;\n\t\t\tvar DEFAULT_MAX = 10;\n\n\t\t\tme.min = valueOrDefault(tickOpts.min, me.min);\n\t\t\tme.max = valueOrDefault(tickOpts.max, me.max);\n\n\t\t\tif (me.min === me.max) {\n\t\t\t\tif (me.min !== 0 && me.min !== null) {\n\t\t\t\t\tme.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);\n\t\t\t\t\tme.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);\n\t\t\t\t} else {\n\t\t\t\t\tme.min = DEFAULT_MIN;\n\t\t\t\t\tme.max = DEFAULT_MAX;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (me.min === null) {\n\t\t\t\tme.min = Math.pow(10, Math.floor(helpers.log10(me.max)) - 1);\n\t\t\t}\n\t\t\tif (me.max === null) {\n\t\t\t\tme.max = me.min !== 0\n\t\t\t\t\t? Math.pow(10, Math.floor(helpers.log10(me.min)) + 1)\n\t\t\t\t\t: DEFAULT_MAX;\n\t\t\t}\n\t\t\tif (me.minNotZero === null) {\n\t\t\t\tif (me.min > 0) {\n\t\t\t\t\tme.minNotZero = me.min;\n\t\t\t\t} else if (me.max < 1) {\n\t\t\t\t\tme.minNotZero = Math.pow(10, Math.floor(helpers.log10(me.max)));\n\t\t\t\t} else {\n\t\t\t\t\tme.minNotZero = DEFAULT_MIN;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar reverse = !me.isHorizontal();\n\n\t\t\tvar generationOptions = {\n\t\t\t\tmin: tickOpts.min,\n\t\t\t\tmax: tickOpts.max\n\t\t\t};\n\t\t\tvar ticks = me.ticks = generateTicks(generationOptions, me);\n\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers.max(ticks);\n\t\t\tme.min = helpers.min(ticks);\n\n\t\t\tif (tickOpts.reverse) {\n\t\t\t\treverse = !reverse;\n\t\t\t\tme.start = me.max;\n\t\t\t\tme.end = me.min;\n\t\t\t} else {\n\t\t\t\tme.start = me.min;\n\t\t\t\tme.end = me.max;\n\t\t\t}\n\t\t\tif (reverse) {\n\t\t\t\tticks.reverse();\n\t\t\t}\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tthis.tickValues = this.ticks.slice();\n\n\t\t\tChart.Scale.prototype.convertTicksToLabels.call(this);\n\t\t},\n\t\t// Get the correct tooltip label\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.tickValues[index]);\n\t\t},\n\t\t/**\n\t\t * Returns the value of the first tick.\n\t\t * @param {Number} value - The minimum not zero value.\n\t\t * @return {Number} The first tick value.\n\t\t * @private\n\t\t */\n\t\t_getFirstTickValue: function(value) {\n\t\t\tvar exp = Math.floor(helpers.log10(value));\n\t\t\tvar significand = Math.floor(value / Math.pow(10, exp));\n\n\t\t\treturn significand * Math.pow(10, exp);\n\t\t},\n\t\tgetPixelForValue: function(value) {\n\t\t\tvar me = this;\n\t\t\tvar reverse = me.options.ticks.reverse;\n\t\t\tvar log10 = helpers.log10;\n\t\t\tvar firstTickValue = me._getFirstTickValue(me.minNotZero);\n\t\t\tvar offset = 0;\n\t\t\tvar innerDimension, pixel, start, end, sign;\n\n\t\t\tvalue = +me.getRightValue(value);\n\t\t\tif (reverse) {\n\t\t\t\tstart = me.end;\n\t\t\t\tend = me.start;\n\t\t\t\tsign = -1;\n\t\t\t} else {\n\t\t\t\tstart = me.start;\n\t\t\t\tend = me.end;\n\t\t\t\tsign = 1;\n\t\t\t}\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tinnerDimension = me.width;\n\t\t\t\tpixel = reverse ? me.right : me.left;\n\t\t\t} else {\n\t\t\t\tinnerDimension = me.height;\n\t\t\t\tsign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)\n\t\t\t\tpixel = reverse ? me.top : me.bottom;\n\t\t\t}\n\t\t\tif (value !== start) {\n\t\t\t\tif (start === 0) { // include zero tick\n\t\t\t\t\toffset = helpers.getValueOrDefault(\n\t\t\t\t\t\tme.options.ticks.fontSize,\n\t\t\t\t\t\tChart.defaults.global.defaultFontSize\n\t\t\t\t\t);\n\t\t\t\t\tinnerDimension -= offset;\n\t\t\t\t\tstart = firstTickValue;\n\t\t\t\t}\n\t\t\t\tif (value !== 0) {\n\t\t\t\t\toffset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));\n\t\t\t\t}\n\t\t\t\tpixel += sign * offset;\n\t\t\t}\n\t\t\treturn pixel;\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar reverse = me.options.ticks.reverse;\n\t\t\tvar log10 = helpers.log10;\n\t\t\tvar firstTickValue = me._getFirstTickValue(me.minNotZero);\n\t\t\tvar innerDimension, start, end, value;\n\n\t\t\tif (reverse) {\n\t\t\t\tstart = me.end;\n\t\t\t\tend = me.start;\n\t\t\t} else {\n\t\t\t\tstart = me.start;\n\t\t\t\tend = me.end;\n\t\t\t}\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tinnerDimension = me.width;\n\t\t\t\tvalue = reverse ? me.right - pixel : pixel - me.left;\n\t\t\t} else {\n\t\t\t\tinnerDimension = me.height;\n\t\t\t\tvalue = reverse ? pixel - me.top : me.bottom - pixel;\n\t\t\t}\n\t\t\tif (value !== start) {\n\t\t\t\tif (start === 0) { // include zero tick\n\t\t\t\t\tvar offset = helpers.getValueOrDefault(\n\t\t\t\t\t\tme.options.ticks.fontSize,\n\t\t\t\t\t\tChart.defaults.global.defaultFontSize\n\t\t\t\t\t);\n\t\t\t\t\tvalue -= offset;\n\t\t\t\t\tinnerDimension -= offset;\n\t\t\t\t\tstart = firstTickValue;\n\t\t\t\t}\n\t\t\t\tvalue *= log10(end) - log10(start);\n\t\t\t\tvalue /= innerDimension;\n\t\t\t\tvalue = Math.pow(10, log10(start) + value);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);\n\n};\n\n},{\"../core/core.ticks\":42,\"../helpers/index\":53}],65:[function(require,module,exports){\n'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar helpers = require('../helpers/index');\nvar Ticks = require('../core/core.ticks');\n\nmodule.exports = function(Chart) {\n\n\tvar globalDefaults = defaults.global;\n\n\tvar defaultConfig = {\n\t\tdisplay: true,\n\n\t\t// Boolean - Whether to animate scaling the chart from the centre\n\t\tanimate: true,\n\t\tposition: 'chartArea',\n\n\t\tangleLines: {\n\t\t\tdisplay: true,\n\t\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\t\tlineWidth: 1\n\t\t},\n\n\t\tgridLines: {\n\t\t\tcircular: false\n\t\t},\n\n\t\t// label settings\n\t\tticks: {\n\t\t\t// Boolean - Show a backdrop to the scale label\n\t\t\tshowLabelBackdrop: true,\n\n\t\t\t// String - The colour of the label backdrop\n\t\t\tbackdropColor: 'rgba(255,255,255,0.75)',\n\n\t\t\t// Number - The backdrop padding above & below the label in pixels\n\t\t\tbackdropPaddingY: 2,\n\n\t\t\t// Number - The backdrop padding to the side of the label in pixels\n\t\t\tbackdropPaddingX: 2,\n\n\t\t\tcallback: Ticks.formatters.linear\n\t\t},\n\n\t\tpointLabels: {\n\t\t\t// Boolean - if true, show point labels\n\t\t\tdisplay: true,\n\n\t\t\t// Number - Point label font size in pixels\n\t\t\tfontSize: 10,\n\n\t\t\t// Function - Used to convert point labels\n\t\t\tcallback: function(label) {\n\t\t\t\treturn label;\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction getValueCount(scale) {\n\t\tvar opts = scale.options;\n\t\treturn opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;\n\t}\n\n\tfunction getPointLabelFontOptions(scale) {\n\t\tvar pointLabelOptions = scale.options.pointLabels;\n\t\tvar fontSize = helpers.valueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);\n\t\tvar fontStyle = helpers.valueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);\n\t\tvar fontFamily = helpers.valueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);\n\t\tvar font = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\treturn {\n\t\t\tsize: fontSize,\n\t\t\tstyle: fontStyle,\n\t\t\tfamily: fontFamily,\n\t\t\tfont: font\n\t\t};\n\t}\n\n\tfunction measureLabelSize(ctx, fontSize, label) {\n\t\tif (helpers.isArray(label)) {\n\t\t\treturn {\n\t\t\t\tw: helpers.longestText(ctx, ctx.font, label),\n\t\t\t\th: (label.length * fontSize) + ((label.length - 1) * 1.5 * fontSize)\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tw: ctx.measureText(label).width,\n\t\t\th: fontSize\n\t\t};\n\t}\n\n\tfunction determineLimits(angle, pos, size, min, max) {\n\t\tif (angle === min || angle === max) {\n\t\t\treturn {\n\t\t\t\tstart: pos - (size / 2),\n\t\t\t\tend: pos + (size / 2)\n\t\t\t};\n\t\t} else if (angle < min || angle > max) {\n\t\t\treturn {\n\t\t\t\tstart: pos - size - 5,\n\t\t\t\tend: pos\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tstart: pos,\n\t\t\tend: pos + size + 5\n\t\t};\n\t}\n\n\t/**\n\t * Helper function to fit a radial linear scale with point labels\n\t */\n\tfunction fitWithPointLabels(scale) {\n\t\t/*\n\t\t * Right, this is really confusing and there is a lot of maths going on here\n\t\t * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n\t\t *\n\t\t * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n\t\t *\n\t\t * Solution:\n\t\t *\n\t\t * We assume the radius of the polygon is half the size of the canvas at first\n\t\t * at each index we check if the text overlaps.\n\t\t *\n\t\t * Where it does, we store that angle and that index.\n\t\t *\n\t\t * After finding the largest index and angle we calculate how much we need to remove\n\t\t * from the shape radius to move the point inwards by that x.\n\t\t *\n\t\t * We average the left and right distances to get the maximum shape radius that can fit in the box\n\t\t * along with labels.\n\t\t *\n\t\t * Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n\t\t * on each side, removing that from the size, halving it and adding the left x protrusion width.\n\t\t *\n\t\t * This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n\t\t * and position it in the most space efficient manner\n\t\t *\n\t\t * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n\t\t */\n\n\t\tvar plFont = getPointLabelFontOptions(scale);\n\n\t\t// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n\t\t// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n\t\tvar largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n\t\tvar furthestLimits = {\n\t\t\tr: scale.width,\n\t\t\tl: 0,\n\t\t\tt: scale.height,\n\t\t\tb: 0\n\t\t};\n\t\tvar furthestAngles = {};\n\t\tvar i, textSize, pointPosition;\n\n\t\tscale.ctx.font = plFont.font;\n\t\tscale._pointLabelSizes = [];\n\n\t\tvar valueCount = getValueCount(scale);\n\t\tfor (i = 0; i < valueCount; i++) {\n\t\t\tpointPosition = scale.getPointPosition(i, largestPossibleRadius);\n\t\t\ttextSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');\n\t\t\tscale._pointLabelSizes[i] = textSize;\n\n\t\t\t// Add quarter circle to make degree 0 mean top of circle\n\t\t\tvar angleRadians = scale.getIndexAngle(i);\n\t\t\tvar angle = helpers.toDegrees(angleRadians) % 360;\n\t\t\tvar hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n\t\t\tvar vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n\n\t\t\tif (hLimits.start < furthestLimits.l) {\n\t\t\t\tfurthestLimits.l = hLimits.start;\n\t\t\t\tfurthestAngles.l = angleRadians;\n\t\t\t}\n\n\t\t\tif (hLimits.end > furthestLimits.r) {\n\t\t\t\tfurthestLimits.r = hLimits.end;\n\t\t\t\tfurthestAngles.r = angleRadians;\n\t\t\t}\n\n\t\t\tif (vLimits.start < furthestLimits.t) {\n\t\t\t\tfurthestLimits.t = vLimits.start;\n\t\t\t\tfurthestAngles.t = angleRadians;\n\t\t\t}\n\n\t\t\tif (vLimits.end > furthestLimits.b) {\n\t\t\t\tfurthestLimits.b = vLimits.end;\n\t\t\t\tfurthestAngles.b = angleRadians;\n\t\t\t}\n\t\t}\n\n\t\tscale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);\n\t}\n\n\t/**\n\t * Helper function to fit a radial linear scale with no point labels\n\t */\n\tfunction fit(scale) {\n\t\tvar largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n\t\tscale.drawingArea = Math.round(largestPossibleRadius);\n\t\tscale.setCenterPoint(0, 0, 0, 0);\n\t}\n\n\tfunction getTextAlignForAngle(angle) {\n\t\tif (angle === 0 || angle === 180) {\n\t\t\treturn 'center';\n\t\t} else if (angle < 180) {\n\t\t\treturn 'left';\n\t\t}\n\n\t\treturn 'right';\n\t}\n\n\tfunction fillText(ctx, text, position, fontSize) {\n\t\tif (helpers.isArray(text)) {\n\t\t\tvar y = position.y;\n\t\t\tvar spacing = 1.5 * fontSize;\n\n\t\t\tfor (var i = 0; i < text.length; ++i) {\n\t\t\t\tctx.fillText(text[i], position.x, y);\n\t\t\t\ty += spacing;\n\t\t\t}\n\t\t} else {\n\t\t\tctx.fillText(text, position.x, position.y);\n\t\t}\n\t}\n\n\tfunction adjustPointPositionForLabelHeight(angle, textSize, position) {\n\t\tif (angle === 90 || angle === 270) {\n\t\t\tposition.y -= (textSize.h / 2);\n\t\t} else if (angle > 270 || angle < 90) {\n\t\t\tposition.y -= textSize.h;\n\t\t}\n\t}\n\n\tfunction drawPointLabels(scale) {\n\t\tvar ctx = scale.ctx;\n\t\tvar opts = scale.options;\n\t\tvar angleLineOpts = opts.angleLines;\n\t\tvar pointLabelOpts = opts.pointLabels;\n\n\t\tctx.lineWidth = angleLineOpts.lineWidth;\n\t\tctx.strokeStyle = angleLineOpts.color;\n\n\t\tvar outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);\n\n\t\t// Point Label Font\n\t\tvar plFont = getPointLabelFontOptions(scale);\n\n\t\tctx.textBaseline = 'top';\n\n\t\tfor (var i = getValueCount(scale) - 1; i >= 0; i--) {\n\t\t\tif (angleLineOpts.display) {\n\t\t\t\tvar outerPosition = scale.getPointPosition(i, outerDistance);\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(scale.xCenter, scale.yCenter);\n\t\t\t\tctx.lineTo(outerPosition.x, outerPosition.y);\n\t\t\t\tctx.stroke();\n\t\t\t\tctx.closePath();\n\t\t\t}\n\n\t\t\tif (pointLabelOpts.display) {\n\t\t\t\t// Extra 3px out for some label spacing\n\t\t\t\tvar pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);\n\n\t\t\t\t// Keep this in loop since we may support array properties here\n\t\t\t\tvar pointLabelFontColor = helpers.valueAtIndexOrDefault(pointLabelOpts.fontColor, i, globalDefaults.defaultFontColor);\n\t\t\t\tctx.font = plFont.font;\n\t\t\t\tctx.fillStyle = pointLabelFontColor;\n\n\t\t\t\tvar angleRadians = scale.getIndexAngle(i);\n\t\t\t\tvar angle = helpers.toDegrees(angleRadians);\n\t\t\t\tctx.textAlign = getTextAlignForAngle(angle);\n\t\t\t\tadjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\n\t\t\t\tfillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction drawRadiusLine(scale, gridLineOpts, radius, index) {\n\t\tvar ctx = scale.ctx;\n\t\tctx.strokeStyle = helpers.valueAtIndexOrDefault(gridLineOpts.color, index - 1);\n\t\tctx.lineWidth = helpers.valueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);\n\n\t\tif (scale.options.gridLines.circular) {\n\t\t\t// Draw circular arcs between the points\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);\n\t\t\tctx.closePath();\n\t\t\tctx.stroke();\n\t\t} else {\n\t\t\t// Draw straight lines connecting each index\n\t\t\tvar valueCount = getValueCount(scale);\n\n\t\t\tif (valueCount === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tctx.beginPath();\n\t\t\tvar pointPosition = scale.getPointPosition(0, radius);\n\t\t\tctx.moveTo(pointPosition.x, pointPosition.y);\n\n\t\t\tfor (var i = 1; i < valueCount; i++) {\n\t\t\t\tpointPosition = scale.getPointPosition(i, radius);\n\t\t\t\tctx.lineTo(pointPosition.x, pointPosition.y);\n\t\t\t}\n\n\t\t\tctx.closePath();\n\t\t\tctx.stroke();\n\t\t}\n\t}\n\n\tfunction numberOrZero(param) {\n\t\treturn helpers.isNumber(param) ? param : 0;\n\t}\n\n\tvar LinearRadialScale = Chart.LinearScaleBase.extend({\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.height = me.maxHeight;\n\t\t\tme.xCenter = Math.round(me.width / 2);\n\t\t\tme.yCenter = Math.round(me.height / 2);\n\n\t\t\tvar minSize = helpers.min([me.height, me.width]);\n\t\t\tvar tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\tme.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);\n\t\t},\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar min = Number.POSITIVE_INFINITY;\n\t\t\tvar max = Number.NEGATIVE_INFINITY;\n\n\t\t\thelpers.each(chart.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\n\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmin = Math.min(value, min);\n\t\t\t\t\t\tmax = Math.max(value, max);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tme.min = (min === Number.POSITIVE_INFINITY ? 0 : min);\n\t\t\tme.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);\n\n\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\t\tme.handleTickRangeOptions();\n\t\t},\n\t\tgetTickLimit: function() {\n\t\t\tvar tickOpts = this.options.ticks;\n\t\t\tvar tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\treturn Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\n\t\t\tChart.LinearScaleBase.prototype.convertTicksToLabels.call(me);\n\n\t\t\t// Point labels\n\t\t\tme.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);\n\t\t},\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\tfit: function() {\n\t\t\tif (this.options.pointLabels.display) {\n\t\t\t\tfitWithPointLabels(this);\n\t\t\t} else {\n\t\t\t\tfit(this);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Set radius reductions and determine new radius and center point\n\t\t * @private\n\t\t */\n\t\tsetReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {\n\t\t\tvar me = this;\n\t\t\tvar radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\n\t\t\tvar radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\n\t\t\tvar radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\n\t\t\tvar radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);\n\n\t\t\tradiusReductionLeft = numberOrZero(radiusReductionLeft);\n\t\t\tradiusReductionRight = numberOrZero(radiusReductionRight);\n\t\t\tradiusReductionTop = numberOrZero(radiusReductionTop);\n\t\t\tradiusReductionBottom = numberOrZero(radiusReductionBottom);\n\n\t\t\tme.drawingArea = Math.min(\n\t\t\t\tMath.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),\n\t\t\t\tMath.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\n\t\t\tme.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\n\t\t},\n\t\tsetCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {\n\t\t\tvar me = this;\n\t\t\tvar maxRight = me.width - rightMovement - me.drawingArea;\n\t\t\tvar maxLeft = leftMovement + me.drawingArea;\n\t\t\tvar maxTop = topMovement + me.drawingArea;\n\t\t\tvar maxBottom = me.height - bottomMovement - me.drawingArea;\n\n\t\t\tme.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);\n\t\t\tme.yCenter = Math.round(((maxTop + maxBottom) / 2) + me.top);\n\t\t},\n\n\t\tgetIndexAngle: function(index) {\n\t\t\tvar angleMultiplier = (Math.PI * 2) / getValueCount(this);\n\t\t\tvar startAngle = this.chart.options && this.chart.options.startAngle ?\n\t\t\t\tthis.chart.options.startAngle :\n\t\t\t\t0;\n\n\t\t\tvar startAngleRadians = startAngle * Math.PI * 2 / 360;\n\n\t\t\t// Start from the top instead of right, so remove a quarter of the circle\n\t\t\treturn index * angleMultiplier + startAngleRadians;\n\t\t},\n\t\tgetDistanceFromCenterForValue: function(value) {\n\t\t\tvar me = this;\n\n\t\t\tif (value === null) {\n\t\t\t\treturn 0; // null always in center\n\t\t\t}\n\n\t\t\t// Take into account half font size + the yPadding of the top value\n\t\t\tvar scalingFactor = me.drawingArea / (me.max - me.min);\n\t\t\tif (me.options.ticks.reverse) {\n\t\t\t\treturn (me.max - value) * scalingFactor;\n\t\t\t}\n\t\t\treturn (value - me.min) * scalingFactor;\n\t\t},\n\t\tgetPointPosition: function(index, distanceFromCenter) {\n\t\t\tvar me = this;\n\t\t\tvar thisAngle = me.getIndexAngle(index) - (Math.PI / 2);\n\t\t\treturn {\n\t\t\t\tx: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,\n\t\t\t\ty: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter\n\t\t\t};\n\t\t},\n\t\tgetPointPositionForValue: function(index, value) {\n\t\t\treturn this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n\t\t},\n\n\t\tgetBasePosition: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\n\t\t\treturn me.getPointPositionForValue(0,\n\t\t\t\tme.beginAtZero ? 0 :\n\t\t\t\tmin < 0 && max < 0 ? max :\n\t\t\t\tmin > 0 && max > 0 ? min :\n\t\t\t\t0);\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar gridLineOpts = opts.gridLines;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar valueOrDefault = helpers.valueOrDefault;\n\n\t\t\tif (opts.display) {\n\t\t\t\tvar ctx = me.ctx;\n\t\t\t\tvar startAngle = this.getIndexAngle(0);\n\n\t\t\t\t// Tick Font\n\t\t\t\tvar tickFontSize = valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\t\tvar tickFontStyle = valueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);\n\t\t\t\tvar tickFontFamily = valueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);\n\t\t\t\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\n\n\t\t\t\thelpers.each(me.ticks, function(label, index) {\n\t\t\t\t\t// Don't draw a centre value (if it is minimum)\n\t\t\t\t\tif (index > 0 || tickOpts.reverse) {\n\t\t\t\t\t\tvar yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\n\n\t\t\t\t\t\t// Draw circular lines around the scale\n\t\t\t\t\t\tif (gridLineOpts.display && index !== 0) {\n\t\t\t\t\t\t\tdrawRadiusLine(me, gridLineOpts, yCenterOffset, index);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (tickOpts.display) {\n\t\t\t\t\t\t\tvar tickFontColor = valueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);\n\t\t\t\t\t\t\tctx.font = tickLabelFont;\n\n\t\t\t\t\t\t\tctx.save();\n\t\t\t\t\t\t\tctx.translate(me.xCenter, me.yCenter);\n\t\t\t\t\t\t\tctx.rotate(startAngle);\n\n\t\t\t\t\t\t\tif (tickOpts.showLabelBackdrop) {\n\t\t\t\t\t\t\t\tvar labelWidth = ctx.measureText(label).width;\n\t\t\t\t\t\t\t\tctx.fillStyle = tickOpts.backdropColor;\n\t\t\t\t\t\t\t\tctx.fillRect(\n\t\t\t\t\t\t\t\t\t-labelWidth / 2 - tickOpts.backdropPaddingX,\n\t\t\t\t\t\t\t\t\t-yCenterOffset - tickFontSize / 2 - tickOpts.backdropPaddingY,\n\t\t\t\t\t\t\t\t\tlabelWidth + tickOpts.backdropPaddingX * 2,\n\t\t\t\t\t\t\t\t\ttickFontSize + tickOpts.backdropPaddingY * 2\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tctx.textAlign = 'center';\n\t\t\t\t\t\t\tctx.textBaseline = 'middle';\n\t\t\t\t\t\t\tctx.fillStyle = tickFontColor;\n\t\t\t\t\t\t\tctx.fillText(label, 0, -yCenterOffset);\n\t\t\t\t\t\t\tctx.restore();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (opts.angleLines.display || opts.pointLabels.display) {\n\t\t\t\t\tdrawPointLabels(me);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);\n\n};\n\n},{\"../core/core.defaults\":33,\"../core/core.ticks\":42,\"../helpers/index\":53}],66:[function(require,module,exports){\n/* global window: false */\n'use strict';\n\nvar moment = require('moment');\nmoment = typeof moment === 'function' ? moment : window.moment;\n\nvar defaults = require('../core/core.defaults');\nvar helpers = require('../helpers/index');\n\n// Integer constants are from the ES6 spec.\nvar MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;\nvar MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\nvar INTERVALS = {\n\tmillisecond: {\n\t\tcommon: true,\n\t\tsize: 1,\n\t\tsteps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n\t},\n\tsecond: {\n\t\tcommon: true,\n\t\tsize: 1000,\n\t\tsteps: [1, 2, 5, 10, 30]\n\t},\n\tminute: {\n\t\tcommon: true,\n\t\tsize: 60000,\n\t\tsteps: [1, 2, 5, 10, 30]\n\t},\n\thour: {\n\t\tcommon: true,\n\t\tsize: 3600000,\n\t\tsteps: [1, 2, 3, 6, 12]\n\t},\n\tday: {\n\t\tcommon: true,\n\t\tsize: 86400000,\n\t\tsteps: [1, 2, 5]\n\t},\n\tweek: {\n\t\tcommon: false,\n\t\tsize: 604800000,\n\t\tsteps: [1, 2, 3, 4]\n\t},\n\tmonth: {\n\t\tcommon: true,\n\t\tsize: 2.628e9,\n\t\tsteps: [1, 2, 3]\n\t},\n\tquarter: {\n\t\tcommon: false,\n\t\tsize: 7.884e9,\n\t\tsteps: [1, 2, 3, 4]\n\t},\n\tyear: {\n\t\tcommon: true,\n\t\tsize: 3.154e10\n\t}\n};\n\nvar UNITS = Object.keys(INTERVALS);\n\nfunction sorter(a, b) {\n\treturn a - b;\n}\n\nfunction arrayUnique(items) {\n\tvar hash = {};\n\tvar out = [];\n\tvar i, ilen, item;\n\n\tfor (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\titem = items[i];\n\t\tif (!hash[item]) {\n\t\t\thash[item] = true;\n\t\t\tout.push(item);\n\t\t}\n\t}\n\n\treturn out;\n}\n\n/**\n * Returns an array of {time, pos} objects used to interpolate a specific `time` or position\n * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is\n * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other\n * extremity (left + width or top + height). Note that it would be more optimized to directly\n * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need\n * to create the lookup table. The table ALWAYS contains at least two items: min and max.\n *\n * @param {Number[]} timestamps - timestamps sorted from lowest to highest.\n * @param {String} distribution - If 'linear', timestamps will be spread linearly along the min\n * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.\n * If 'series', timestamps will be positioned at the same distance from each other. In this\n * case, only timestamps that break the time linearity are registered, meaning that in the\n * best case, all timestamps are linear, the table contains only min and max.\n */\nfunction buildLookupTable(timestamps, min, max, distribution) {\n\tif (distribution === 'linear' || !timestamps.length) {\n\t\treturn [\n\t\t\t{time: min, pos: 0},\n\t\t\t{time: max, pos: 1}\n\t\t];\n\t}\n\n\tvar table = [];\n\tvar items = [min];\n\tvar i, ilen, prev, curr, next;\n\n\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n\t\tcurr = timestamps[i];\n\t\tif (curr > min && curr < max) {\n\t\t\titems.push(curr);\n\t\t}\n\t}\n\n\titems.push(max);\n\n\tfor (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\tnext = items[i + 1];\n\t\tprev = items[i - 1];\n\t\tcurr = items[i];\n\n\t\t// only add points that breaks the scale linearity\n\t\tif (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {\n\t\t\ttable.push({time: curr, pos: i / (ilen - 1)});\n\t\t}\n\t}\n\n\treturn table;\n}\n\n// @see adapted from http://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/\nfunction lookup(table, key, value) {\n\tvar lo = 0;\n\tvar hi = table.length - 1;\n\tvar mid, i0, i1;\n\n\twhile (lo >= 0 && lo <= hi) {\n\t\tmid = (lo + hi) >> 1;\n\t\ti0 = table[mid - 1] || null;\n\t\ti1 = table[mid];\n\n\t\tif (!i0) {\n\t\t\t// given value is outside table (before first item)\n\t\t\treturn {lo: null, hi: i1};\n\t\t} else if (i1[key] < value) {\n\t\t\tlo = mid + 1;\n\t\t} else if (i0[key] > value) {\n\t\t\thi = mid - 1;\n\t\t} else {\n\t\t\treturn {lo: i0, hi: i1};\n\t\t}\n\t}\n\n\t// given value is outside table (after last item)\n\treturn {lo: i1, hi: null};\n}\n\n/**\n * Linearly interpolates the given source `value` using the table items `skey` values and\n * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')\n * returns the position for a timestamp equal to 42. If value is out of bounds, values at\n * index [0, 1] or [n - 1, n] are used for the interpolation.\n */\nfunction interpolate(table, skey, sval, tkey) {\n\tvar range = lookup(table, skey, sval);\n\n\t// Note: the lookup table ALWAYS contains at least 2 items (min and max)\n\tvar prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;\n\tvar next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;\n\n\tvar span = next[skey] - prev[skey];\n\tvar ratio = span ? (sval - prev[skey]) / span : 0;\n\tvar offset = (next[tkey] - prev[tkey]) * ratio;\n\n\treturn prev[tkey] + offset;\n}\n\n/**\n * Convert the given value to a moment object using the given time options.\n * @see http://momentjs.com/docs/#/parsing/\n */\nfunction momentify(value, options) {\n\tvar parser = options.parser;\n\tvar format = options.parser || options.format;\n\n\tif (typeof parser === 'function') {\n\t\treturn parser(value);\n\t}\n\n\tif (typeof value === 'string' && typeof format === 'string') {\n\t\treturn moment(value, format);\n\t}\n\n\tif (!(value instanceof moment)) {\n\t\tvalue = moment(value);\n\t}\n\n\tif (value.isValid()) {\n\t\treturn value;\n\t}\n\n\t// Labels are in an incompatible moment format and no `parser` has been provided.\n\t// The user might still use the deprecated `format` option to convert his inputs.\n\tif (typeof format === 'function') {\n\t\treturn format(value);\n\t}\n\n\treturn value;\n}\n\nfunction parse(input, scale) {\n\tif (helpers.isNullOrUndef(input)) {\n\t\treturn null;\n\t}\n\n\tvar options = scale.options.time;\n\tvar value = momentify(scale.getRightValue(input), options);\n\tif (!value.isValid()) {\n\t\treturn null;\n\t}\n\n\tif (options.round) {\n\t\tvalue.startOf(options.round);\n\t}\n\n\treturn value.valueOf();\n}\n\n/**\n * Returns the number of unit to skip to be able to display up to `capacity` number of ticks\n * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.\n */\nfunction determineStepSize(min, max, unit, capacity) {\n\tvar range = max - min;\n\tvar interval = INTERVALS[unit];\n\tvar milliseconds = interval.size;\n\tvar steps = interval.steps;\n\tvar i, ilen, factor;\n\n\tif (!steps) {\n\t\treturn Math.ceil(range / (capacity * milliseconds));\n\t}\n\n\tfor (i = 0, ilen = steps.length; i < ilen; ++i) {\n\t\tfactor = steps[i];\n\t\tif (Math.ceil(range / (milliseconds * factor)) <= capacity) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn factor;\n}\n\n/**\n * Figures out what unit results in an appropriate number of auto-generated ticks\n */\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n\tvar ilen = UNITS.length;\n\tvar i, interval, factor;\n\n\tfor (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n\t\tinterval = INTERVALS[UNITS[i]];\n\t\tfactor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;\n\n\t\tif (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n\t\t\treturn UNITS[i];\n\t\t}\n\t}\n\n\treturn UNITS[ilen - 1];\n}\n\n/**\n * Figures out what unit to format a set of ticks with\n */\nfunction determineUnitForFormatting(ticks, minUnit, min, max) {\n\tvar duration = moment.duration(moment(max).diff(moment(min)));\n\tvar ilen = UNITS.length;\n\tvar i, unit;\n\n\tfor (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {\n\t\tunit = UNITS[i];\n\t\tif (INTERVALS[unit].common && duration.as(unit) >= ticks.length) {\n\t\t\treturn unit;\n\t\t}\n\t}\n\n\treturn UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n\nfunction determineMajorUnit(unit) {\n\tfor (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n\t\tif (INTERVALS[UNITS[i]].common) {\n\t\t\treturn UNITS[i];\n\t\t}\n\t}\n}\n\n/**\n * Generates a maximum of `capacity` timestamps between min and max, rounded to the\n * `minor` unit, aligned on the `major` unit and using the given scale time `options`.\n * Important: this method can return ticks outside the min and max range, it's the\n * responsibility of the calling code to clamp values if needed.\n */\nfunction generate(min, max, capacity, options) {\n\tvar timeOpts = options.time;\n\tvar minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\n\tvar major = determineMajorUnit(minor);\n\tvar stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);\n\tvar weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n\tvar majorTicksEnabled = options.ticks.major.enabled;\n\tvar interval = INTERVALS[minor];\n\tvar first = moment(min);\n\tvar last = moment(max);\n\tvar ticks = [];\n\tvar time;\n\n\tif (!stepSize) {\n\t\tstepSize = determineStepSize(min, max, minor, capacity);\n\t}\n\n\t// For 'week' unit, handle the first day of week option\n\tif (weekday) {\n\t\tfirst = first.isoWeekday(weekday);\n\t\tlast = last.isoWeekday(weekday);\n\t}\n\n\t// Align first/last ticks on unit\n\tfirst = first.startOf(weekday ? 'day' : minor);\n\tlast = last.startOf(weekday ? 'day' : minor);\n\n\t// Make sure that the last tick include max\n\tif (last < max) {\n\t\tlast.add(1, minor);\n\t}\n\n\ttime = moment(first);\n\n\tif (majorTicksEnabled && major && !weekday && !timeOpts.round) {\n\t\t// Align the first tick on the previous `minor` unit aligned on the `major` unit:\n\t\t// we first aligned time on the previous `major` unit then add the number of full\n\t\t// stepSize there is between first and the previous major time.\n\t\ttime.startOf(major);\n\t\ttime.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);\n\t}\n\n\tfor (; time < last; time.add(stepSize, minor)) {\n\t\tticks.push(+time);\n\t}\n\n\tticks.push(+time);\n\n\treturn ticks;\n}\n\n/**\n * Returns the right and left offsets from edges in the form of {left, right}.\n * Offsets are added when the `offset` option is true.\n */\nfunction computeOffsets(table, ticks, min, max, options) {\n\tvar left = 0;\n\tvar right = 0;\n\tvar upper, lower;\n\n\tif (options.offset && ticks.length) {\n\t\tif (!options.time.min) {\n\t\t\tupper = ticks.length > 1 ? ticks[1] : max;\n\t\t\tlower = ticks[0];\n\t\t\tleft = (\n\t\t\t\tinterpolate(table, 'time', upper, 'pos') -\n\t\t\t\tinterpolate(table, 'time', lower, 'pos')\n\t\t\t) / 2;\n\t\t}\n\t\tif (!options.time.max) {\n\t\t\tupper = ticks[ticks.length - 1];\n\t\t\tlower = ticks.length > 1 ? ticks[ticks.length - 2] : min;\n\t\t\tright = (\n\t\t\t\tinterpolate(table, 'time', upper, 'pos') -\n\t\t\t\tinterpolate(table, 'time', lower, 'pos')\n\t\t\t) / 2;\n\t\t}\n\t}\n\n\treturn {left: left, right: right};\n}\n\nfunction ticksFromTimestamps(values, majorUnit) {\n\tvar ticks = [];\n\tvar i, ilen, value, major;\n\n\tfor (i = 0, ilen = values.length; i < ilen; ++i) {\n\t\tvalue = values[i];\n\t\tmajor = majorUnit ? value === +moment(value).startOf(majorUnit) : false;\n\n\t\tticks.push({\n\t\t\tvalue: value,\n\t\t\tmajor: major\n\t\t});\n\t}\n\n\treturn ticks;\n}\n\nfunction determineLabelFormat(data, timeOpts) {\n\tvar i, momentDate, hasTime;\n\tvar ilen = data.length;\n\n\t// find the label with the most parts (milliseconds, minutes, etc.)\n\t// format all labels with the same level of detail as the most specific label\n\tfor (i = 0; i < ilen; i++) {\n\t\tmomentDate = momentify(data[i], timeOpts);\n\t\tif (momentDate.millisecond() !== 0) {\n\t\t\treturn 'MMM D, YYYY h:mm:ss.SSS a';\n\t\t}\n\t\tif (momentDate.second() !== 0 || momentDate.minute() !== 0 || momentDate.hour() !== 0) {\n\t\t\thasTime = true;\n\t\t}\n\t}\n\tif (hasTime) {\n\t\treturn 'MMM D, YYYY h:mm:ss a';\n\t}\n\treturn 'MMM D, YYYY';\n}\n\nmodule.exports = function(Chart) {\n\n\tvar defaultConfig = {\n\t\tposition: 'bottom',\n\n\t\t/**\n\t\t * Data distribution along the scale:\n\t\t * - 'linear': data are spread according to their time (distances can vary),\n\t\t * - 'series': data are spread at the same distance from each other.\n\t\t * @see https://github.com/chartjs/Chart.js/pull/4507\n\t\t * @since 2.7.0\n\t\t */\n\t\tdistribution: 'linear',\n\n\t\t/**\n\t\t * Scale boundary strategy (bypassed by min/max time options)\n\t\t * - `data`: make sure data are fully visible, ticks outside are removed\n\t\t * - `ticks`: make sure ticks are fully visible, data outside are truncated\n\t\t * @see https://github.com/chartjs/Chart.js/pull/4556\n\t\t * @since 2.7.0\n\t\t */\n\t\tbounds: 'data',\n\n\t\ttime: {\n\t\t\tparser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\n\t\t\tformat: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/\n\t\t\tunit: false, // false == automatic or override with week, month, year, etc.\n\t\t\tround: false, // none, or override with week, month, year, etc.\n\t\t\tdisplayFormat: false, // DEPRECATED\n\t\t\tisoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/\n\t\t\tminUnit: 'millisecond',\n\n\t\t\t// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/\n\t\t\tdisplayFormats: {\n\t\t\t\tmillisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,\n\t\t\t\tsecond: 'h:mm:ss a', // 11:20:01 AM\n\t\t\t\tminute: 'h:mm a', // 11:20 AM\n\t\t\t\thour: 'hA', // 5PM\n\t\t\t\tday: 'MMM D', // Sep 4\n\t\t\t\tweek: 'll', // Week 46, or maybe \"[W]WW - YYYY\" ?\n\t\t\t\tmonth: 'MMM YYYY', // Sept 2015\n\t\t\t\tquarter: '[Q]Q - YYYY', // Q3\n\t\t\t\tyear: 'YYYY' // 2015\n\t\t\t},\n\t\t},\n\t\tticks: {\n\t\t\tautoSkip: false,\n\n\t\t\t/**\n\t\t\t * Ticks generation input values:\n\t\t\t * - 'auto': generates \"optimal\" ticks based on scale size and time options.\n\t\t\t * - 'data': generates ticks from data (including labels from data {t|x|y} objects).\n\t\t\t * - 'labels': generates ticks from user given `data.labels` values ONLY.\n\t\t\t * @see https://github.com/chartjs/Chart.js/pull/4507\n\t\t\t * @since 2.7.0\n\t\t\t */\n\t\t\tsource: 'auto',\n\n\t\t\tmajor: {\n\t\t\t\tenabled: false\n\t\t\t}\n\t\t}\n\t};\n\n\tvar TimeScale = Chart.Scale.extend({\n\t\tinitialize: function() {\n\t\t\tif (!moment) {\n\t\t\t\tthrow new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');\n\t\t\t}\n\n\t\t\tthis.mergeTicksOptions();\n\n\t\t\tChart.Scale.prototype.initialize.call(this);\n\t\t},\n\n\t\tupdate: function() {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\n\t\t\t// DEPRECATIONS: output a message only one time per update\n\t\t\tif (options.time && options.time.format) {\n\t\t\t\tconsole.warn('options.time.format is deprecated and replaced by options.time.parser.');\n\t\t\t}\n\n\t\t\treturn Chart.Scale.prototype.update.apply(me, arguments);\n\t\t},\n\n\t\t/**\n\t\t * Allows data to be referenced via 't' attribute\n\t\t */\n\t\tgetRightValue: function(rawValue) {\n\t\t\tif (rawValue && rawValue.t !== undefined) {\n\t\t\t\trawValue = rawValue.t;\n\t\t\t}\n\t\t\treturn Chart.Scale.prototype.getRightValue.call(this, rawValue);\n\t\t},\n\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar timeOpts = me.options.time;\n\t\t\tvar unit = timeOpts.unit || 'day';\n\t\t\tvar min = MAX_INTEGER;\n\t\t\tvar max = MIN_INTEGER;\n\t\t\tvar timestamps = [];\n\t\t\tvar datasets = [];\n\t\t\tvar labels = [];\n\t\t\tvar i, j, ilen, jlen, data, timestamp;\n\n\t\t\t// Convert labels to timestamps\n\t\t\tfor (i = 0, ilen = chart.data.labels.length; i < ilen; ++i) {\n\t\t\t\tlabels.push(parse(chart.data.labels[i], me));\n\t\t\t}\n\n\t\t\t// Convert data to timestamps\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\tif (chart.isDatasetVisible(i)) {\n\t\t\t\t\tdata = chart.data.datasets[i].data;\n\n\t\t\t\t\t// Let's consider that all data have the same format.\n\t\t\t\t\tif (helpers.isObject(data[0])) {\n\t\t\t\t\t\tdatasets[i] = [];\n\n\t\t\t\t\t\tfor (j = 0, jlen = data.length; j < jlen; ++j) {\n\t\t\t\t\t\t\ttimestamp = parse(data[j], me);\n\t\t\t\t\t\t\ttimestamps.push(timestamp);\n\t\t\t\t\t\t\tdatasets[i][j] = timestamp;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttimestamps.push.apply(timestamps, labels);\n\t\t\t\t\t\tdatasets[i] = labels.slice(0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdatasets[i] = [];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (labels.length) {\n\t\t\t\t// Sort labels **after** data have been converted\n\t\t\t\tlabels = arrayUnique(labels).sort(sorter);\n\t\t\t\tmin = Math.min(min, labels[0]);\n\t\t\t\tmax = Math.max(max, labels[labels.length - 1]);\n\t\t\t}\n\n\t\t\tif (timestamps.length) {\n\t\t\t\ttimestamps = arrayUnique(timestamps).sort(sorter);\n\t\t\t\tmin = Math.min(min, timestamps[0]);\n\t\t\t\tmax = Math.max(max, timestamps[timestamps.length - 1]);\n\t\t\t}\n\n\t\t\tmin = parse(timeOpts.min, me) || min;\n\t\t\tmax = parse(timeOpts.max, me) || max;\n\n\t\t\t// In case there is no valid min/max, set limits based on unit time option\n\t\t\tmin = min === MAX_INTEGER ? +moment().startOf(unit) : min;\n\t\t\tmax = max === MIN_INTEGER ? +moment().endOf(unit) + 1 : max;\n\n\t\t\t// Make sure that max is strictly higher than min (required by the lookup table)\n\t\t\tme.min = Math.min(min, max);\n\t\t\tme.max = Math.max(min + 1, max);\n\n\t\t\t// PRIVATE\n\t\t\tme._horizontal = me.isHorizontal();\n\t\t\tme._table = [];\n\t\t\tme._timestamps = {\n\t\t\t\tdata: timestamps,\n\t\t\t\tdatasets: datasets,\n\t\t\t\tlabels: labels\n\t\t\t};\n\t\t},\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\t\t\tvar options = me.options;\n\t\t\tvar timeOpts = options.time;\n\t\t\tvar timestamps = [];\n\t\t\tvar ticks = [];\n\t\t\tvar i, ilen, timestamp;\n\n\t\t\tswitch (options.ticks.source) {\n\t\t\tcase 'data':\n\t\t\t\ttimestamps = me._timestamps.data;\n\t\t\t\tbreak;\n\t\t\tcase 'labels':\n\t\t\t\ttimestamps = me._timestamps.labels;\n\t\t\t\tbreak;\n\t\t\tcase 'auto':\n\t\t\tdefault:\n\t\t\t\ttimestamps = generate(min, max, me.getLabelCapacity(min), options);\n\t\t\t}\n\n\t\t\tif (options.bounds === 'ticks' && timestamps.length) {\n\t\t\t\tmin = timestamps[0];\n\t\t\t\tmax = timestamps[timestamps.length - 1];\n\t\t\t}\n\n\t\t\t// Enforce limits with user min/max options\n\t\t\tmin = parse(timeOpts.min, me) || min;\n\t\t\tmax = parse(timeOpts.max, me) || max;\n\n\t\t\t// Remove ticks outside the min/max range\n\t\t\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n\t\t\t\ttimestamp = timestamps[i];\n\t\t\t\tif (timestamp >= min && timestamp <= max) {\n\t\t\t\t\tticks.push(timestamp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.min = min;\n\t\t\tme.max = max;\n\n\t\t\t// PRIVATE\n\t\t\tme._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);\n\t\t\tme._majorUnit = determineMajorUnit(me._unit);\n\t\t\tme._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);\n\t\t\tme._offsets = computeOffsets(me._table, ticks, min, max, options);\n\t\t\tme._labelFormat = determineLabelFormat(me._timestamps.data, timeOpts);\n\n\t\t\treturn ticksFromTimestamps(ticks, me._majorUnit);\n\t\t},\n\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar data = me.chart.data;\n\t\t\tvar timeOpts = me.options.time;\n\t\t\tvar label = data.labels && index < data.labels.length ? data.labels[index] : '';\n\t\t\tvar value = data.datasets[datasetIndex].data[index];\n\n\t\t\tif (helpers.isObject(value)) {\n\t\t\t\tlabel = me.getRightValue(value);\n\t\t\t}\n\t\t\tif (timeOpts.tooltipFormat) {\n\t\t\t\treturn momentify(label, timeOpts).format(timeOpts.tooltipFormat);\n\t\t\t}\n\t\t\tif (typeof label === 'string') {\n\t\t\t\treturn label;\n\t\t\t}\n\n\t\t\treturn momentify(label, timeOpts).format(me._labelFormat);\n\t\t},\n\n\t\t/**\n\t\t * Function to format an individual tick mark\n\t\t * @private\n\t\t */\n\t\ttickFormatFunction: function(tick, index, ticks, formatOverride) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tvar time = tick.valueOf();\n\t\t\tvar formats = options.time.displayFormats;\n\t\t\tvar minorFormat = formats[me._unit];\n\t\t\tvar majorUnit = me._majorUnit;\n\t\t\tvar majorFormat = formats[majorUnit];\n\t\t\tvar majorTime = tick.clone().startOf(majorUnit).valueOf();\n\t\t\tvar majorTickOpts = options.ticks.major;\n\t\t\tvar major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;\n\t\t\tvar label = tick.format(formatOverride ? formatOverride : major ? majorFormat : minorFormat);\n\t\t\tvar tickOpts = major ? majorTickOpts : options.ticks.minor;\n\t\t\tvar formatter = helpers.valueOrDefault(tickOpts.callback, tickOpts.userCallback);\n\n\t\t\treturn formatter ? formatter(label, index, ticks) : label;\n\t\t},\n\n\t\tconvertTicksToLabels: function(ticks) {\n\t\t\tvar labels = [];\n\t\t\tvar i, ilen;\n\n\t\t\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\t\t\tlabels.push(this.tickFormatFunction(moment(ticks[i].value), i, ticks));\n\t\t\t}\n\n\t\t\treturn labels;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetPixelForOffset: function(time) {\n\t\t\tvar me = this;\n\t\t\tvar size = me._horizontal ? me.width : me.height;\n\t\t\tvar start = me._horizontal ? me.left : me.top;\n\t\t\tvar pos = interpolate(me._table, 'time', time, 'pos');\n\n\t\t\treturn start + size * (me._offsets.left + pos) / (me._offsets.left + 1 + me._offsets.right);\n\t\t},\n\n\t\tgetPixelForValue: function(value, index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar time = null;\n\n\t\t\tif (index !== undefined && datasetIndex !== undefined) {\n\t\t\t\ttime = me._timestamps.datasets[datasetIndex][index];\n\t\t\t}\n\n\t\t\tif (time === null) {\n\t\t\t\ttime = parse(value, me);\n\t\t\t}\n\n\t\t\tif (time !== null) {\n\t\t\t\treturn me.getPixelForOffset(time);\n\t\t\t}\n\t\t},\n\n\t\tgetPixelForTick: function(index) {\n\t\t\tvar ticks = this.getTicks();\n\t\t\treturn index >= 0 && index < ticks.length ?\n\t\t\t\tthis.getPixelForOffset(ticks[index].value) :\n\t\t\t\tnull;\n\t\t},\n\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar size = me._horizontal ? me.width : me.height;\n\t\t\tvar start = me._horizontal ? me.left : me.top;\n\t\t\tvar pos = (size ? (pixel - start) / size : 0) * (me._offsets.left + 1 + me._offsets.left) - me._offsets.right;\n\t\t\tvar time = interpolate(me._table, 'pos', pos, 'time');\n\n\t\t\treturn moment(time);\n\t\t},\n\n\t\t/**\n\t\t * Crude approximation of what the label width might be\n\t\t * @private\n\t\t */\n\t\tgetLabelWidth: function(label) {\n\t\t\tvar me = this;\n\t\t\tvar ticksOpts = me.options.ticks;\n\t\t\tvar tickLabelWidth = me.ctx.measureText(label).width;\n\t\t\tvar angle = helpers.toRadians(ticksOpts.maxRotation);\n\t\t\tvar cosRotation = Math.cos(angle);\n\t\t\tvar sinRotation = Math.sin(angle);\n\t\t\tvar tickFontSize = helpers.valueOrDefault(ticksOpts.fontSize, defaults.global.defaultFontSize);\n\n\t\t\treturn (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetLabelCapacity: function(exampleTime) {\n\t\t\tvar me = this;\n\n\t\t\tvar formatOverride = me.options.time.displayFormats.millisecond;\t// Pick the longest format for guestimation\n\n\t\t\tvar exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, [], formatOverride);\n\t\t\tvar tickLabelWidth = me.getLabelWidth(exampleLabel);\n\t\t\tvar innerWidth = me.isHorizontal() ? me.width : me.height;\n\n\t\t\tvar capacity = Math.floor(innerWidth / tickLabelWidth);\n\t\t\treturn capacity > 0 ? capacity : 1;\n\t\t}\n\t});\n\n\tChart.scaleService.registerScaleType('time', TimeScale, defaultConfig);\n};\n\n},{\"../core/core.defaults\":33,\"../helpers/index\":53,\"moment\":\"moment\"}],67:[function(require,module,exports){\n//! moment.js locale configuration\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../moment')) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    function processRelativeTime(number, withoutSuffix, key, isFuture) {\n        var format = {\n            'm': ['eine Minute', 'einer Minute'],\n            'h': ['eine Stunde', 'einer Stunde'],\n            'd': ['ein Tag', 'einem Tag'],\n            'dd': [number + ' Tage', number + ' Tagen'],\n            'M': ['ein Monat', 'einem Monat'],\n            'MM': [number + ' Monate', number + ' Monaten'],\n            'y': ['ein Jahr', 'einem Jahr'],\n            'yy': [number + ' Jahre', number + ' Jahren']\n        };\n        return withoutSuffix ? format[key][0] : format[key][1];\n    }\n\n    var de = moment.defineLocale('de', {\n        months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),\n        monthsShort : 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),\n        monthsParseExact : true,\n        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),\n        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),\n        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT: 'HH:mm',\n            LTS: 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D. MMMM YYYY',\n            LLL : 'D. MMMM YYYY HH:mm',\n            LLLL : 'dddd, D. MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[heute um] LT [Uhr]',\n            sameElse: 'L',\n            nextDay: '[morgen um] LT [Uhr]',\n            nextWeek: 'dddd [um] LT [Uhr]',\n            lastDay: '[gestern um] LT [Uhr]',\n            lastWeek: '[letzten] dddd [um] LT [Uhr]'\n        },\n        relativeTime : {\n            future : 'in %s',\n            past : 'vor %s',\n            s : 'ein paar Sekunden',\n            ss : '%d Sekunden',\n            m : processRelativeTime,\n            mm : '%d Minuten',\n            h : processRelativeTime,\n            hh : '%d Stunden',\n            d : processRelativeTime,\n            dd : processRelativeTime,\n            M : processRelativeTime,\n            MM : processRelativeTime,\n            y : processRelativeTime,\n            yy : processRelativeTime\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return de;\n\n})));\n\n},{\"../moment\":68}],68:[function(require,module,exports){\n//! moment.js\n\n;(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    global.moment = factory()\n}(this, (function () { 'use strict';\n\n    var hookCallback;\n\n    function hooks () {\n        return hookCallback.apply(null, arguments);\n    }\n\n    // This is done to register the method called with moment()\n    // without creating circular dependencies.\n    function setHookCallback (callback) {\n        hookCallback = callback;\n    }\n\n    function isArray(input) {\n        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';\n    }\n\n    function isObject(input) {\n        // IE8 will treat undefined and null as object if it wasn't for\n        // input != null\n        return input != null && Object.prototype.toString.call(input) === '[object Object]';\n    }\n\n    function isObjectEmpty(obj) {\n        if (Object.getOwnPropertyNames) {\n            return (Object.getOwnPropertyNames(obj).length === 0);\n        } else {\n            var k;\n            for (k in obj) {\n                if (obj.hasOwnProperty(k)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    function isUndefined(input) {\n        return input === void 0;\n    }\n\n    function isNumber(input) {\n        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';\n    }\n\n    function isDate(input) {\n        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';\n    }\n\n    function map(arr, fn) {\n        var res = [], i;\n        for (i = 0; i < arr.length; ++i) {\n            res.push(fn(arr[i], i));\n        }\n        return res;\n    }\n\n    function hasOwnProp(a, b) {\n        return Object.prototype.hasOwnProperty.call(a, b);\n    }\n\n    function extend(a, b) {\n        for (var i in b) {\n            if (hasOwnProp(b, i)) {\n                a[i] = b[i];\n            }\n        }\n\n        if (hasOwnProp(b, 'toString')) {\n            a.toString = b.toString;\n        }\n\n        if (hasOwnProp(b, 'valueOf')) {\n            a.valueOf = b.valueOf;\n        }\n\n        return a;\n    }\n\n    function createUTC (input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, true).utc();\n    }\n\n    function defaultParsingFlags() {\n        // We need to deep clone this object.\n        return {\n            empty           : false,\n            unusedTokens    : [],\n            unusedInput     : [],\n            overflow        : -2,\n            charsLeftOver   : 0,\n            nullInput       : false,\n            invalidMonth    : null,\n            invalidFormat   : false,\n            userInvalidated : false,\n            iso             : false,\n            parsedDateParts : [],\n            meridiem        : null,\n            rfc2822         : false,\n            weekdayMismatch : false\n        };\n    }\n\n    function getParsingFlags(m) {\n        if (m._pf == null) {\n            m._pf = defaultParsingFlags();\n        }\n        return m._pf;\n    }\n\n    var some;\n    if (Array.prototype.some) {\n        some = Array.prototype.some;\n    } else {\n        some = function (fun) {\n            var t = Object(this);\n            var len = t.length >>> 0;\n\n            for (var i = 0; i < len; i++) {\n                if (i in t && fun.call(this, t[i], i, t)) {\n                    return true;\n                }\n            }\n\n            return false;\n        };\n    }\n\n    function isValid(m) {\n        if (m._isValid == null) {\n            var flags = getParsingFlags(m);\n            var parsedParts = some.call(flags.parsedDateParts, function (i) {\n                return i != null;\n            });\n            var isNowValid = !isNaN(m._d.getTime()) &&\n                flags.overflow < 0 &&\n                !flags.empty &&\n                !flags.invalidMonth &&\n                !flags.invalidWeekday &&\n                !flags.weekdayMismatch &&\n                !flags.nullInput &&\n                !flags.invalidFormat &&\n                !flags.userInvalidated &&\n                (!flags.meridiem || (flags.meridiem && parsedParts));\n\n            if (m._strict) {\n                isNowValid = isNowValid &&\n                    flags.charsLeftOver === 0 &&\n                    flags.unusedTokens.length === 0 &&\n                    flags.bigHour === undefined;\n            }\n\n            if (Object.isFrozen == null || !Object.isFrozen(m)) {\n                m._isValid = isNowValid;\n            }\n            else {\n                return isNowValid;\n            }\n        }\n        return m._isValid;\n    }\n\n    function createInvalid (flags) {\n        var m = createUTC(NaN);\n        if (flags != null) {\n            extend(getParsingFlags(m), flags);\n        }\n        else {\n            getParsingFlags(m).userInvalidated = true;\n        }\n\n        return m;\n    }\n\n    // Plugins that add properties should also add the key here (null value),\n    // so we can properly clone ourselves.\n    var momentProperties = hooks.momentProperties = [];\n\n    function copyConfig(to, from) {\n        var i, prop, val;\n\n        if (!isUndefined(from._isAMomentObject)) {\n            to._isAMomentObject = from._isAMomentObject;\n        }\n        if (!isUndefined(from._i)) {\n            to._i = from._i;\n        }\n        if (!isUndefined(from._f)) {\n            to._f = from._f;\n        }\n        if (!isUndefined(from._l)) {\n            to._l = from._l;\n        }\n        if (!isUndefined(from._strict)) {\n            to._strict = from._strict;\n        }\n        if (!isUndefined(from._tzm)) {\n            to._tzm = from._tzm;\n        }\n        if (!isUndefined(from._isUTC)) {\n            to._isUTC = from._isUTC;\n        }\n        if (!isUndefined(from._offset)) {\n            to._offset = from._offset;\n        }\n        if (!isUndefined(from._pf)) {\n            to._pf = getParsingFlags(from);\n        }\n        if (!isUndefined(from._locale)) {\n            to._locale = from._locale;\n        }\n\n        if (momentProperties.length > 0) {\n            for (i = 0; i < momentProperties.length; i++) {\n                prop = momentProperties[i];\n                val = from[prop];\n                if (!isUndefined(val)) {\n                    to[prop] = val;\n                }\n            }\n        }\n\n        return to;\n    }\n\n    var updateInProgress = false;\n\n    // Moment prototype object\n    function Moment(config) {\n        copyConfig(this, config);\n        this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n        if (!this.isValid()) {\n            this._d = new Date(NaN);\n        }\n        // Prevent infinite loop in case updateOffset creates new moment\n        // objects.\n        if (updateInProgress === false) {\n            updateInProgress = true;\n            hooks.updateOffset(this);\n            updateInProgress = false;\n        }\n    }\n\n    function isMoment (obj) {\n        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);\n    }\n\n    function absFloor (number) {\n        if (number < 0) {\n            // -0 -> 0\n            return Math.ceil(number) || 0;\n        } else {\n            return Math.floor(number);\n        }\n    }\n\n    function toInt(argumentForCoercion) {\n        var coercedNumber = +argumentForCoercion,\n            value = 0;\n\n        if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n            value = absFloor(coercedNumber);\n        }\n\n        return value;\n    }\n\n    // compare two arrays, return the number of differences\n    function compareArrays(array1, array2, dontConvert) {\n        var len = Math.min(array1.length, array2.length),\n            lengthDiff = Math.abs(array1.length - array2.length),\n            diffs = 0,\n            i;\n        for (i = 0; i < len; i++) {\n            if ((dontConvert && array1[i] !== array2[i]) ||\n                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {\n                diffs++;\n            }\n        }\n        return diffs + lengthDiff;\n    }\n\n    function warn(msg) {\n        if (hooks.suppressDeprecationWarnings === false &&\n                (typeof console !==  'undefined') && console.warn) {\n            console.warn('Deprecation warning: ' + msg);\n        }\n    }\n\n    function deprecate(msg, fn) {\n        var firstTime = true;\n\n        return extend(function () {\n            if (hooks.deprecationHandler != null) {\n                hooks.deprecationHandler(null, msg);\n            }\n            if (firstTime) {\n                var args = [];\n                var arg;\n                for (var i = 0; i < arguments.length; i++) {\n                    arg = '';\n                    if (typeof arguments[i] === 'object') {\n                        arg += '\\n[' + i + '] ';\n                        for (var key in arguments[0]) {\n                            arg += key + ': ' + arguments[0][key] + ', ';\n                        }\n                        arg = arg.slice(0, -2); // Remove trailing comma and space\n                    } else {\n                        arg = arguments[i];\n                    }\n                    args.push(arg);\n                }\n                warn(msg + '\\nArguments: ' + Array.prototype.slice.call(args).join('') + '\\n' + (new Error()).stack);\n                firstTime = false;\n            }\n            return fn.apply(this, arguments);\n        }, fn);\n    }\n\n    var deprecations = {};\n\n    function deprecateSimple(name, msg) {\n        if (hooks.deprecationHandler != null) {\n            hooks.deprecationHandler(name, msg);\n        }\n        if (!deprecations[name]) {\n            warn(msg);\n            deprecations[name] = true;\n        }\n    }\n\n    hooks.suppressDeprecationWarnings = false;\n    hooks.deprecationHandler = null;\n\n    function isFunction(input) {\n        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';\n    }\n\n    function set (config) {\n        var prop, i;\n        for (i in config) {\n            prop = config[i];\n            if (isFunction(prop)) {\n                this[i] = prop;\n            } else {\n                this['_' + i] = prop;\n            }\n        }\n        this._config = config;\n        // Lenient ordinal parsing accepts just a number in addition to\n        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        this._dayOfMonthOrdinalParseLenient = new RegExp(\n            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +\n                '|' + (/\\d{1,2}/).source);\n    }\n\n    function mergeConfigs(parentConfig, childConfig) {\n        var res = extend({}, parentConfig), prop;\n        for (prop in childConfig) {\n            if (hasOwnProp(childConfig, prop)) {\n                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\n                    res[prop] = {};\n                    extend(res[prop], parentConfig[prop]);\n                    extend(res[prop], childConfig[prop]);\n                } else if (childConfig[prop] != null) {\n                    res[prop] = childConfig[prop];\n                } else {\n                    delete res[prop];\n                }\n            }\n        }\n        for (prop in parentConfig) {\n            if (hasOwnProp(parentConfig, prop) &&\n                    !hasOwnProp(childConfig, prop) &&\n                    isObject(parentConfig[prop])) {\n                // make sure changes to properties don't modify parent config\n                res[prop] = extend({}, res[prop]);\n            }\n        }\n        return res;\n    }\n\n    function Locale(config) {\n        if (config != null) {\n            this.set(config);\n        }\n    }\n\n    var keys;\n\n    if (Object.keys) {\n        keys = Object.keys;\n    } else {\n        keys = function (obj) {\n            var i, res = [];\n            for (i in obj) {\n                if (hasOwnProp(obj, i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        };\n    }\n\n    var defaultCalendar = {\n        sameDay : '[Today at] LT',\n        nextDay : '[Tomorrow at] LT',\n        nextWeek : 'dddd [at] LT',\n        lastDay : '[Yesterday at] LT',\n        lastWeek : '[Last] dddd [at] LT',\n        sameElse : 'L'\n    };\n\n    function calendar (key, mom, now) {\n        var output = this._calendar[key] || this._calendar['sameElse'];\n        return isFunction(output) ? output.call(mom, now) : output;\n    }\n\n    var defaultLongDateFormat = {\n        LTS  : 'h:mm:ss A',\n        LT   : 'h:mm A',\n        L    : 'MM/DD/YYYY',\n        LL   : 'MMMM D, YYYY',\n        LLL  : 'MMMM D, YYYY h:mm A',\n        LLLL : 'dddd, MMMM D, YYYY h:mm A'\n    };\n\n    function longDateFormat (key) {\n        var format = this._longDateFormat[key],\n            formatUpper = this._longDateFormat[key.toUpperCase()];\n\n        if (format || !formatUpper) {\n            return format;\n        }\n\n        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {\n            return val.slice(1);\n        });\n\n        return this._longDateFormat[key];\n    }\n\n    var defaultInvalidDate = 'Invalid date';\n\n    function invalidDate () {\n        return this._invalidDate;\n    }\n\n    var defaultOrdinal = '%d';\n    var defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\n\n    function ordinal (number) {\n        return this._ordinal.replace('%d', number);\n    }\n\n    var defaultRelativeTime = {\n        future : 'in %s',\n        past   : '%s ago',\n        s  : 'a few seconds',\n        ss : '%d seconds',\n        m  : 'a minute',\n        mm : '%d minutes',\n        h  : 'an hour',\n        hh : '%d hours',\n        d  : 'a day',\n        dd : '%d days',\n        M  : 'a month',\n        MM : '%d months',\n        y  : 'a year',\n        yy : '%d years'\n    };\n\n    function relativeTime (number, withoutSuffix, string, isFuture) {\n        var output = this._relativeTime[string];\n        return (isFunction(output)) ?\n            output(number, withoutSuffix, string, isFuture) :\n            output.replace(/%d/i, number);\n    }\n\n    function pastFuture (diff, output) {\n        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n        return isFunction(format) ? format(output) : format.replace(/%s/i, output);\n    }\n\n    var aliases = {};\n\n    function addUnitAlias (unit, shorthand) {\n        var lowerCase = unit.toLowerCase();\n        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\n    }\n\n    function normalizeUnits(units) {\n        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;\n    }\n\n    function normalizeObjectUnits(inputObject) {\n        var normalizedInput = {},\n            normalizedProp,\n            prop;\n\n        for (prop in inputObject) {\n            if (hasOwnProp(inputObject, prop)) {\n                normalizedProp = normalizeUnits(prop);\n                if (normalizedProp) {\n                    normalizedInput[normalizedProp] = inputObject[prop];\n                }\n            }\n        }\n\n        return normalizedInput;\n    }\n\n    var priorities = {};\n\n    function addUnitPriority(unit, priority) {\n        priorities[unit] = priority;\n    }\n\n    function getPrioritizedUnits(unitsObj) {\n        var units = [];\n        for (var u in unitsObj) {\n            units.push({unit: u, priority: priorities[u]});\n        }\n        units.sort(function (a, b) {\n            return a.priority - b.priority;\n        });\n        return units;\n    }\n\n    function zeroFill(number, targetLength, forceSign) {\n        var absNumber = '' + Math.abs(number),\n            zerosToFill = targetLength - absNumber.length,\n            sign = number >= 0;\n        return (sign ? (forceSign ? '+' : '') : '-') +\n            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\n    }\n\n    var formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;\n\n    var localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g;\n\n    var formatFunctions = {};\n\n    var formatTokenFunctions = {};\n\n    // token:    'M'\n    // padded:   ['MM', 2]\n    // ordinal:  'Mo'\n    // callback: function () { this.month() + 1 }\n    function addFormatToken (token, padded, ordinal, callback) {\n        var func = callback;\n        if (typeof callback === 'string') {\n            func = function () {\n                return this[callback]();\n            };\n        }\n        if (token) {\n            formatTokenFunctions[token] = func;\n        }\n        if (padded) {\n            formatTokenFunctions[padded[0]] = function () {\n                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n            };\n        }\n        if (ordinal) {\n            formatTokenFunctions[ordinal] = function () {\n                return this.localeData().ordinal(func.apply(this, arguments), token);\n            };\n        }\n    }\n\n    function removeFormattingTokens(input) {\n        if (input.match(/\\[[\\s\\S]/)) {\n            return input.replace(/^\\[|\\]$/g, '');\n        }\n        return input.replace(/\\\\/g, '');\n    }\n\n    function makeFormatFunction(format) {\n        var array = format.match(formattingTokens), i, length;\n\n        for (i = 0, length = array.length; i < length; i++) {\n            if (formatTokenFunctions[array[i]]) {\n                array[i] = formatTokenFunctions[array[i]];\n            } else {\n                array[i] = removeFormattingTokens(array[i]);\n            }\n        }\n\n        return function (mom) {\n            var output = '', i;\n            for (i = 0; i < length; i++) {\n                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];\n            }\n            return output;\n        };\n    }\n\n    // format date using native date object\n    function formatMoment(m, format) {\n        if (!m.isValid()) {\n            return m.localeData().invalidDate();\n        }\n\n        format = expandFormat(format, m.localeData());\n        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\n\n        return formatFunctions[format](m);\n    }\n\n    function expandFormat(format, locale) {\n        var i = 5;\n\n        function replaceLongDateFormatTokens(input) {\n            return locale.longDateFormat(input) || input;\n        }\n\n        localFormattingTokens.lastIndex = 0;\n        while (i >= 0 && localFormattingTokens.test(format)) {\n            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n            localFormattingTokens.lastIndex = 0;\n            i -= 1;\n        }\n\n        return format;\n    }\n\n    var match1         = /\\d/;            //       0 - 9\n    var match2         = /\\d\\d/;          //      00 - 99\n    var match3         = /\\d{3}/;         //     000 - 999\n    var match4         = /\\d{4}/;         //    0000 - 9999\n    var match6         = /[+-]?\\d{6}/;    // -999999 - 999999\n    var match1to2      = /\\d\\d?/;         //       0 - 99\n    var match3to4      = /\\d\\d\\d\\d?/;     //     999 - 9999\n    var match5to6      = /\\d\\d\\d\\d\\d\\d?/; //   99999 - 999999\n    var match1to3      = /\\d{1,3}/;       //       0 - 999\n    var match1to4      = /\\d{1,4}/;       //       0 - 9999\n    var match1to6      = /[+-]?\\d{1,6}/;  // -999999 - 999999\n\n    var matchUnsigned  = /\\d+/;           //       0 - inf\n    var matchSigned    = /[+-]?\\d+/;      //    -inf - inf\n\n    var matchOffset    = /Z|[+-]\\d\\d:?\\d\\d/gi; // +00:00 -00:00 +0000 -0000 or Z\n    var matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z\n\n    var matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/; // 123456789 123456789.123\n\n    // any word (or two) characters or numbers including two/three word month in arabic.\n    // includes scottish gaelic two word and hyphenated months\n    var matchWord = /[0-9]{0,256}['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFF07\\uFF10-\\uFFEF]{1,256}|[\\u0600-\\u06FF\\/]{1,256}(\\s*?[\\u0600-\\u06FF]{1,256}){1,2}/i;\n\n    var regexes = {};\n\n    function addRegexToken (token, regex, strictRegex) {\n        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {\n            return (isStrict && strictRegex) ? strictRegex : regex;\n        };\n    }\n\n    function getParseRegexForToken (token, config) {\n        if (!hasOwnProp(regexes, token)) {\n            return new RegExp(unescapeFormat(token));\n        }\n\n        return regexes[token](config._strict, config._locale);\n    }\n\n    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n    function unescapeFormat(s) {\n        return regexEscape(s.replace('\\\\', '').replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {\n            return p1 || p2 || p3 || p4;\n        }));\n    }\n\n    function regexEscape(s) {\n        return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    }\n\n    var tokens = {};\n\n    function addParseToken (token, callback) {\n        var i, func = callback;\n        if (typeof token === 'string') {\n            token = [token];\n        }\n        if (isNumber(callback)) {\n            func = function (input, array) {\n                array[callback] = toInt(input);\n            };\n        }\n        for (i = 0; i < token.length; i++) {\n            tokens[token[i]] = func;\n        }\n    }\n\n    function addWeekParseToken (token, callback) {\n        addParseToken(token, function (input, array, config, token) {\n            config._w = config._w || {};\n            callback(input, config._w, config, token);\n        });\n    }\n\n    function addTimeToArrayFromToken(token, input, config) {\n        if (input != null && hasOwnProp(tokens, token)) {\n            tokens[token](input, config._a, config, token);\n        }\n    }\n\n    var YEAR = 0;\n    var MONTH = 1;\n    var DATE = 2;\n    var HOUR = 3;\n    var MINUTE = 4;\n    var SECOND = 5;\n    var MILLISECOND = 6;\n    var WEEK = 7;\n    var WEEKDAY = 8;\n\n    // FORMATTING\n\n    addFormatToken('Y', 0, 0, function () {\n        var y = this.year();\n        return y <= 9999 ? '' + y : '+' + y;\n    });\n\n    addFormatToken(0, ['YY', 2], 0, function () {\n        return this.year() % 100;\n    });\n\n    addFormatToken(0, ['YYYY',   4],       0, 'year');\n    addFormatToken(0, ['YYYYY',  5],       0, 'year');\n    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\n\n    // ALIASES\n\n    addUnitAlias('year', 'y');\n\n    // PRIORITIES\n\n    addUnitPriority('year', 1);\n\n    // PARSING\n\n    addRegexToken('Y',      matchSigned);\n    addRegexToken('YY',     match1to2, match2);\n    addRegexToken('YYYY',   match1to4, match4);\n    addRegexToken('YYYYY',  match1to6, match6);\n    addRegexToken('YYYYYY', match1to6, match6);\n\n    addParseToken(['YYYYY', 'YYYYYY'], YEAR);\n    addParseToken('YYYY', function (input, array) {\n        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\n    });\n    addParseToken('YY', function (input, array) {\n        array[YEAR] = hooks.parseTwoDigitYear(input);\n    });\n    addParseToken('Y', function (input, array) {\n        array[YEAR] = parseInt(input, 10);\n    });\n\n    // HELPERS\n\n    function daysInYear(year) {\n        return isLeapYear(year) ? 366 : 365;\n    }\n\n    function isLeapYear(year) {\n        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n    }\n\n    // HOOKS\n\n    hooks.parseTwoDigitYear = function (input) {\n        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n    };\n\n    // MOMENTS\n\n    var getSetYear = makeGetSet('FullYear', true);\n\n    function getIsLeapYear () {\n        return isLeapYear(this.year());\n    }\n\n    function makeGetSet (unit, keepTime) {\n        return function (value) {\n            if (value != null) {\n                set$1(this, unit, value);\n                hooks.updateOffset(this, keepTime);\n                return this;\n            } else {\n                return get(this, unit);\n            }\n        };\n    }\n\n    function get (mom, unit) {\n        return mom.isValid() ?\n            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;\n    }\n\n    function set$1 (mom, unit, value) {\n        if (mom.isValid() && !isNaN(value)) {\n            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {\n                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));\n            }\n            else {\n                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function stringGet (units) {\n        units = normalizeUnits(units);\n        if (isFunction(this[units])) {\n            return this[units]();\n        }\n        return this;\n    }\n\n\n    function stringSet (units, value) {\n        if (typeof units === 'object') {\n            units = normalizeObjectUnits(units);\n            var prioritized = getPrioritizedUnits(units);\n            for (var i = 0; i < prioritized.length; i++) {\n                this[prioritized[i].unit](units[prioritized[i].unit]);\n            }\n        } else {\n            units = normalizeUnits(units);\n            if (isFunction(this[units])) {\n                return this[units](value);\n            }\n        }\n        return this;\n    }\n\n    function mod(n, x) {\n        return ((n % x) + x) % x;\n    }\n\n    var indexOf;\n\n    if (Array.prototype.indexOf) {\n        indexOf = Array.prototype.indexOf;\n    } else {\n        indexOf = function (o) {\n            // I know\n            var i;\n            for (i = 0; i < this.length; ++i) {\n                if (this[i] === o) {\n                    return i;\n                }\n            }\n            return -1;\n        };\n    }\n\n    function daysInMonth(year, month) {\n        if (isNaN(year) || isNaN(month)) {\n            return NaN;\n        }\n        var modMonth = mod(month, 12);\n        year += (month - modMonth) / 12;\n        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);\n    }\n\n    // FORMATTING\n\n    addFormatToken('M', ['MM', 2], 'Mo', function () {\n        return this.month() + 1;\n    });\n\n    addFormatToken('MMM', 0, 0, function (format) {\n        return this.localeData().monthsShort(this, format);\n    });\n\n    addFormatToken('MMMM', 0, 0, function (format) {\n        return this.localeData().months(this, format);\n    });\n\n    // ALIASES\n\n    addUnitAlias('month', 'M');\n\n    // PRIORITY\n\n    addUnitPriority('month', 8);\n\n    // PARSING\n\n    addRegexToken('M',    match1to2);\n    addRegexToken('MM',   match1to2, match2);\n    addRegexToken('MMM',  function (isStrict, locale) {\n        return locale.monthsShortRegex(isStrict);\n    });\n    addRegexToken('MMMM', function (isStrict, locale) {\n        return locale.monthsRegex(isStrict);\n    });\n\n    addParseToken(['M', 'MM'], function (input, array) {\n        array[MONTH] = toInt(input) - 1;\n    });\n\n    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\n        var month = config._locale.monthsParse(input, token, config._strict);\n        // if we didn't find a month name, mark the date as invalid.\n        if (month != null) {\n            array[MONTH] = month;\n        } else {\n            getParsingFlags(config).invalidMonth = input;\n        }\n    });\n\n    // LOCALES\n\n    var MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/;\n    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');\n    function localeMonths (m, format) {\n        if (!m) {\n            return isArray(this._months) ? this._months :\n                this._months['standalone'];\n        }\n        return isArray(this._months) ? this._months[m.month()] :\n            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];\n    }\n\n    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');\n    function localeMonthsShort (m, format) {\n        if (!m) {\n            return isArray(this._monthsShort) ? this._monthsShort :\n                this._monthsShort['standalone'];\n        }\n        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :\n            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];\n    }\n\n    function handleStrictParse(monthName, format, strict) {\n        var i, ii, mom, llc = monthName.toLocaleLowerCase();\n        if (!this._monthsParse) {\n            // this is not used\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n            for (i = 0; i < 12; ++i) {\n                mom = createUTC([2000, i]);\n                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();\n                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\n            }\n        }\n\n        if (strict) {\n            if (format === 'MMM') {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === 'MMM') {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n\n    function localeMonthsParse (monthName, format, strict) {\n        var i, mom, regex;\n\n        if (this._monthsParseExact) {\n            return handleStrictParse.call(this, monthName, format, strict);\n        }\n\n        if (!this._monthsParse) {\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n        }\n\n        // TODO: add sorting\n        // Sorting makes sure if one month (or abbr) is a prefix of another\n        // see sorting in computeMonthsParse\n        for (i = 0; i < 12; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, i]);\n            if (strict && !this._longMonthsParse[i]) {\n                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\n                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\n            }\n            if (!strict && !this._monthsParse[i]) {\n                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (!strict && this._monthsParse[i].test(monthName)) {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function setMonth (mom, value) {\n        var dayOfMonth;\n\n        if (!mom.isValid()) {\n            // No op\n            return mom;\n        }\n\n        if (typeof value === 'string') {\n            if (/^\\d+$/.test(value)) {\n                value = toInt(value);\n            } else {\n                value = mom.localeData().monthsParse(value);\n                // TODO: Another silent failure?\n                if (!isNumber(value)) {\n                    return mom;\n                }\n            }\n        }\n\n        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\n        return mom;\n    }\n\n    function getSetMonth (value) {\n        if (value != null) {\n            setMonth(this, value);\n            hooks.updateOffset(this, true);\n            return this;\n        } else {\n            return get(this, 'Month');\n        }\n    }\n\n    function getDaysInMonth () {\n        return daysInMonth(this.year(), this.month());\n    }\n\n    var defaultMonthsShortRegex = matchWord;\n    function monthsShortRegex (isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsShortStrictRegex;\n            } else {\n                return this._monthsShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_monthsShortRegex')) {\n                this._monthsShortRegex = defaultMonthsShortRegex;\n            }\n            return this._monthsShortStrictRegex && isStrict ?\n                this._monthsShortStrictRegex : this._monthsShortRegex;\n        }\n    }\n\n    var defaultMonthsRegex = matchWord;\n    function monthsRegex (isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsStrictRegex;\n            } else {\n                return this._monthsRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                this._monthsRegex = defaultMonthsRegex;\n            }\n            return this._monthsStrictRegex && isStrict ?\n                this._monthsStrictRegex : this._monthsRegex;\n        }\n    }\n\n    function computeMonthsParse () {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n\n        var shortPieces = [], longPieces = [], mixedPieces = [],\n            i, mom;\n        for (i = 0; i < 12; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, i]);\n            shortPieces.push(this.monthsShort(mom, ''));\n            longPieces.push(this.months(mom, ''));\n            mixedPieces.push(this.months(mom, ''));\n            mixedPieces.push(this.monthsShort(mom, ''));\n        }\n        // Sorting makes sure if one month (or abbr) is a prefix of another it\n        // will match the longer piece.\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n        for (i = 0; i < 12; i++) {\n            shortPieces[i] = regexEscape(shortPieces[i]);\n            longPieces[i] = regexEscape(longPieces[i]);\n        }\n        for (i = 0; i < 24; i++) {\n            mixedPieces[i] = regexEscape(mixedPieces[i]);\n        }\n\n        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n        this._monthsShortRegex = this._monthsRegex;\n        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n    }\n\n    function createDate (y, m, d, h, M, s, ms) {\n        // can't just apply() to create a date:\n        // https://stackoverflow.com/q/181348\n        var date = new Date(y, m, d, h, M, s, ms);\n\n        // the date constructor remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {\n            date.setFullYear(y);\n        }\n        return date;\n    }\n\n    function createUTCDate (y) {\n        var date = new Date(Date.UTC.apply(null, arguments));\n\n        // the Date.UTC function remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {\n            date.setUTCFullYear(y);\n        }\n        return date;\n    }\n\n    // start-of-first-week - start-of-year\n    function firstWeekOffset(year, dow, doy) {\n        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n            fwd = 7 + dow - doy,\n            // first-week day local weekday -- which local weekday is fwd\n            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\n\n        return -fwdlw + fwd - 1;\n    }\n\n    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {\n        var localWeekday = (7 + weekday - dow) % 7,\n            weekOffset = firstWeekOffset(year, dow, doy),\n            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\n            resYear, resDayOfYear;\n\n        if (dayOfYear <= 0) {\n            resYear = year - 1;\n            resDayOfYear = daysInYear(resYear) + dayOfYear;\n        } else if (dayOfYear > daysInYear(year)) {\n            resYear = year + 1;\n            resDayOfYear = dayOfYear - daysInYear(year);\n        } else {\n            resYear = year;\n            resDayOfYear = dayOfYear;\n        }\n\n        return {\n            year: resYear,\n            dayOfYear: resDayOfYear\n        };\n    }\n\n    function weekOfYear(mom, dow, doy) {\n        var weekOffset = firstWeekOffset(mom.year(), dow, doy),\n            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\n            resWeek, resYear;\n\n        if (week < 1) {\n            resYear = mom.year() - 1;\n            resWeek = week + weeksInYear(resYear, dow, doy);\n        } else if (week > weeksInYear(mom.year(), dow, doy)) {\n            resWeek = week - weeksInYear(mom.year(), dow, doy);\n            resYear = mom.year() + 1;\n        } else {\n            resYear = mom.year();\n            resWeek = week;\n        }\n\n        return {\n            week: resWeek,\n            year: resYear\n        };\n    }\n\n    function weeksInYear(year, dow, doy) {\n        var weekOffset = firstWeekOffset(year, dow, doy),\n            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\n        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\n    }\n\n    // FORMATTING\n\n    addFormatToken('w', ['ww', 2], 'wo', 'week');\n    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\n\n    // ALIASES\n\n    addUnitAlias('week', 'w');\n    addUnitAlias('isoWeek', 'W');\n\n    // PRIORITIES\n\n    addUnitPriority('week', 5);\n    addUnitPriority('isoWeek', 5);\n\n    // PARSING\n\n    addRegexToken('w',  match1to2);\n    addRegexToken('ww', match1to2, match2);\n    addRegexToken('W',  match1to2);\n    addRegexToken('WW', match1to2, match2);\n\n    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {\n        week[token.substr(0, 1)] = toInt(input);\n    });\n\n    // HELPERS\n\n    // LOCALES\n\n    function localeWeek (mom) {\n        return weekOfYear(mom, this._week.dow, this._week.doy).week;\n    }\n\n    var defaultLocaleWeek = {\n        dow : 0, // Sunday is the first day of the week.\n        doy : 6  // The week that contains Jan 1st is the first week of the year.\n    };\n\n    function localeFirstDayOfWeek () {\n        return this._week.dow;\n    }\n\n    function localeFirstDayOfYear () {\n        return this._week.doy;\n    }\n\n    // MOMENTS\n\n    function getSetWeek (input) {\n        var week = this.localeData().week(this);\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    function getSetISOWeek (input) {\n        var week = weekOfYear(this, 1, 4).week;\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    // FORMATTING\n\n    addFormatToken('d', 0, 'do', 'day');\n\n    addFormatToken('dd', 0, 0, function (format) {\n        return this.localeData().weekdaysMin(this, format);\n    });\n\n    addFormatToken('ddd', 0, 0, function (format) {\n        return this.localeData().weekdaysShort(this, format);\n    });\n\n    addFormatToken('dddd', 0, 0, function (format) {\n        return this.localeData().weekdays(this, format);\n    });\n\n    addFormatToken('e', 0, 0, 'weekday');\n    addFormatToken('E', 0, 0, 'isoWeekday');\n\n    // ALIASES\n\n    addUnitAlias('day', 'd');\n    addUnitAlias('weekday', 'e');\n    addUnitAlias('isoWeekday', 'E');\n\n    // PRIORITY\n    addUnitPriority('day', 11);\n    addUnitPriority('weekday', 11);\n    addUnitPriority('isoWeekday', 11);\n\n    // PARSING\n\n    addRegexToken('d',    match1to2);\n    addRegexToken('e',    match1to2);\n    addRegexToken('E',    match1to2);\n    addRegexToken('dd',   function (isStrict, locale) {\n        return locale.weekdaysMinRegex(isStrict);\n    });\n    addRegexToken('ddd',   function (isStrict, locale) {\n        return locale.weekdaysShortRegex(isStrict);\n    });\n    addRegexToken('dddd',   function (isStrict, locale) {\n        return locale.weekdaysRegex(isStrict);\n    });\n\n    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {\n        var weekday = config._locale.weekdaysParse(input, token, config._strict);\n        // if we didn't get a weekday name, mark the date as invalid\n        if (weekday != null) {\n            week.d = weekday;\n        } else {\n            getParsingFlags(config).invalidWeekday = input;\n        }\n    });\n\n    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\n        week[token] = toInt(input);\n    });\n\n    // HELPERS\n\n    function parseWeekday(input, locale) {\n        if (typeof input !== 'string') {\n            return input;\n        }\n\n        if (!isNaN(input)) {\n            return parseInt(input, 10);\n        }\n\n        input = locale.weekdaysParse(input);\n        if (typeof input === 'number') {\n            return input;\n        }\n\n        return null;\n    }\n\n    function parseIsoWeekday(input, locale) {\n        if (typeof input === 'string') {\n            return locale.weekdaysParse(input) % 7 || 7;\n        }\n        return isNaN(input) ? null : input;\n    }\n\n    // LOCALES\n\n    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');\n    function localeWeekdays (m, format) {\n        if (!m) {\n            return isArray(this._weekdays) ? this._weekdays :\n                this._weekdays['standalone'];\n        }\n        return isArray(this._weekdays) ? this._weekdays[m.day()] :\n            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];\n    }\n\n    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');\n    function localeWeekdaysShort (m) {\n        return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;\n    }\n\n    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');\n    function localeWeekdaysMin (m) {\n        return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;\n    }\n\n    function handleStrictParse$1(weekdayName, format, strict) {\n        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._minWeekdaysParse = [];\n\n            for (i = 0; i < 7; ++i) {\n                mom = createUTC([2000, 1]).day(i);\n                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();\n                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();\n                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();\n            }\n        }\n\n        if (strict) {\n            if (format === 'dddd') {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === 'ddd') {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === 'dddd') {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === 'ddd') {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n\n    function localeWeekdaysParse (weekdayName, format, strict) {\n        var i, mom, regex;\n\n        if (this._weekdaysParseExact) {\n            return handleStrictParse$1.call(this, weekdayName, format, strict);\n        }\n\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._minWeekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._fullWeekdaysParse = [];\n        }\n\n        for (i = 0; i < 7; i++) {\n            // make the regex if we don't have it already\n\n            mom = createUTC([2000, 1]).day(i);\n            if (strict && !this._fullWeekdaysParse[i]) {\n                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\\\.?') + '$', 'i');\n                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\\\.?') + '$', 'i');\n                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\\\.?') + '$', 'i');\n            }\n            if (!this._weekdaysParse[i]) {\n                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\n                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function getSetDayOfWeek (input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n        if (input != null) {\n            input = parseWeekday(input, this.localeData());\n            return this.add(input - day, 'd');\n        } else {\n            return day;\n        }\n    }\n\n    function getSetLocaleDayOfWeek (input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n        return input == null ? weekday : this.add(input - weekday, 'd');\n    }\n\n    function getSetISODayOfWeek (input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n\n        // behaves the same as moment#day except\n        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n        // as a setter, sunday should belong to the previous week.\n\n        if (input != null) {\n            var weekday = parseIsoWeekday(input, this.localeData());\n            return this.day(this.day() % 7 ? weekday : weekday - 7);\n        } else {\n            return this.day() || 7;\n        }\n    }\n\n    var defaultWeekdaysRegex = matchWord;\n    function weekdaysRegex (isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysStrictRegex;\n            } else {\n                return this._weekdaysRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                this._weekdaysRegex = defaultWeekdaysRegex;\n            }\n            return this._weekdaysStrictRegex && isStrict ?\n                this._weekdaysStrictRegex : this._weekdaysRegex;\n        }\n    }\n\n    var defaultWeekdaysShortRegex = matchWord;\n    function weekdaysShortRegex (isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysShortStrictRegex;\n            } else {\n                return this._weekdaysShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysShortRegex')) {\n                this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n            }\n            return this._weekdaysShortStrictRegex && isStrict ?\n                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\n        }\n    }\n\n    var defaultWeekdaysMinRegex = matchWord;\n    function weekdaysMinRegex (isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysMinStrictRegex;\n            } else {\n                return this._weekdaysMinRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysMinRegex')) {\n                this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n            }\n            return this._weekdaysMinStrictRegex && isStrict ?\n                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\n        }\n    }\n\n\n    function computeWeekdaysParse () {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n\n        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],\n            i, mom, minp, shortp, longp;\n        for (i = 0; i < 7; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, 1]).day(i);\n            minp = this.weekdaysMin(mom, '');\n            shortp = this.weekdaysShort(mom, '');\n            longp = this.weekdays(mom, '');\n            minPieces.push(minp);\n            shortPieces.push(shortp);\n            longPieces.push(longp);\n            mixedPieces.push(minp);\n            mixedPieces.push(shortp);\n            mixedPieces.push(longp);\n        }\n        // Sorting makes sure if one weekday (or abbr) is a prefix of another it\n        // will match the longer piece.\n        minPieces.sort(cmpLenRev);\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n        for (i = 0; i < 7; i++) {\n            shortPieces[i] = regexEscape(shortPieces[i]);\n            longPieces[i] = regexEscape(longPieces[i]);\n            mixedPieces[i] = regexEscape(mixedPieces[i]);\n        }\n\n        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n        this._weekdaysShortRegex = this._weekdaysRegex;\n        this._weekdaysMinRegex = this._weekdaysRegex;\n\n        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');\n    }\n\n    // FORMATTING\n\n    function hFormat() {\n        return this.hours() % 12 || 12;\n    }\n\n    function kFormat() {\n        return this.hours() || 24;\n    }\n\n    addFormatToken('H', ['HH', 2], 0, 'hour');\n    addFormatToken('h', ['hh', 2], 0, hFormat);\n    addFormatToken('k', ['kk', 2], 0, kFormat);\n\n    addFormatToken('hmm', 0, 0, function () {\n        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);\n    });\n\n    addFormatToken('hmmss', 0, 0, function () {\n        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +\n            zeroFill(this.seconds(), 2);\n    });\n\n    addFormatToken('Hmm', 0, 0, function () {\n        return '' + this.hours() + zeroFill(this.minutes(), 2);\n    });\n\n    addFormatToken('Hmmss', 0, 0, function () {\n        return '' + this.hours() + zeroFill(this.minutes(), 2) +\n            zeroFill(this.seconds(), 2);\n    });\n\n    function meridiem (token, lowercase) {\n        addFormatToken(token, 0, 0, function () {\n            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\n        });\n    }\n\n    meridiem('a', true);\n    meridiem('A', false);\n\n    // ALIASES\n\n    addUnitAlias('hour', 'h');\n\n    // PRIORITY\n    addUnitPriority('hour', 13);\n\n    // PARSING\n\n    function matchMeridiem (isStrict, locale) {\n        return locale._meridiemParse;\n    }\n\n    addRegexToken('a',  matchMeridiem);\n    addRegexToken('A',  matchMeridiem);\n    addRegexToken('H',  match1to2);\n    addRegexToken('h',  match1to2);\n    addRegexToken('k',  match1to2);\n    addRegexToken('HH', match1to2, match2);\n    addRegexToken('hh', match1to2, match2);\n    addRegexToken('kk', match1to2, match2);\n\n    addRegexToken('hmm', match3to4);\n    addRegexToken('hmmss', match5to6);\n    addRegexToken('Hmm', match3to4);\n    addRegexToken('Hmmss', match5to6);\n\n    addParseToken(['H', 'HH'], HOUR);\n    addParseToken(['k', 'kk'], function (input, array, config) {\n        var kInput = toInt(input);\n        array[HOUR] = kInput === 24 ? 0 : kInput;\n    });\n    addParseToken(['a', 'A'], function (input, array, config) {\n        config._isPm = config._locale.isPM(input);\n        config._meridiem = input;\n    });\n    addParseToken(['h', 'hh'], function (input, array, config) {\n        array[HOUR] = toInt(input);\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('hmm', function (input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('hmmss', function (input, array, config) {\n        var pos1 = input.length - 4;\n        var pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('Hmm', function (input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n    });\n    addParseToken('Hmmss', function (input, array, config) {\n        var pos1 = input.length - 4;\n        var pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n    });\n\n    // LOCALES\n\n    function localeIsPM (input) {\n        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n        // Using charAt should be more compatible.\n        return ((input + '').toLowerCase().charAt(0) === 'p');\n    }\n\n    var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i;\n    function localeMeridiem (hours, minutes, isLower) {\n        if (hours > 11) {\n            return isLower ? 'pm' : 'PM';\n        } else {\n            return isLower ? 'am' : 'AM';\n        }\n    }\n\n\n    // MOMENTS\n\n    // Setting the hour should keep the time, because the user explicitly\n    // specified which hour they want. So trying to maintain the same hour (in\n    // a new timezone) makes sense. Adding/subtracting hours does not follow\n    // this rule.\n    var getSetHour = makeGetSet('Hours', true);\n\n    var baseConfig = {\n        calendar: defaultCalendar,\n        longDateFormat: defaultLongDateFormat,\n        invalidDate: defaultInvalidDate,\n        ordinal: defaultOrdinal,\n        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\n        relativeTime: defaultRelativeTime,\n\n        months: defaultLocaleMonths,\n        monthsShort: defaultLocaleMonthsShort,\n\n        week: defaultLocaleWeek,\n\n        weekdays: defaultLocaleWeekdays,\n        weekdaysMin: defaultLocaleWeekdaysMin,\n        weekdaysShort: defaultLocaleWeekdaysShort,\n\n        meridiemParse: defaultLocaleMeridiemParse\n    };\n\n    // internal storage for locale config files\n    var locales = {};\n    var localeFamilies = {};\n    var globalLocale;\n\n    function normalizeLocale(key) {\n        return key ? key.toLowerCase().replace('_', '-') : key;\n    }\n\n    // pick the locale from the array\n    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\n    function chooseLocale(names) {\n        var i = 0, j, next, locale, split;\n\n        while (i < names.length) {\n            split = normalizeLocale(names[i]).split('-');\n            j = split.length;\n            next = normalizeLocale(names[i + 1]);\n            next = next ? next.split('-') : null;\n            while (j > 0) {\n                locale = loadLocale(split.slice(0, j).join('-'));\n                if (locale) {\n                    return locale;\n                }\n                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {\n                    //the next array item is better than a shallower substring of this one\n                    break;\n                }\n                j--;\n            }\n            i++;\n        }\n        return globalLocale;\n    }\n\n    function loadLocale(name) {\n        var oldLocale = null;\n        // TODO: Find a better way to register and load all the locales in Node\n        if (!locales[name] && (typeof module !== 'undefined') &&\n                module && module.exports) {\n            try {\n                oldLocale = globalLocale._abbr;\n                var aliasedRequire = require;\n                aliasedRequire('./locale/' + name);\n                getSetGlobalLocale(oldLocale);\n            } catch (e) {}\n        }\n        return locales[name];\n    }\n\n    // This function will load locale and then set the global locale.  If\n    // no arguments are passed in, it will simply return the current global\n    // locale key.\n    function getSetGlobalLocale (key, values) {\n        var data;\n        if (key) {\n            if (isUndefined(values)) {\n                data = getLocale(key);\n            }\n            else {\n                data = defineLocale(key, values);\n            }\n\n            if (data) {\n                // moment.duration._locale = moment._locale = data;\n                globalLocale = data;\n            }\n            else {\n                if ((typeof console !==  'undefined') && console.warn) {\n                    //warn user if arguments are passed but the locale could not be set\n                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');\n                }\n            }\n        }\n\n        return globalLocale._abbr;\n    }\n\n    function defineLocale (name, config) {\n        if (config !== null) {\n            var locale, parentConfig = baseConfig;\n            config.abbr = name;\n            if (locales[name] != null) {\n                deprecateSimple('defineLocaleOverride',\n                        'use moment.updateLocale(localeName, config) to change ' +\n                        'an existing locale. moment.defineLocale(localeName, ' +\n                        'config) should only be used for creating a new locale ' +\n                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');\n                parentConfig = locales[name]._config;\n            } else if (config.parentLocale != null) {\n                if (locales[config.parentLocale] != null) {\n                    parentConfig = locales[config.parentLocale]._config;\n                } else {\n                    locale = loadLocale(config.parentLocale);\n                    if (locale != null) {\n                        parentConfig = locale._config;\n                    } else {\n                        if (!localeFamilies[config.parentLocale]) {\n                            localeFamilies[config.parentLocale] = [];\n                        }\n                        localeFamilies[config.parentLocale].push({\n                            name: name,\n                            config: config\n                        });\n                        return null;\n                    }\n                }\n            }\n            locales[name] = new Locale(mergeConfigs(parentConfig, config));\n\n            if (localeFamilies[name]) {\n                localeFamilies[name].forEach(function (x) {\n                    defineLocale(x.name, x.config);\n                });\n            }\n\n            // backwards compat for now: also set the locale\n            // make sure we set the locale AFTER all child locales have been\n            // created, so we won't end up with the child locale set.\n            getSetGlobalLocale(name);\n\n\n            return locales[name];\n        } else {\n            // useful for testing\n            delete locales[name];\n            return null;\n        }\n    }\n\n    function updateLocale(name, config) {\n        if (config != null) {\n            var locale, tmpLocale, parentConfig = baseConfig;\n            // MERGE\n            tmpLocale = loadLocale(name);\n            if (tmpLocale != null) {\n                parentConfig = tmpLocale._config;\n            }\n            config = mergeConfigs(parentConfig, config);\n            locale = new Locale(config);\n            locale.parentLocale = locales[name];\n            locales[name] = locale;\n\n            // backwards compat for now: also set the locale\n            getSetGlobalLocale(name);\n        } else {\n            // pass null for config to unupdate, useful for tests\n            if (locales[name] != null) {\n                if (locales[name].parentLocale != null) {\n                    locales[name] = locales[name].parentLocale;\n                } else if (locales[name] != null) {\n                    delete locales[name];\n                }\n            }\n        }\n        return locales[name];\n    }\n\n    // returns locale data\n    function getLocale (key) {\n        var locale;\n\n        if (key && key._locale && key._locale._abbr) {\n            key = key._locale._abbr;\n        }\n\n        if (!key) {\n            return globalLocale;\n        }\n\n        if (!isArray(key)) {\n            //short-circuit everything else\n            locale = loadLocale(key);\n            if (locale) {\n                return locale;\n            }\n            key = [key];\n        }\n\n        return chooseLocale(key);\n    }\n\n    function listLocales() {\n        return keys(locales);\n    }\n\n    function checkOverflow (m) {\n        var overflow;\n        var a = m._a;\n\n        if (a && getParsingFlags(m).overflow === -2) {\n            overflow =\n                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :\n                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :\n                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :\n                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :\n                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :\n                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :\n                -1;\n\n            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n                overflow = DATE;\n            }\n            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\n                overflow = WEEK;\n            }\n            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\n                overflow = WEEKDAY;\n            }\n\n            getParsingFlags(m).overflow = overflow;\n        }\n\n        return m;\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function currentDateArray(config) {\n        // hooks is actually the exported moment object\n        var nowValue = new Date(hooks.now());\n        if (config._useUTC) {\n            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];\n        }\n        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\n    }\n\n    // convert an array to a date.\n    // the array should mirror the parameters below\n    // note: all values past the year are optional and will default to the lowest possible value.\n    // [year, month, day , hour, minute, second, millisecond]\n    function configFromArray (config) {\n        var i, date, input = [], currentDate, expectedWeekday, yearToUse;\n\n        if (config._d) {\n            return;\n        }\n\n        currentDate = currentDateArray(config);\n\n        //compute day of the year from weeks and weekdays\n        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n            dayOfYearFromWeekInfo(config);\n        }\n\n        //if the day of the year is set, figure out what it is\n        if (config._dayOfYear != null) {\n            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n\n            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {\n                getParsingFlags(config)._overflowDayOfYear = true;\n            }\n\n            date = createUTCDate(yearToUse, 0, config._dayOfYear);\n            config._a[MONTH] = date.getUTCMonth();\n            config._a[DATE] = date.getUTCDate();\n        }\n\n        // Default to current date.\n        // * if no year, month, day of month are given, default to today\n        // * if day of month is given, default month and year\n        // * if month is given, default only year\n        // * if year is given, don't default anything\n        for (i = 0; i < 3 && config._a[i] == null; ++i) {\n            config._a[i] = input[i] = currentDate[i];\n        }\n\n        // Zero out whatever was not defaulted, including time\n        for (; i < 7; i++) {\n            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\n        }\n\n        // Check for 24:00:00.000\n        if (config._a[HOUR] === 24 &&\n                config._a[MINUTE] === 0 &&\n                config._a[SECOND] === 0 &&\n                config._a[MILLISECOND] === 0) {\n            config._nextDay = true;\n            config._a[HOUR] = 0;\n        }\n\n        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\n        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();\n\n        // Apply timezone offset from input. The actual utcOffset can be changed\n        // with parseZone.\n        if (config._tzm != null) {\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n        }\n\n        if (config._nextDay) {\n            config._a[HOUR] = 24;\n        }\n\n        // check for mismatching day of week\n        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {\n            getParsingFlags(config).weekdayMismatch = true;\n        }\n    }\n\n    function dayOfYearFromWeekInfo(config) {\n        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;\n\n        w = config._w;\n        if (w.GG != null || w.W != null || w.E != null) {\n            dow = 1;\n            doy = 4;\n\n            // TODO: We need to take the current isoWeekYear, but that depends on\n            // how we interpret now (local, utc, fixed offset). So create\n            // a now version of current config (take local/utc/offset flags, and\n            // create now).\n            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);\n            week = defaults(w.W, 1);\n            weekday = defaults(w.E, 1);\n            if (weekday < 1 || weekday > 7) {\n                weekdayOverflow = true;\n            }\n        } else {\n            dow = config._locale._week.dow;\n            doy = config._locale._week.doy;\n\n            var curWeek = weekOfYear(createLocal(), dow, doy);\n\n            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\n\n            // Default to current week.\n            week = defaults(w.w, curWeek.week);\n\n            if (w.d != null) {\n                // weekday -- low day numbers are considered next week\n                weekday = w.d;\n                if (weekday < 0 || weekday > 6) {\n                    weekdayOverflow = true;\n                }\n            } else if (w.e != null) {\n                // local weekday -- counting starts from begining of week\n                weekday = w.e + dow;\n                if (w.e < 0 || w.e > 6) {\n                    weekdayOverflow = true;\n                }\n            } else {\n                // default to begining of week\n                weekday = dow;\n            }\n        }\n        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\n            getParsingFlags(config)._overflowWeeks = true;\n        } else if (weekdayOverflow != null) {\n            getParsingFlags(config)._overflowWeekday = true;\n        } else {\n            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\n            config._a[YEAR] = temp.year;\n            config._dayOfYear = temp.dayOfYear;\n        }\n    }\n\n    // iso 8601 regex\n    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\n    var extendedIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n    var basicIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n\n    var tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/;\n\n    var isoDates = [\n        ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d\\d-\\d\\d/],\n        ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/],\n        ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/],\n        ['GGGG-[W]WW', /\\d{4}-W\\d\\d/, false],\n        ['YYYY-DDD', /\\d{4}-\\d{3}/],\n        ['YYYY-MM', /\\d{4}-\\d\\d/, false],\n        ['YYYYYYMMDD', /[+-]\\d{10}/],\n        ['YYYYMMDD', /\\d{8}/],\n        // YYYYMM is NOT allowed by the standard\n        ['GGGG[W]WWE', /\\d{4}W\\d{3}/],\n        ['GGGG[W]WW', /\\d{4}W\\d{2}/, false],\n        ['YYYYDDD', /\\d{7}/]\n    ];\n\n    // iso time formats and regexes\n    var isoTimes = [\n        ['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n        ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/],\n        ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/],\n        ['HH:mm', /\\d\\d:\\d\\d/],\n        ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/],\n        ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/],\n        ['HHmmss', /\\d\\d\\d\\d\\d\\d/],\n        ['HHmm', /\\d\\d\\d\\d/],\n        ['HH', /\\d\\d/]\n    ];\n\n    var aspNetJsonRegex = /^\\/?Date\\((\\-?\\d+)/i;\n\n    // date from iso format\n    function configFromISO(config) {\n        var i, l,\n            string = config._i,\n            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\n            allowTime, dateFormat, timeFormat, tzFormat;\n\n        if (match) {\n            getParsingFlags(config).iso = true;\n\n            for (i = 0, l = isoDates.length; i < l; i++) {\n                if (isoDates[i][1].exec(match[1])) {\n                    dateFormat = isoDates[i][0];\n                    allowTime = isoDates[i][2] !== false;\n                    break;\n                }\n            }\n            if (dateFormat == null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[3]) {\n                for (i = 0, l = isoTimes.length; i < l; i++) {\n                    if (isoTimes[i][1].exec(match[3])) {\n                        // match[2] should be 'T' or space\n                        timeFormat = (match[2] || ' ') + isoTimes[i][0];\n                        break;\n                    }\n                }\n                if (timeFormat == null) {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            if (!allowTime && timeFormat != null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[4]) {\n                if (tzRegex.exec(match[4])) {\n                    tzFormat = 'Z';\n                } else {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\n            configFromStringAndFormat(config);\n        } else {\n            config._isValid = false;\n        }\n    }\n\n    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\n    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/;\n\n    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\n        var result = [\n            untruncateYear(yearStr),\n            defaultLocaleMonthsShort.indexOf(monthStr),\n            parseInt(dayStr, 10),\n            parseInt(hourStr, 10),\n            parseInt(minuteStr, 10)\n        ];\n\n        if (secondStr) {\n            result.push(parseInt(secondStr, 10));\n        }\n\n        return result;\n    }\n\n    function untruncateYear(yearStr) {\n        var year = parseInt(yearStr, 10);\n        if (year <= 49) {\n            return 2000 + year;\n        } else if (year <= 999) {\n            return 1900 + year;\n        }\n        return year;\n    }\n\n    function preprocessRFC2822(s) {\n        // Remove comments and folding whitespace and replace multiple-spaces with a single space\n        return s.replace(/\\([^)]*\\)|[\\n\\t]/g, ' ').replace(/(\\s\\s+)/g, ' ').replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n    }\n\n    function checkWeekday(weekdayStr, parsedInput, config) {\n        if (weekdayStr) {\n            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.\n            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),\n                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();\n            if (weekdayProvided !== weekdayActual) {\n                getParsingFlags(config).weekdayMismatch = true;\n                config._isValid = false;\n                return false;\n            }\n        }\n        return true;\n    }\n\n    var obsOffsets = {\n        UT: 0,\n        GMT: 0,\n        EDT: -4 * 60,\n        EST: -5 * 60,\n        CDT: -5 * 60,\n        CST: -6 * 60,\n        MDT: -6 * 60,\n        MST: -7 * 60,\n        PDT: -7 * 60,\n        PST: -8 * 60\n    };\n\n    function calculateOffset(obsOffset, militaryOffset, numOffset) {\n        if (obsOffset) {\n            return obsOffsets[obsOffset];\n        } else if (militaryOffset) {\n            // the only allowed military tz is Z\n            return 0;\n        } else {\n            var hm = parseInt(numOffset, 10);\n            var m = hm % 100, h = (hm - m) / 100;\n            return h * 60 + m;\n        }\n    }\n\n    // date and time from ref 2822 format\n    function configFromRFC2822(config) {\n        var match = rfc2822.exec(preprocessRFC2822(config._i));\n        if (match) {\n            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);\n            if (!checkWeekday(match[1], parsedArray, config)) {\n                return;\n            }\n\n            config._a = parsedArray;\n            config._tzm = calculateOffset(match[8], match[9], match[10]);\n\n            config._d = createUTCDate.apply(null, config._a);\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n\n            getParsingFlags(config).rfc2822 = true;\n        } else {\n            config._isValid = false;\n        }\n    }\n\n    // date from iso format or fallback\n    function configFromString(config) {\n        var matched = aspNetJsonRegex.exec(config._i);\n\n        if (matched !== null) {\n            config._d = new Date(+matched[1]);\n            return;\n        }\n\n        configFromISO(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n\n        configFromRFC2822(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n\n        // Final attempt, use Input Fallback\n        hooks.createFromInputFallback(config);\n    }\n\n    hooks.createFromInputFallback = deprecate(\n        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +\n        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +\n        'discouraged and will be removed in an upcoming major release. Please refer to ' +\n        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',\n        function (config) {\n            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n        }\n    );\n\n    // constant that refers to the ISO standard\n    hooks.ISO_8601 = function () {};\n\n    // constant that refers to the RFC 2822 form\n    hooks.RFC_2822 = function () {};\n\n    // date from string and format string\n    function configFromStringAndFormat(config) {\n        // TODO: Move this to another part of the creation flow to prevent circular deps\n        if (config._f === hooks.ISO_8601) {\n            configFromISO(config);\n            return;\n        }\n        if (config._f === hooks.RFC_2822) {\n            configFromRFC2822(config);\n            return;\n        }\n        config._a = [];\n        getParsingFlags(config).empty = true;\n\n        // This array is used to make a Date, either with `new Date` or `Date.UTC`\n        var string = '' + config._i,\n            i, parsedInput, tokens, token, skipped,\n            stringLength = string.length,\n            totalParsedInputLength = 0;\n\n        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n\n        for (i = 0; i < tokens.length; i++) {\n            token = tokens[i];\n            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n            // console.log('token', token, 'parsedInput', parsedInput,\n            //         'regex', getParseRegexForToken(token, config));\n            if (parsedInput) {\n                skipped = string.substr(0, string.indexOf(parsedInput));\n                if (skipped.length > 0) {\n                    getParsingFlags(config).unusedInput.push(skipped);\n                }\n                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n                totalParsedInputLength += parsedInput.length;\n            }\n            // don't parse if it's not a known token\n            if (formatTokenFunctions[token]) {\n                if (parsedInput) {\n                    getParsingFlags(config).empty = false;\n                }\n                else {\n                    getParsingFlags(config).unusedTokens.push(token);\n                }\n                addTimeToArrayFromToken(token, parsedInput, config);\n            }\n            else if (config._strict && !parsedInput) {\n                getParsingFlags(config).unusedTokens.push(token);\n            }\n        }\n\n        // add remaining unparsed input length to the string\n        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n        if (string.length > 0) {\n            getParsingFlags(config).unusedInput.push(string);\n        }\n\n        // clear _12h flag if hour is <= 12\n        if (config._a[HOUR] <= 12 &&\n            getParsingFlags(config).bigHour === true &&\n            config._a[HOUR] > 0) {\n            getParsingFlags(config).bigHour = undefined;\n        }\n\n        getParsingFlags(config).parsedDateParts = config._a.slice(0);\n        getParsingFlags(config).meridiem = config._meridiem;\n        // handle meridiem\n        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\n\n        configFromArray(config);\n        checkOverflow(config);\n    }\n\n\n    function meridiemFixWrap (locale, hour, meridiem) {\n        var isPm;\n\n        if (meridiem == null) {\n            // nothing to do\n            return hour;\n        }\n        if (locale.meridiemHour != null) {\n            return locale.meridiemHour(hour, meridiem);\n        } else if (locale.isPM != null) {\n            // Fallback\n            isPm = locale.isPM(meridiem);\n            if (isPm && hour < 12) {\n                hour += 12;\n            }\n            if (!isPm && hour === 12) {\n                hour = 0;\n            }\n            return hour;\n        } else {\n            // this is not supposed to happen\n            return hour;\n        }\n    }\n\n    // date from string and array of format strings\n    function configFromStringAndArray(config) {\n        var tempConfig,\n            bestMoment,\n\n            scoreToBeat,\n            i,\n            currentScore;\n\n        if (config._f.length === 0) {\n            getParsingFlags(config).invalidFormat = true;\n            config._d = new Date(NaN);\n            return;\n        }\n\n        for (i = 0; i < config._f.length; i++) {\n            currentScore = 0;\n            tempConfig = copyConfig({}, config);\n            if (config._useUTC != null) {\n                tempConfig._useUTC = config._useUTC;\n            }\n            tempConfig._f = config._f[i];\n            configFromStringAndFormat(tempConfig);\n\n            if (!isValid(tempConfig)) {\n                continue;\n            }\n\n            // if there is any input that was not parsed add a penalty for that format\n            currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\n            //or tokens\n            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n\n            getParsingFlags(tempConfig).score = currentScore;\n\n            if (scoreToBeat == null || currentScore < scoreToBeat) {\n                scoreToBeat = currentScore;\n                bestMoment = tempConfig;\n            }\n        }\n\n        extend(config, bestMoment || tempConfig);\n    }\n\n    function configFromObject(config) {\n        if (config._d) {\n            return;\n        }\n\n        var i = normalizeObjectUnits(config._i);\n        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {\n            return obj && parseInt(obj, 10);\n        });\n\n        configFromArray(config);\n    }\n\n    function createFromConfig (config) {\n        var res = new Moment(checkOverflow(prepareConfig(config)));\n        if (res._nextDay) {\n            // Adding is smart enough around DST\n            res.add(1, 'd');\n            res._nextDay = undefined;\n        }\n\n        return res;\n    }\n\n    function prepareConfig (config) {\n        var input = config._i,\n            format = config._f;\n\n        config._locale = config._locale || getLocale(config._l);\n\n        if (input === null || (format === undefined && input === '')) {\n            return createInvalid({nullInput: true});\n        }\n\n        if (typeof input === 'string') {\n            config._i = input = config._locale.preparse(input);\n        }\n\n        if (isMoment(input)) {\n            return new Moment(checkOverflow(input));\n        } else if (isDate(input)) {\n            config._d = input;\n        } else if (isArray(format)) {\n            configFromStringAndArray(config);\n        } else if (format) {\n            configFromStringAndFormat(config);\n        }  else {\n            configFromInput(config);\n        }\n\n        if (!isValid(config)) {\n            config._d = null;\n        }\n\n        return config;\n    }\n\n    function configFromInput(config) {\n        var input = config._i;\n        if (isUndefined(input)) {\n            config._d = new Date(hooks.now());\n        } else if (isDate(input)) {\n            config._d = new Date(input.valueOf());\n        } else if (typeof input === 'string') {\n            configFromString(config);\n        } else if (isArray(input)) {\n            config._a = map(input.slice(0), function (obj) {\n                return parseInt(obj, 10);\n            });\n            configFromArray(config);\n        } else if (isObject(input)) {\n            configFromObject(config);\n        } else if (isNumber(input)) {\n            // from milliseconds\n            config._d = new Date(input);\n        } else {\n            hooks.createFromInputFallback(config);\n        }\n    }\n\n    function createLocalOrUTC (input, format, locale, strict, isUTC) {\n        var c = {};\n\n        if (locale === true || locale === false) {\n            strict = locale;\n            locale = undefined;\n        }\n\n        if ((isObject(input) && isObjectEmpty(input)) ||\n                (isArray(input) && input.length === 0)) {\n            input = undefined;\n        }\n        // object construction must be done this way.\n        // https://github.com/moment/moment/issues/1423\n        c._isAMomentObject = true;\n        c._useUTC = c._isUTC = isUTC;\n        c._l = locale;\n        c._i = input;\n        c._f = format;\n        c._strict = strict;\n\n        return createFromConfig(c);\n    }\n\n    function createLocal (input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, false);\n    }\n\n    var prototypeMin = deprecate(\n        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',\n        function () {\n            var other = createLocal.apply(null, arguments);\n            if (this.isValid() && other.isValid()) {\n                return other < this ? this : other;\n            } else {\n                return createInvalid();\n            }\n        }\n    );\n\n    var prototypeMax = deprecate(\n        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',\n        function () {\n            var other = createLocal.apply(null, arguments);\n            if (this.isValid() && other.isValid()) {\n                return other > this ? this : other;\n            } else {\n                return createInvalid();\n            }\n        }\n    );\n\n    // Pick a moment m from moments so that m[fn](other) is true for all\n    // other. This relies on the function fn to be transitive.\n    //\n    // moments should either be an array of moment objects or an array, whose\n    // first element is an array of moment objects.\n    function pickBy(fn, moments) {\n        var res, i;\n        if (moments.length === 1 && isArray(moments[0])) {\n            moments = moments[0];\n        }\n        if (!moments.length) {\n            return createLocal();\n        }\n        res = moments[0];\n        for (i = 1; i < moments.length; ++i) {\n            if (!moments[i].isValid() || moments[i][fn](res)) {\n                res = moments[i];\n            }\n        }\n        return res;\n    }\n\n    // TODO: Use [].sort instead?\n    function min () {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isBefore', args);\n    }\n\n    function max () {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isAfter', args);\n    }\n\n    var now = function () {\n        return Date.now ? Date.now() : +(new Date());\n    };\n\n    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];\n\n    function isDurationValid(m) {\n        for (var key in m) {\n            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {\n                return false;\n            }\n        }\n\n        var unitHasDecimal = false;\n        for (var i = 0; i < ordering.length; ++i) {\n            if (m[ordering[i]]) {\n                if (unitHasDecimal) {\n                    return false; // only allow non-integers for smallest unit\n                }\n                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\n                    unitHasDecimal = true;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    function isValid$1() {\n        return this._isValid;\n    }\n\n    function createInvalid$1() {\n        return createDuration(NaN);\n    }\n\n    function Duration (duration) {\n        var normalizedInput = normalizeObjectUnits(duration),\n            years = normalizedInput.year || 0,\n            quarters = normalizedInput.quarter || 0,\n            months = normalizedInput.month || 0,\n            weeks = normalizedInput.week || 0,\n            days = normalizedInput.day || 0,\n            hours = normalizedInput.hour || 0,\n            minutes = normalizedInput.minute || 0,\n            seconds = normalizedInput.second || 0,\n            milliseconds = normalizedInput.millisecond || 0;\n\n        this._isValid = isDurationValid(normalizedInput);\n\n        // representation for dateAddRemove\n        this._milliseconds = +milliseconds +\n            seconds * 1e3 + // 1000\n            minutes * 6e4 + // 1000 * 60\n            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\n        // Because of dateAddRemove treats 24 hours as different from a\n        // day when working around DST, we need to store them separately\n        this._days = +days +\n            weeks * 7;\n        // It is impossible to translate months into days without knowing\n        // which months you are are talking about, so we have to store\n        // it separately.\n        this._months = +months +\n            quarters * 3 +\n            years * 12;\n\n        this._data = {};\n\n        this._locale = getLocale();\n\n        this._bubble();\n    }\n\n    function isDuration (obj) {\n        return obj instanceof Duration;\n    }\n\n    function absRound (number) {\n        if (number < 0) {\n            return Math.round(-1 * number) * -1;\n        } else {\n            return Math.round(number);\n        }\n    }\n\n    // FORMATTING\n\n    function offset (token, separator) {\n        addFormatToken(token, 0, 0, function () {\n            var offset = this.utcOffset();\n            var sign = '+';\n            if (offset < 0) {\n                offset = -offset;\n                sign = '-';\n            }\n            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);\n        });\n    }\n\n    offset('Z', ':');\n    offset('ZZ', '');\n\n    // PARSING\n\n    addRegexToken('Z',  matchShortOffset);\n    addRegexToken('ZZ', matchShortOffset);\n    addParseToken(['Z', 'ZZ'], function (input, array, config) {\n        config._useUTC = true;\n        config._tzm = offsetFromString(matchShortOffset, input);\n    });\n\n    // HELPERS\n\n    // timezone chunker\n    // '+10:00' > ['10',  '00']\n    // '-1530'  > ['-15', '30']\n    var chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\n    function offsetFromString(matcher, string) {\n        var matches = (string || '').match(matcher);\n\n        if (matches === null) {\n            return null;\n        }\n\n        var chunk   = matches[matches.length - 1] || [];\n        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n        var minutes = +(parts[1] * 60) + toInt(parts[2]);\n\n        return minutes === 0 ?\n          0 :\n          parts[0] === '+' ? minutes : -minutes;\n    }\n\n    // Return a moment from input, that is local/utc/zone equivalent to model.\n    function cloneWithOffset(input, model) {\n        var res, diff;\n        if (model._isUTC) {\n            res = model.clone();\n            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();\n            // Use low-level api, because this fn is low-level api.\n            res._d.setTime(res._d.valueOf() + diff);\n            hooks.updateOffset(res, false);\n            return res;\n        } else {\n            return createLocal(input).local();\n        }\n    }\n\n    function getDateOffset (m) {\n        // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n        // https://github.com/moment/moment/pull/1871\n        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;\n    }\n\n    // HOOKS\n\n    // This function will be called whenever a moment is mutated.\n    // It is intended to keep the offset in sync with the timezone.\n    hooks.updateOffset = function () {};\n\n    // MOMENTS\n\n    // keepLocalTime = true means only change the timezone, without\n    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n    // +0200, so we adjust the time as needed, to be valid.\n    //\n    // Keeping the time actually adds/subtracts (one hour)\n    // from the actual represented time. That is why we call updateOffset\n    // a second time. In case it wants us to change the offset again\n    // _changeInProgress == true case, then we have to adjust, because\n    // there is no such time in the given timezone.\n    function getSetOffset (input, keepLocalTime, keepMinutes) {\n        var offset = this._offset || 0,\n            localAdjust;\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        if (input != null) {\n            if (typeof input === 'string') {\n                input = offsetFromString(matchShortOffset, input);\n                if (input === null) {\n                    return this;\n                }\n            } else if (Math.abs(input) < 16 && !keepMinutes) {\n                input = input * 60;\n            }\n            if (!this._isUTC && keepLocalTime) {\n                localAdjust = getDateOffset(this);\n            }\n            this._offset = input;\n            this._isUTC = true;\n            if (localAdjust != null) {\n                this.add(localAdjust, 'm');\n            }\n            if (offset !== input) {\n                if (!keepLocalTime || this._changeInProgress) {\n                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);\n                } else if (!this._changeInProgress) {\n                    this._changeInProgress = true;\n                    hooks.updateOffset(this, true);\n                    this._changeInProgress = null;\n                }\n            }\n            return this;\n        } else {\n            return this._isUTC ? offset : getDateOffset(this);\n        }\n    }\n\n    function getSetZone (input, keepLocalTime) {\n        if (input != null) {\n            if (typeof input !== 'string') {\n                input = -input;\n            }\n\n            this.utcOffset(input, keepLocalTime);\n\n            return this;\n        } else {\n            return -this.utcOffset();\n        }\n    }\n\n    function setOffsetToUTC (keepLocalTime) {\n        return this.utcOffset(0, keepLocalTime);\n    }\n\n    function setOffsetToLocal (keepLocalTime) {\n        if (this._isUTC) {\n            this.utcOffset(0, keepLocalTime);\n            this._isUTC = false;\n\n            if (keepLocalTime) {\n                this.subtract(getDateOffset(this), 'm');\n            }\n        }\n        return this;\n    }\n\n    function setOffsetToParsedOffset () {\n        if (this._tzm != null) {\n            this.utcOffset(this._tzm, false, true);\n        } else if (typeof this._i === 'string') {\n            var tZone = offsetFromString(matchOffset, this._i);\n            if (tZone != null) {\n                this.utcOffset(tZone);\n            }\n            else {\n                this.utcOffset(0, true);\n            }\n        }\n        return this;\n    }\n\n    function hasAlignedHourOffset (input) {\n        if (!this.isValid()) {\n            return false;\n        }\n        input = input ? createLocal(input).utcOffset() : 0;\n\n        return (this.utcOffset() - input) % 60 === 0;\n    }\n\n    function isDaylightSavingTime () {\n        return (\n            this.utcOffset() > this.clone().month(0).utcOffset() ||\n            this.utcOffset() > this.clone().month(5).utcOffset()\n        );\n    }\n\n    function isDaylightSavingTimeShifted () {\n        if (!isUndefined(this._isDSTShifted)) {\n            return this._isDSTShifted;\n        }\n\n        var c = {};\n\n        copyConfig(c, this);\n        c = prepareConfig(c);\n\n        if (c._a) {\n            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n            this._isDSTShifted = this.isValid() &&\n                compareArrays(c._a, other.toArray()) > 0;\n        } else {\n            this._isDSTShifted = false;\n        }\n\n        return this._isDSTShifted;\n    }\n\n    function isLocal () {\n        return this.isValid() ? !this._isUTC : false;\n    }\n\n    function isUtcOffset () {\n        return this.isValid() ? this._isUTC : false;\n    }\n\n    function isUtc () {\n        return this.isValid() ? this._isUTC && this._offset === 0 : false;\n    }\n\n    // ASP.NET json date format regex\n    var aspNetRegex = /^(\\-|\\+)?(?:(\\d*)[. ])?(\\d+)\\:(\\d+)(?:\\:(\\d+)(\\.\\d*)?)?$/;\n\n    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n    // and further modified to allow for strings containing both week and day\n    var isoRegex = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n\n    function createDuration (input, key) {\n        var duration = input,\n            // matching against regexp is expensive, do it on demand\n            match = null,\n            sign,\n            ret,\n            diffRes;\n\n        if (isDuration(input)) {\n            duration = {\n                ms : input._milliseconds,\n                d  : input._days,\n                M  : input._months\n            };\n        } else if (isNumber(input)) {\n            duration = {};\n            if (key) {\n                duration[key] = input;\n            } else {\n                duration.milliseconds = input;\n            }\n        } else if (!!(match = aspNetRegex.exec(input))) {\n            sign = (match[1] === '-') ? -1 : 1;\n            duration = {\n                y  : 0,\n                d  : toInt(match[DATE])                         * sign,\n                h  : toInt(match[HOUR])                         * sign,\n                m  : toInt(match[MINUTE])                       * sign,\n                s  : toInt(match[SECOND])                       * sign,\n                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match\n            };\n        } else if (!!(match = isoRegex.exec(input))) {\n            sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;\n            duration = {\n                y : parseIso(match[2], sign),\n                M : parseIso(match[3], sign),\n                w : parseIso(match[4], sign),\n                d : parseIso(match[5], sign),\n                h : parseIso(match[6], sign),\n                m : parseIso(match[7], sign),\n                s : parseIso(match[8], sign)\n            };\n        } else if (duration == null) {// checks for null or undefined\n            duration = {};\n        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {\n            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));\n\n            duration = {};\n            duration.ms = diffRes.milliseconds;\n            duration.M = diffRes.months;\n        }\n\n        ret = new Duration(duration);\n\n        if (isDuration(input) && hasOwnProp(input, '_locale')) {\n            ret._locale = input._locale;\n        }\n\n        return ret;\n    }\n\n    createDuration.fn = Duration.prototype;\n    createDuration.invalid = createInvalid$1;\n\n    function parseIso (inp, sign) {\n        // We'd normally use ~~inp for this, but unfortunately it also\n        // converts floats to ints.\n        // inp may be undefined, so careful calling replace on it.\n        var res = inp && parseFloat(inp.replace(',', '.'));\n        // apply sign while we're at it\n        return (isNaN(res) ? 0 : res) * sign;\n    }\n\n    function positiveMomentsDifference(base, other) {\n        var res = {milliseconds: 0, months: 0};\n\n        res.months = other.month() - base.month() +\n            (other.year() - base.year()) * 12;\n        if (base.clone().add(res.months, 'M').isAfter(other)) {\n            --res.months;\n        }\n\n        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));\n\n        return res;\n    }\n\n    function momentsDifference(base, other) {\n        var res;\n        if (!(base.isValid() && other.isValid())) {\n            return {milliseconds: 0, months: 0};\n        }\n\n        other = cloneWithOffset(other, base);\n        if (base.isBefore(other)) {\n            res = positiveMomentsDifference(base, other);\n        } else {\n            res = positiveMomentsDifference(other, base);\n            res.milliseconds = -res.milliseconds;\n            res.months = -res.months;\n        }\n\n        return res;\n    }\n\n    // TODO: remove 'name' arg after deprecation is removed\n    function createAdder(direction, name) {\n        return function (val, period) {\n            var dur, tmp;\n            //invert the arguments, but complain about it\n            if (period !== null && !isNaN(+period)) {\n                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +\n                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');\n                tmp = val; val = period; period = tmp;\n            }\n\n            val = typeof val === 'string' ? +val : val;\n            dur = createDuration(val, period);\n            addSubtract(this, dur, direction);\n            return this;\n        };\n    }\n\n    function addSubtract (mom, duration, isAdding, updateOffset) {\n        var milliseconds = duration._milliseconds,\n            days = absRound(duration._days),\n            months = absRound(duration._months);\n\n        if (!mom.isValid()) {\n            // No op\n            return;\n        }\n\n        updateOffset = updateOffset == null ? true : updateOffset;\n\n        if (months) {\n            setMonth(mom, get(mom, 'Month') + months * isAdding);\n        }\n        if (days) {\n            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);\n        }\n        if (milliseconds) {\n            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\n        }\n        if (updateOffset) {\n            hooks.updateOffset(mom, days || months);\n        }\n    }\n\n    var add      = createAdder(1, 'add');\n    var subtract = createAdder(-1, 'subtract');\n\n    function getCalendarFormat(myMoment, now) {\n        var diff = myMoment.diff(now, 'days', true);\n        return diff < -6 ? 'sameElse' :\n                diff < -1 ? 'lastWeek' :\n                diff < 0 ? 'lastDay' :\n                diff < 1 ? 'sameDay' :\n                diff < 2 ? 'nextDay' :\n                diff < 7 ? 'nextWeek' : 'sameElse';\n    }\n\n    function calendar$1 (time, formats) {\n        // We want to compare the start of today, vs this.\n        // Getting start-of-today depends on whether we're local/utc/offset or not.\n        var now = time || createLocal(),\n            sod = cloneWithOffset(now, this).startOf('day'),\n            format = hooks.calendarFormat(this, sod) || 'sameElse';\n\n        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);\n\n        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));\n    }\n\n    function clone () {\n        return new Moment(this);\n    }\n\n    function isAfter (input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\n        if (units === 'millisecond') {\n            return this.valueOf() > localInput.valueOf();\n        } else {\n            return localInput.valueOf() < this.clone().startOf(units).valueOf();\n        }\n    }\n\n    function isBefore (input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\n        if (units === 'millisecond') {\n            return this.valueOf() < localInput.valueOf();\n        } else {\n            return this.clone().endOf(units).valueOf() < localInput.valueOf();\n        }\n    }\n\n    function isBetween (from, to, units, inclusivity) {\n        inclusivity = inclusivity || '()';\n        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&\n            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));\n    }\n\n    function isSame (input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input),\n            inputMs;\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units || 'millisecond');\n        if (units === 'millisecond') {\n            return this.valueOf() === localInput.valueOf();\n        } else {\n            inputMs = localInput.valueOf();\n            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();\n        }\n    }\n\n    function isSameOrAfter (input, units) {\n        return this.isSame(input, units) || this.isAfter(input,units);\n    }\n\n    function isSameOrBefore (input, units) {\n        return this.isSame(input, units) || this.isBefore(input,units);\n    }\n\n    function diff (input, units, asFloat) {\n        var that,\n            zoneDelta,\n            output;\n\n        if (!this.isValid()) {\n            return NaN;\n        }\n\n        that = cloneWithOffset(input, this);\n\n        if (!that.isValid()) {\n            return NaN;\n        }\n\n        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\n\n        units = normalizeUnits(units);\n\n        switch (units) {\n            case 'year': output = monthDiff(this, that) / 12; break;\n            case 'month': output = monthDiff(this, that); break;\n            case 'quarter': output = monthDiff(this, that) / 3; break;\n            case 'second': output = (this - that) / 1e3; break; // 1000\n            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60\n            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60\n            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst\n            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst\n            default: output = this - that;\n        }\n\n        return asFloat ? output : absFloor(output);\n    }\n\n    function monthDiff (a, b) {\n        // difference in months\n        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),\n            // b is in (anchor - 1 month, anchor + 1 month)\n            anchor = a.clone().add(wholeMonthDiff, 'months'),\n            anchor2, adjust;\n\n        if (b - anchor < 0) {\n            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor - anchor2);\n        } else {\n            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor2 - anchor);\n        }\n\n        //check for negative zero, return zero if negative zero\n        return -(wholeMonthDiff + adjust) || 0;\n    }\n\n    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\n    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\n\n    function toString () {\n        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\n    }\n\n    function toISOString(keepOffset) {\n        if (!this.isValid()) {\n            return null;\n        }\n        var utc = keepOffset !== true;\n        var m = utc ? this.clone().utc() : this;\n        if (m.year() < 0 || m.year() > 9999) {\n            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');\n        }\n        if (isFunction(Date.prototype.toISOString)) {\n            // native implementation is ~50x faster, use it when we can\n            if (utc) {\n                return this.toDate().toISOString();\n            } else {\n                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));\n            }\n        }\n        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');\n    }\n\n    /**\n     * Return a human readable representation of a moment that can\n     * also be evaluated to get a new moment which is the same\n     *\n     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\n     */\n    function inspect () {\n        if (!this.isValid()) {\n            return 'moment.invalid(/* ' + this._i + ' */)';\n        }\n        var func = 'moment';\n        var zone = '';\n        if (!this.isLocal()) {\n            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';\n            zone = 'Z';\n        }\n        var prefix = '[' + func + '(\"]';\n        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';\n        var datetime = '-MM-DD[T]HH:mm:ss.SSS';\n        var suffix = zone + '[\")]';\n\n        return this.format(prefix + year + datetime + suffix);\n    }\n\n    function format (inputString) {\n        if (!inputString) {\n            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;\n        }\n        var output = formatMoment(this, inputString);\n        return this.localeData().postformat(output);\n    }\n\n    function from (time, withoutSuffix) {\n        if (this.isValid() &&\n                ((isMoment(time) && time.isValid()) ||\n                 createLocal(time).isValid())) {\n            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n\n    function fromNow (withoutSuffix) {\n        return this.from(createLocal(), withoutSuffix);\n    }\n\n    function to (time, withoutSuffix) {\n        if (this.isValid() &&\n                ((isMoment(time) && time.isValid()) ||\n                 createLocal(time).isValid())) {\n            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n\n    function toNow (withoutSuffix) {\n        return this.to(createLocal(), withoutSuffix);\n    }\n\n    // If passed a locale key, it will set the locale for this\n    // instance.  Otherwise, it will return the locale configuration\n    // variables for this instance.\n    function locale (key) {\n        var newLocaleData;\n\n        if (key === undefined) {\n            return this._locale._abbr;\n        } else {\n            newLocaleData = getLocale(key);\n            if (newLocaleData != null) {\n                this._locale = newLocaleData;\n            }\n            return this;\n        }\n    }\n\n    var lang = deprecate(\n        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\n        function (key) {\n            if (key === undefined) {\n                return this.localeData();\n            } else {\n                return this.locale(key);\n            }\n        }\n    );\n\n    function localeData () {\n        return this._locale;\n    }\n\n    function startOf (units) {\n        units = normalizeUnits(units);\n        // the following switch intentionally omits break keywords\n        // to utilize falling through the cases.\n        switch (units) {\n            case 'year':\n                this.month(0);\n                /* falls through */\n            case 'quarter':\n            case 'month':\n                this.date(1);\n                /* falls through */\n            case 'week':\n            case 'isoWeek':\n            case 'day':\n            case 'date':\n                this.hours(0);\n                /* falls through */\n            case 'hour':\n                this.minutes(0);\n                /* falls through */\n            case 'minute':\n                this.seconds(0);\n                /* falls through */\n            case 'second':\n                this.milliseconds(0);\n        }\n\n        // weeks are a special case\n        if (units === 'week') {\n            this.weekday(0);\n        }\n        if (units === 'isoWeek') {\n            this.isoWeekday(1);\n        }\n\n        // quarters are also special\n        if (units === 'quarter') {\n            this.month(Math.floor(this.month() / 3) * 3);\n        }\n\n        return this;\n    }\n\n    function endOf (units) {\n        units = normalizeUnits(units);\n        if (units === undefined || units === 'millisecond') {\n            return this;\n        }\n\n        // 'date' is an alias for 'day', so it should be considered as such.\n        if (units === 'date') {\n            units = 'day';\n        }\n\n        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');\n    }\n\n    function valueOf () {\n        return this._d.valueOf() - ((this._offset || 0) * 60000);\n    }\n\n    function unix () {\n        return Math.floor(this.valueOf() / 1000);\n    }\n\n    function toDate () {\n        return new Date(this.valueOf());\n    }\n\n    function toArray () {\n        var m = this;\n        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];\n    }\n\n    function toObject () {\n        var m = this;\n        return {\n            years: m.year(),\n            months: m.month(),\n            date: m.date(),\n            hours: m.hours(),\n            minutes: m.minutes(),\n            seconds: m.seconds(),\n            milliseconds: m.milliseconds()\n        };\n    }\n\n    function toJSON () {\n        // new Date(NaN).toJSON() === null\n        return this.isValid() ? this.toISOString() : null;\n    }\n\n    function isValid$2 () {\n        return isValid(this);\n    }\n\n    function parsingFlags () {\n        return extend({}, getParsingFlags(this));\n    }\n\n    function invalidAt () {\n        return getParsingFlags(this).overflow;\n    }\n\n    function creationData() {\n        return {\n            input: this._i,\n            format: this._f,\n            locale: this._locale,\n            isUTC: this._isUTC,\n            strict: this._strict\n        };\n    }\n\n    // FORMATTING\n\n    addFormatToken(0, ['gg', 2], 0, function () {\n        return this.weekYear() % 100;\n    });\n\n    addFormatToken(0, ['GG', 2], 0, function () {\n        return this.isoWeekYear() % 100;\n    });\n\n    function addWeekYearFormatToken (token, getter) {\n        addFormatToken(0, [token, token.length], 0, getter);\n    }\n\n    addWeekYearFormatToken('gggg',     'weekYear');\n    addWeekYearFormatToken('ggggg',    'weekYear');\n    addWeekYearFormatToken('GGGG',  'isoWeekYear');\n    addWeekYearFormatToken('GGGGG', 'isoWeekYear');\n\n    // ALIASES\n\n    addUnitAlias('weekYear', 'gg');\n    addUnitAlias('isoWeekYear', 'GG');\n\n    // PRIORITY\n\n    addUnitPriority('weekYear', 1);\n    addUnitPriority('isoWeekYear', 1);\n\n\n    // PARSING\n\n    addRegexToken('G',      matchSigned);\n    addRegexToken('g',      matchSigned);\n    addRegexToken('GG',     match1to2, match2);\n    addRegexToken('gg',     match1to2, match2);\n    addRegexToken('GGGG',   match1to4, match4);\n    addRegexToken('gggg',   match1to4, match4);\n    addRegexToken('GGGGG',  match1to6, match6);\n    addRegexToken('ggggg',  match1to6, match6);\n\n    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {\n        week[token.substr(0, 2)] = toInt(input);\n    });\n\n    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\n        week[token] = hooks.parseTwoDigitYear(input);\n    });\n\n    // MOMENTS\n\n    function getSetWeekYear (input) {\n        return getSetWeekYearHelper.call(this,\n                input,\n                this.week(),\n                this.weekday(),\n                this.localeData()._week.dow,\n                this.localeData()._week.doy);\n    }\n\n    function getSetISOWeekYear (input) {\n        return getSetWeekYearHelper.call(this,\n                input, this.isoWeek(), this.isoWeekday(), 1, 4);\n    }\n\n    function getISOWeeksInYear () {\n        return weeksInYear(this.year(), 1, 4);\n    }\n\n    function getWeeksInYear () {\n        var weekInfo = this.localeData()._week;\n        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n    }\n\n    function getSetWeekYearHelper(input, week, weekday, dow, doy) {\n        var weeksTarget;\n        if (input == null) {\n            return weekOfYear(this, dow, doy).year;\n        } else {\n            weeksTarget = weeksInYear(input, dow, doy);\n            if (week > weeksTarget) {\n                week = weeksTarget;\n            }\n            return setWeekAll.call(this, input, week, weekday, dow, doy);\n        }\n    }\n\n    function setWeekAll(weekYear, week, weekday, dow, doy) {\n        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\n            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n\n        this.year(date.getUTCFullYear());\n        this.month(date.getUTCMonth());\n        this.date(date.getUTCDate());\n        return this;\n    }\n\n    // FORMATTING\n\n    addFormatToken('Q', 0, 'Qo', 'quarter');\n\n    // ALIASES\n\n    addUnitAlias('quarter', 'Q');\n\n    // PRIORITY\n\n    addUnitPriority('quarter', 7);\n\n    // PARSING\n\n    addRegexToken('Q', match1);\n    addParseToken('Q', function (input, array) {\n        array[MONTH] = (toInt(input) - 1) * 3;\n    });\n\n    // MOMENTS\n\n    function getSetQuarter (input) {\n        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n    }\n\n    // FORMATTING\n\n    addFormatToken('D', ['DD', 2], 'Do', 'date');\n\n    // ALIASES\n\n    addUnitAlias('date', 'D');\n\n    // PRIORITY\n    addUnitPriority('date', 9);\n\n    // PARSING\n\n    addRegexToken('D',  match1to2);\n    addRegexToken('DD', match1to2, match2);\n    addRegexToken('Do', function (isStrict, locale) {\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        return isStrict ?\n          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :\n          locale._dayOfMonthOrdinalParseLenient;\n    });\n\n    addParseToken(['D', 'DD'], DATE);\n    addParseToken('Do', function (input, array) {\n        array[DATE] = toInt(input.match(match1to2)[0]);\n    });\n\n    // MOMENTS\n\n    var getSetDayOfMonth = makeGetSet('Date', true);\n\n    // FORMATTING\n\n    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\n\n    // ALIASES\n\n    addUnitAlias('dayOfYear', 'DDD');\n\n    // PRIORITY\n    addUnitPriority('dayOfYear', 4);\n\n    // PARSING\n\n    addRegexToken('DDD',  match1to3);\n    addRegexToken('DDDD', match3);\n    addParseToken(['DDD', 'DDDD'], function (input, array, config) {\n        config._dayOfYear = toInt(input);\n    });\n\n    // HELPERS\n\n    // MOMENTS\n\n    function getSetDayOfYear (input) {\n        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;\n        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');\n    }\n\n    // FORMATTING\n\n    addFormatToken('m', ['mm', 2], 0, 'minute');\n\n    // ALIASES\n\n    addUnitAlias('minute', 'm');\n\n    // PRIORITY\n\n    addUnitPriority('minute', 14);\n\n    // PARSING\n\n    addRegexToken('m',  match1to2);\n    addRegexToken('mm', match1to2, match2);\n    addParseToken(['m', 'mm'], MINUTE);\n\n    // MOMENTS\n\n    var getSetMinute = makeGetSet('Minutes', false);\n\n    // FORMATTING\n\n    addFormatToken('s', ['ss', 2], 0, 'second');\n\n    // ALIASES\n\n    addUnitAlias('second', 's');\n\n    // PRIORITY\n\n    addUnitPriority('second', 15);\n\n    // PARSING\n\n    addRegexToken('s',  match1to2);\n    addRegexToken('ss', match1to2, match2);\n    addParseToken(['s', 'ss'], SECOND);\n\n    // MOMENTS\n\n    var getSetSecond = makeGetSet('Seconds', false);\n\n    // FORMATTING\n\n    addFormatToken('S', 0, 0, function () {\n        return ~~(this.millisecond() / 100);\n    });\n\n    addFormatToken(0, ['SS', 2], 0, function () {\n        return ~~(this.millisecond() / 10);\n    });\n\n    addFormatToken(0, ['SSS', 3], 0, 'millisecond');\n    addFormatToken(0, ['SSSS', 4], 0, function () {\n        return this.millisecond() * 10;\n    });\n    addFormatToken(0, ['SSSSS', 5], 0, function () {\n        return this.millisecond() * 100;\n    });\n    addFormatToken(0, ['SSSSSS', 6], 0, function () {\n        return this.millisecond() * 1000;\n    });\n    addFormatToken(0, ['SSSSSSS', 7], 0, function () {\n        return this.millisecond() * 10000;\n    });\n    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {\n        return this.millisecond() * 100000;\n    });\n    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\n        return this.millisecond() * 1000000;\n    });\n\n\n    // ALIASES\n\n    addUnitAlias('millisecond', 'ms');\n\n    // PRIORITY\n\n    addUnitPriority('millisecond', 16);\n\n    // PARSING\n\n    addRegexToken('S',    match1to3, match1);\n    addRegexToken('SS',   match1to3, match2);\n    addRegexToken('SSS',  match1to3, match3);\n\n    var token;\n    for (token = 'SSSS'; token.length <= 9; token += 'S') {\n        addRegexToken(token, matchUnsigned);\n    }\n\n    function parseMs(input, array) {\n        array[MILLISECOND] = toInt(('0.' + input) * 1000);\n    }\n\n    for (token = 'S'; token.length <= 9; token += 'S') {\n        addParseToken(token, parseMs);\n    }\n    // MOMENTS\n\n    var getSetMillisecond = makeGetSet('Milliseconds', false);\n\n    // FORMATTING\n\n    addFormatToken('z',  0, 0, 'zoneAbbr');\n    addFormatToken('zz', 0, 0, 'zoneName');\n\n    // MOMENTS\n\n    function getZoneAbbr () {\n        return this._isUTC ? 'UTC' : '';\n    }\n\n    function getZoneName () {\n        return this._isUTC ? 'Coordinated Universal Time' : '';\n    }\n\n    var proto = Moment.prototype;\n\n    proto.add               = add;\n    proto.calendar          = calendar$1;\n    proto.clone             = clone;\n    proto.diff              = diff;\n    proto.endOf             = endOf;\n    proto.format            = format;\n    proto.from              = from;\n    proto.fromNow           = fromNow;\n    proto.to                = to;\n    proto.toNow             = toNow;\n    proto.get               = stringGet;\n    proto.invalidAt         = invalidAt;\n    proto.isAfter           = isAfter;\n    proto.isBefore          = isBefore;\n    proto.isBetween         = isBetween;\n    proto.isSame            = isSame;\n    proto.isSameOrAfter     = isSameOrAfter;\n    proto.isSameOrBefore    = isSameOrBefore;\n    proto.isValid           = isValid$2;\n    proto.lang              = lang;\n    proto.locale            = locale;\n    proto.localeData        = localeData;\n    proto.max               = prototypeMax;\n    proto.min               = prototypeMin;\n    proto.parsingFlags      = parsingFlags;\n    proto.set               = stringSet;\n    proto.startOf           = startOf;\n    proto.subtract          = subtract;\n    proto.toArray           = toArray;\n    proto.toObject          = toObject;\n    proto.toDate            = toDate;\n    proto.toISOString       = toISOString;\n    proto.inspect           = inspect;\n    proto.toJSON            = toJSON;\n    proto.toString          = toString;\n    proto.unix              = unix;\n    proto.valueOf           = valueOf;\n    proto.creationData      = creationData;\n    proto.year       = getSetYear;\n    proto.isLeapYear = getIsLeapYear;\n    proto.weekYear    = getSetWeekYear;\n    proto.isoWeekYear = getSetISOWeekYear;\n    proto.quarter = proto.quarters = getSetQuarter;\n    proto.month       = getSetMonth;\n    proto.daysInMonth = getDaysInMonth;\n    proto.week           = proto.weeks        = getSetWeek;\n    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;\n    proto.weeksInYear    = getWeeksInYear;\n    proto.isoWeeksInYear = getISOWeeksInYear;\n    proto.date       = getSetDayOfMonth;\n    proto.day        = proto.days             = getSetDayOfWeek;\n    proto.weekday    = getSetLocaleDayOfWeek;\n    proto.isoWeekday = getSetISODayOfWeek;\n    proto.dayOfYear  = getSetDayOfYear;\n    proto.hour = proto.hours = getSetHour;\n    proto.minute = proto.minutes = getSetMinute;\n    proto.second = proto.seconds = getSetSecond;\n    proto.millisecond = proto.milliseconds = getSetMillisecond;\n    proto.utcOffset            = getSetOffset;\n    proto.utc                  = setOffsetToUTC;\n    proto.local                = setOffsetToLocal;\n    proto.parseZone            = setOffsetToParsedOffset;\n    proto.hasAlignedHourOffset = hasAlignedHourOffset;\n    proto.isDST                = isDaylightSavingTime;\n    proto.isLocal              = isLocal;\n    proto.isUtcOffset          = isUtcOffset;\n    proto.isUtc                = isUtc;\n    proto.isUTC                = isUtc;\n    proto.zoneAbbr = getZoneAbbr;\n    proto.zoneName = getZoneName;\n    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);\n    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);\n    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);\n    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);\n    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);\n\n    function createUnix (input) {\n        return createLocal(input * 1000);\n    }\n\n    function createInZone () {\n        return createLocal.apply(null, arguments).parseZone();\n    }\n\n    function preParsePostFormat (string) {\n        return string;\n    }\n\n    var proto$1 = Locale.prototype;\n\n    proto$1.calendar        = calendar;\n    proto$1.longDateFormat  = longDateFormat;\n    proto$1.invalidDate     = invalidDate;\n    proto$1.ordinal         = ordinal;\n    proto$1.preparse        = preParsePostFormat;\n    proto$1.postformat      = preParsePostFormat;\n    proto$1.relativeTime    = relativeTime;\n    proto$1.pastFuture      = pastFuture;\n    proto$1.set             = set;\n\n    proto$1.months            =        localeMonths;\n    proto$1.monthsShort       =        localeMonthsShort;\n    proto$1.monthsParse       =        localeMonthsParse;\n    proto$1.monthsRegex       = monthsRegex;\n    proto$1.monthsShortRegex  = monthsShortRegex;\n    proto$1.week = localeWeek;\n    proto$1.firstDayOfYear = localeFirstDayOfYear;\n    proto$1.firstDayOfWeek = localeFirstDayOfWeek;\n\n    proto$1.weekdays       =        localeWeekdays;\n    proto$1.weekdaysMin    =        localeWeekdaysMin;\n    proto$1.weekdaysShort  =        localeWeekdaysShort;\n    proto$1.weekdaysParse  =        localeWeekdaysParse;\n\n    proto$1.weekdaysRegex       =        weekdaysRegex;\n    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;\n    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;\n\n    proto$1.isPM = localeIsPM;\n    proto$1.meridiem = localeMeridiem;\n\n    function get$1 (format, index, field, setter) {\n        var locale = getLocale();\n        var utc = createUTC().set(setter, index);\n        return locale[field](utc, format);\n    }\n\n    function listMonthsImpl (format, index, field) {\n        if (isNumber(format)) {\n            index = format;\n            format = undefined;\n        }\n\n        format = format || '';\n\n        if (index != null) {\n            return get$1(format, index, field, 'month');\n        }\n\n        var i;\n        var out = [];\n        for (i = 0; i < 12; i++) {\n            out[i] = get$1(format, i, field, 'month');\n        }\n        return out;\n    }\n\n    // ()\n    // (5)\n    // (fmt, 5)\n    // (fmt)\n    // (true)\n    // (true, 5)\n    // (true, fmt, 5)\n    // (true, fmt)\n    function listWeekdaysImpl (localeSorted, format, index, field) {\n        if (typeof localeSorted === 'boolean') {\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n\n            format = format || '';\n        } else {\n            format = localeSorted;\n            index = format;\n            localeSorted = false;\n\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n\n            format = format || '';\n        }\n\n        var locale = getLocale(),\n            shift = localeSorted ? locale._week.dow : 0;\n\n        if (index != null) {\n            return get$1(format, (index + shift) % 7, field, 'day');\n        }\n\n        var i;\n        var out = [];\n        for (i = 0; i < 7; i++) {\n            out[i] = get$1(format, (i + shift) % 7, field, 'day');\n        }\n        return out;\n    }\n\n    function listMonths (format, index) {\n        return listMonthsImpl(format, index, 'months');\n    }\n\n    function listMonthsShort (format, index) {\n        return listMonthsImpl(format, index, 'monthsShort');\n    }\n\n    function listWeekdays (localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\n    }\n\n    function listWeekdaysShort (localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\n    }\n\n    function listWeekdaysMin (localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');\n    }\n\n    getSetGlobalLocale('en', {\n        dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\n        ordinal : function (number) {\n            var b = number % 10,\n                output = (toInt(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n            return number + output;\n        }\n    });\n\n    // Side effect imports\n\n    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);\n    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);\n\n    var mathAbs = Math.abs;\n\n    function abs () {\n        var data           = this._data;\n\n        this._milliseconds = mathAbs(this._milliseconds);\n        this._days         = mathAbs(this._days);\n        this._months       = mathAbs(this._months);\n\n        data.milliseconds  = mathAbs(data.milliseconds);\n        data.seconds       = mathAbs(data.seconds);\n        data.minutes       = mathAbs(data.minutes);\n        data.hours         = mathAbs(data.hours);\n        data.months        = mathAbs(data.months);\n        data.years         = mathAbs(data.years);\n\n        return this;\n    }\n\n    function addSubtract$1 (duration, input, value, direction) {\n        var other = createDuration(input, value);\n\n        duration._milliseconds += direction * other._milliseconds;\n        duration._days         += direction * other._days;\n        duration._months       += direction * other._months;\n\n        return duration._bubble();\n    }\n\n    // supports only 2.0-style add(1, 's') or add(duration)\n    function add$1 (input, value) {\n        return addSubtract$1(this, input, value, 1);\n    }\n\n    // supports only 2.0-style subtract(1, 's') or subtract(duration)\n    function subtract$1 (input, value) {\n        return addSubtract$1(this, input, value, -1);\n    }\n\n    function absCeil (number) {\n        if (number < 0) {\n            return Math.floor(number);\n        } else {\n            return Math.ceil(number);\n        }\n    }\n\n    function bubble () {\n        var milliseconds = this._milliseconds;\n        var days         = this._days;\n        var months       = this._months;\n        var data         = this._data;\n        var seconds, minutes, hours, years, monthsFromDays;\n\n        // if we have a mix of positive and negative values, bubble down first\n        // check: https://github.com/moment/moment/issues/2166\n        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||\n                (milliseconds <= 0 && days <= 0 && months <= 0))) {\n            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n            days = 0;\n            months = 0;\n        }\n\n        // The following code bubbles up values, see the tests for\n        // examples of what that means.\n        data.milliseconds = milliseconds % 1000;\n\n        seconds           = absFloor(milliseconds / 1000);\n        data.seconds      = seconds % 60;\n\n        minutes           = absFloor(seconds / 60);\n        data.minutes      = minutes % 60;\n\n        hours             = absFloor(minutes / 60);\n        data.hours        = hours % 24;\n\n        days += absFloor(hours / 24);\n\n        // convert days to months\n        monthsFromDays = absFloor(daysToMonths(days));\n        months += monthsFromDays;\n        days -= absCeil(monthsToDays(monthsFromDays));\n\n        // 12 months -> 1 year\n        years = absFloor(months / 12);\n        months %= 12;\n\n        data.days   = days;\n        data.months = months;\n        data.years  = years;\n\n        return this;\n    }\n\n    function daysToMonths (days) {\n        // 400 years have 146097 days (taking into account leap year rules)\n        // 400 years have 12 months === 4800\n        return days * 4800 / 146097;\n    }\n\n    function monthsToDays (months) {\n        // the reverse of daysToMonths\n        return months * 146097 / 4800;\n    }\n\n    function as (units) {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        var days;\n        var months;\n        var milliseconds = this._milliseconds;\n\n        units = normalizeUnits(units);\n\n        if (units === 'month' || units === 'year') {\n            days   = this._days   + milliseconds / 864e5;\n            months = this._months + daysToMonths(days);\n            return units === 'month' ? months : months / 12;\n        } else {\n            // handle milliseconds separately because of floating point math errors (issue #1867)\n            days = this._days + Math.round(monthsToDays(this._months));\n            switch (units) {\n                case 'week'   : return days / 7     + milliseconds / 6048e5;\n                case 'day'    : return days         + milliseconds / 864e5;\n                case 'hour'   : return days * 24    + milliseconds / 36e5;\n                case 'minute' : return days * 1440  + milliseconds / 6e4;\n                case 'second' : return days * 86400 + milliseconds / 1000;\n                // Math.floor prevents floating point math errors here\n                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;\n                default: throw new Error('Unknown unit ' + units);\n            }\n        }\n    }\n\n    // TODO: Use this.as('ms')?\n    function valueOf$1 () {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        return (\n            this._milliseconds +\n            this._days * 864e5 +\n            (this._months % 12) * 2592e6 +\n            toInt(this._months / 12) * 31536e6\n        );\n    }\n\n    function makeAs (alias) {\n        return function () {\n            return this.as(alias);\n        };\n    }\n\n    var asMilliseconds = makeAs('ms');\n    var asSeconds      = makeAs('s');\n    var asMinutes      = makeAs('m');\n    var asHours        = makeAs('h');\n    var asDays         = makeAs('d');\n    var asWeeks        = makeAs('w');\n    var asMonths       = makeAs('M');\n    var asYears        = makeAs('y');\n\n    function clone$1 () {\n        return createDuration(this);\n    }\n\n    function get$2 (units) {\n        units = normalizeUnits(units);\n        return this.isValid() ? this[units + 's']() : NaN;\n    }\n\n    function makeGetter(name) {\n        return function () {\n            return this.isValid() ? this._data[name] : NaN;\n        };\n    }\n\n    var milliseconds = makeGetter('milliseconds');\n    var seconds      = makeGetter('seconds');\n    var minutes      = makeGetter('minutes');\n    var hours        = makeGetter('hours');\n    var days         = makeGetter('days');\n    var months       = makeGetter('months');\n    var years        = makeGetter('years');\n\n    function weeks () {\n        return absFloor(this.days() / 7);\n    }\n\n    var round = Math.round;\n    var thresholds = {\n        ss: 44,         // a few seconds to seconds\n        s : 45,         // seconds to minute\n        m : 45,         // minutes to hour\n        h : 22,         // hours to day\n        d : 26,         // days to month\n        M : 11          // months to year\n    };\n\n    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n    }\n\n    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {\n        var duration = createDuration(posNegDuration).abs();\n        var seconds  = round(duration.as('s'));\n        var minutes  = round(duration.as('m'));\n        var hours    = round(duration.as('h'));\n        var days     = round(duration.as('d'));\n        var months   = round(duration.as('M'));\n        var years    = round(duration.as('y'));\n\n        var a = seconds <= thresholds.ss && ['s', seconds]  ||\n                seconds < thresholds.s   && ['ss', seconds] ||\n                minutes <= 1             && ['m']           ||\n                minutes < thresholds.m   && ['mm', minutes] ||\n                hours   <= 1             && ['h']           ||\n                hours   < thresholds.h   && ['hh', hours]   ||\n                days    <= 1             && ['d']           ||\n                days    < thresholds.d   && ['dd', days]    ||\n                months  <= 1             && ['M']           ||\n                months  < thresholds.M   && ['MM', months]  ||\n                years   <= 1             && ['y']           || ['yy', years];\n\n        a[2] = withoutSuffix;\n        a[3] = +posNegDuration > 0;\n        a[4] = locale;\n        return substituteTimeAgo.apply(null, a);\n    }\n\n    // This function allows you to set the rounding function for relative time strings\n    function getSetRelativeTimeRounding (roundingFunction) {\n        if (roundingFunction === undefined) {\n            return round;\n        }\n        if (typeof(roundingFunction) === 'function') {\n            round = roundingFunction;\n            return true;\n        }\n        return false;\n    }\n\n    // This function allows you to set a threshold for relative time strings\n    function getSetRelativeTimeThreshold (threshold, limit) {\n        if (thresholds[threshold] === undefined) {\n            return false;\n        }\n        if (limit === undefined) {\n            return thresholds[threshold];\n        }\n        thresholds[threshold] = limit;\n        if (threshold === 's') {\n            thresholds.ss = limit - 1;\n        }\n        return true;\n    }\n\n    function humanize (withSuffix) {\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n\n        var locale = this.localeData();\n        var output = relativeTime$1(this, !withSuffix, locale);\n\n        if (withSuffix) {\n            output = locale.pastFuture(+this, output);\n        }\n\n        return locale.postformat(output);\n    }\n\n    var abs$1 = Math.abs;\n\n    function sign(x) {\n        return ((x > 0) - (x < 0)) || +x;\n    }\n\n    function toISOString$1() {\n        // for ISO strings we do not use the normal bubbling rules:\n        //  * milliseconds bubble up until they become hours\n        //  * days do not bubble at all\n        //  * months bubble up until they become years\n        // This is because there is no context-free conversion between hours and days\n        // (think of clock changes)\n        // and also not between days and months (28-31 days per month)\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n\n        var seconds = abs$1(this._milliseconds) / 1000;\n        var days         = abs$1(this._days);\n        var months       = abs$1(this._months);\n        var minutes, hours, years;\n\n        // 3600 seconds -> 60 minutes -> 1 hour\n        minutes           = absFloor(seconds / 60);\n        hours             = absFloor(minutes / 60);\n        seconds %= 60;\n        minutes %= 60;\n\n        // 12 months -> 1 year\n        years  = absFloor(months / 12);\n        months %= 12;\n\n\n        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n        var Y = years;\n        var M = months;\n        var D = days;\n        var h = hours;\n        var m = minutes;\n        var s = seconds ? seconds.toFixed(3).replace(/\\.?0+$/, '') : '';\n        var total = this.asSeconds();\n\n        if (!total) {\n            // this is the same as C#'s (Noda) and python (isodate)...\n            // but not other JS (goog.date)\n            return 'P0D';\n        }\n\n        var totalSign = total < 0 ? '-' : '';\n        var ymSign = sign(this._months) !== sign(total) ? '-' : '';\n        var daysSign = sign(this._days) !== sign(total) ? '-' : '';\n        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';\n\n        return totalSign + 'P' +\n            (Y ? ymSign + Y + 'Y' : '') +\n            (M ? ymSign + M + 'M' : '') +\n            (D ? daysSign + D + 'D' : '') +\n            ((h || m || s) ? 'T' : '') +\n            (h ? hmsSign + h + 'H' : '') +\n            (m ? hmsSign + m + 'M' : '') +\n            (s ? hmsSign + s + 'S' : '');\n    }\n\n    var proto$2 = Duration.prototype;\n\n    proto$2.isValid        = isValid$1;\n    proto$2.abs            = abs;\n    proto$2.add            = add$1;\n    proto$2.subtract       = subtract$1;\n    proto$2.as             = as;\n    proto$2.asMilliseconds = asMilliseconds;\n    proto$2.asSeconds      = asSeconds;\n    proto$2.asMinutes      = asMinutes;\n    proto$2.asHours        = asHours;\n    proto$2.asDays         = asDays;\n    proto$2.asWeeks        = asWeeks;\n    proto$2.asMonths       = asMonths;\n    proto$2.asYears        = asYears;\n    proto$2.valueOf        = valueOf$1;\n    proto$2._bubble        = bubble;\n    proto$2.clone          = clone$1;\n    proto$2.get            = get$2;\n    proto$2.milliseconds   = milliseconds;\n    proto$2.seconds        = seconds;\n    proto$2.minutes        = minutes;\n    proto$2.hours          = hours;\n    proto$2.days           = days;\n    proto$2.weeks          = weeks;\n    proto$2.months         = months;\n    proto$2.years          = years;\n    proto$2.humanize       = humanize;\n    proto$2.toISOString    = toISOString$1;\n    proto$2.toString       = toISOString$1;\n    proto$2.toJSON         = toISOString$1;\n    proto$2.locale         = locale;\n    proto$2.localeData     = localeData;\n\n    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);\n    proto$2.lang = lang;\n\n    // Side effect imports\n\n    // FORMATTING\n\n    addFormatToken('X', 0, 0, 'unix');\n    addFormatToken('x', 0, 0, 'valueOf');\n\n    // PARSING\n\n    addRegexToken('x', matchSigned);\n    addRegexToken('X', matchTimestamp);\n    addParseToken('X', function (input, array, config) {\n        config._d = new Date(parseFloat(input, 10) * 1000);\n    });\n    addParseToken('x', function (input, array, config) {\n        config._d = new Date(toInt(input));\n    });\n\n    // Side effect imports\n\n\n    hooks.version = '2.22.2';\n\n    setHookCallback(createLocal);\n\n    hooks.fn                    = proto;\n    hooks.min                   = min;\n    hooks.max                   = max;\n    hooks.now                   = now;\n    hooks.utc                   = createUTC;\n    hooks.unix                  = createUnix;\n    hooks.months                = listMonths;\n    hooks.isDate                = isDate;\n    hooks.locale                = getSetGlobalLocale;\n    hooks.invalid               = createInvalid;\n    hooks.duration              = createDuration;\n    hooks.isMoment              = isMoment;\n    hooks.weekdays              = listWeekdays;\n    hooks.parseZone             = createInZone;\n    hooks.localeData            = getLocale;\n    hooks.isDuration            = isDuration;\n    hooks.monthsShort           = listMonthsShort;\n    hooks.weekdaysMin           = listWeekdaysMin;\n    hooks.defineLocale          = defineLocale;\n    hooks.updateLocale          = updateLocale;\n    hooks.locales               = listLocales;\n    hooks.weekdaysShort         = listWeekdaysShort;\n    hooks.normalizeUnits        = normalizeUnits;\n    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;\n    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\n    hooks.calendarFormat        = getCalendarFormat;\n    hooks.prototype             = proto;\n\n    // currently HTML5 input type only supports 24-hour formats\n    hooks.HTML5_FMT = {\n        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type=\"datetime-local\" />\n        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type=\"datetime-local\" step=\"1\" />\n        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type=\"datetime-local\" step=\"0.001\" />\n        DATE: 'YYYY-MM-DD',                             // <input type=\"date\" />\n        TIME: 'HH:mm',                                  // <input type=\"time\" />\n        TIME_SECONDS: 'HH:mm:ss',                       // <input type=\"time\" step=\"1\" />\n        TIME_MS: 'HH:mm:ss.SSS',                        // <input type=\"time\" step=\"0.001\" />\n        WEEK: 'YYYY-[W]WW',                             // <input type=\"week\" />\n        MONTH: 'YYYY-MM'                                // <input type=\"month\" />\n    };\n\n    return hooks;\n\n})));\n\n},{}]},{},[3])\n\n","import BaseView from \"../../lib/baseview\"\n\nclass View extends BaseView {\n\n    constructor (element, options) {\n        super(element, options);\n        this.bindEvents();\n        console.log('Component: Periodlist', this, options);\n    }\n\n    bindEvents() {\n        this.$main.off('click').on('click', '.report-period--show-all', (ev) => {\n            ev.preventDefault();\n            ev.stopPropagation();\n            this.$main.find('.report-period--show-all').hide();\n            this.$main.find(\".report-period--table tr\").removeClass('hide');\n        })\n    }\n}\n\nexport default View;\n","import BaseView from \"../../lib/baseview\"\nimport Chartjs from \"chart.js\"\n\nclass View extends BaseView {\n\n    constructor (element, options) {\n        super(element, options);\n        this.bindEvents();\n        console.log('Component: Warehouse report', this, options);\n        this.$.find(\".chartist\").text('[Initializing chart...]');\n        this.data = JSON.parse(this.$.find(\".chartist\").attr('data-chartist'));\n        this.$.find(\".chartist\").attr('data-chartist', '');\n        //this.renderChartist(data);\n        this.renderChartjs();\n    }\n\n    bindEvents() {\n        //this.$main.off('click').on('click', '.report-period--show-all', (ev) => {\n        //    ev.preventDefault();\n        //    ev.stopPropagation();\n        //    this.$main.find('.report-period--show-all').hide();\n        //    this.$main.find(\".report-period--table tr\").removeClass('hide');\n        //})\n    }\n\n    reduceToField(number) {\n        return (list, items) => {\n            list.push(items[number]);\n            return list;\n        }\n    }\n\n    getLabelInfo(label) {\n        for (const info of this.data.dictionary) {\n            if (info.variable == label) {\n                return info;\n            }\n        }\n        throw \"WarehouseReport: Label \" + label + \" not found\"\n    }\n\n    getListByLabel(label) {\n        const info = this.getLabelInfo(label);\n        const list = this.data.data.reduce(this.reduceToField(info.position), []);\n        return list;\n    }\n\n    renderChartjs() {\n        console.log(this.data);\n        console.log(this.data.visualization.ylabel);\n        const labels = this.getListByLabel(this.data.visualization.xlabel[0]);\n        const datasets = [];\n        const colorlist = [\n            '#008cca',\n            '#ffacaa',\n            '#d0eaca',\n            '#c2c2c2',\n            '#efc10f',\n        ];\n        for (const datalabel of this.data.visualization.ylabel) {\n            const dataset = {};\n            console.log(datalabel);\n            dataset.label = this.getLabelInfo(datalabel).description;\n            dataset.data = this.getListByLabel(datalabel);\n            dataset.borderColor = colorlist.shift();\n            dataset.fill = false;\n            datasets.push(dataset);\n        }\n        this.$.find(\".chartist\").html('<canvas></canvas>&nbsp;');\n        this.$.find(\".chartist\").css({\n            \"position\": \"relative\",\n            \"width\": \"100%\",\n            \"height\": \"550px\"\n        });\n        const $canvas = this.$.find(\".chartist canvas\");\n        const canvascontext = $canvas[0].getContext('2d');\n        console.log(datasets);\n        new Chartjs(canvascontext, {\n            type: 'line',\n            data: {\n                labels: labels,\n                datasets: datasets\n            },\n            options: {\n                legend: {\n                    display: true,\n                    labels: {\n                        boxWidth: 12,\n                        usePointStyle: false\n                    }\n                },\n                tooltips: {\n                    mode: \"index\"\n                }\n            }\n        });\n    }\n}\n\nexport default View;\n","// --------------------------------------------------------\n// ZMS Statistic behavior\n// --------------------------------------------------------\n\nimport 'babel-polyfill';\n\n// Import base libs\nimport window from \"window\";\nimport $ from \"jquery\";\nimport moment from 'moment'\nimport 'moment/locale/de';\n//import bindReact from './lib/bindReact.js'\nimport { getDataAttributes } from './lib/utils'\nimport { forceHttps } from './lib/utils'\n\nimport PeriodListView from './block/periodlist'\nimport WarehouseReportView from './block/warehousereport'\n\n// Bind jQuery on $ for testing\nwindow.$ = $;\n\nmoment.locale('de')\n\n// Force https protocol\nforceHttps();\n\n// Say hello\nconsole.log(\"Welcome to the ZMS statistics interface...\");\n\n$('.report-period').each(function() {\n    new PeriodListView(this, getDataAttributes(this));\n})\n\n$('.warehouse-report').each(function() {\n    new WarehouseReportView(this, getDataAttributes(this));\n})\n","import $ from \"jquery\";\nimport BindHandler from \"./bindHandler\";\nimport ExceptionHandler from './exceptionHandler';\nimport DialogHandler from './dialogHandler';\nimport { lightbox, showSpinner, hideSpinner } from './utils';\nimport { noOp } from './utils'\n\nclass BaseView extends BindHandler {\n\n    constructor(element, options = {}) {\n        super();\n        this.$main = $(element);\n        this.$main.off();\n        this.options = options;\n        this.loadPromise = Promise.reject(null).catch(noOp);\n    }\n\n    get $ () {\n        return this.$main;\n    }\n\n    loadCall(url, method = 'GET', data = null, spinner = false) {\n        return BaseView.loadCallStatic(url, method, data, spinner, this);\n    }\n\n    static loadCallStatic(url, method = 'GET', data = null, spinner = false, parent) {\n        if (spinner) {\n            showSpinner(parent.$main);\n        }\n        const ajaxSettings = {\n            method\n        };\n        if (method === 'POST' || method === 'PUT') {\n            ajaxSettings.data = data;\n        }\n        return new Promise((resolve, reject) => {\n            $.ajax(url, ajaxSettings).done(responseData => {\n                resolve(responseData);\n            }).fail(err => {\n                let isException = err.responseText.toLowerCase().includes('exception');\n                if (err.status >= 400 && isException) {\n                    new ExceptionHandler(parent.$main, {\n                        code: err.status,\n                        message: err.responseText,\n                        parent: parent\n                    });\n                    hideSpinner(parent.$main);\n                } else {\n                    console.log('XHR load error', url, err);\n                    reject(err);\n                }\n            })\n        });\n    }\n\n    static loadDialogStatic (response, callback, parent, callbackAsBackgroundAction = false) {\n        var $container = null;\n        var $loader = null;\n        if (parent) {\n            $container = parent.$main;\n            $loader = parent.loadCall;\n        }\n\n        const { lightboxContentElement, destroyLightbox } = lightbox($container, () => {\n            destroyLightbox(),\n            (callbackAsBackgroundAction) ? callback() : () => {}\n        });\n        new DialogHandler(lightboxContentElement, {\n            response: response,\n            callback: () => {\n                callback();\n                destroyLightbox();\n            },\n            parent: parent,\n            loader: $loader,\n            handleLightbox: destroyLightbox\n        })\n    }\n}\n\nexport default BaseView;\n","\n\nclass BindHandler {\n\n    bindPublicMethods (...methods) {\n        let object = this;\n        methods.forEach( function (method) {\n            if (typeof object[method] !== 'function') {\n                throw \"Method not found: \" + method;\n            }\n            object[method] = object[method].bind(object);\n        });\n    }\n}\n\nexport default BindHandler;\n","import $ from 'jquery';\nimport ExceptionHandler from './exceptionHandler'\nimport settings from '../settings' \n\nclass DialogHandler {\n\n    constructor (element, options) {\n        this.$main = $(element);\n        this.response = options.response;\n        this.callback = options.callback || (() => {});\n        this.parent = options.parent;\n        this.loader = options.loader || (() => {});\n        this.handleLightbox = options.handleLightbox || (() => {});\n        this.bindEvents();\n        this.render();\n    }\n\n    render() {\n        DialogHandler.hideMessages(true);\n        var content = $(this.response).filter('div.dialog');\n        if (content.length == 0) {\n            var message = $(this.response).find('div.dialog');\n            if (message.length > 0) {\n                content = message.get(0).outerHTML;\n            }\n        }\n        if (content.length == 0) {\n            new ExceptionHandler(this.$main, {'message': this.response});\n        } else {\n            this.$main.html(content);\n        }\n    }\n\n    bindEvents() {\n        this.$main.off().on('click', '.button-ok', (ev) => {\n            ev.preventDefault();\n            ev.stopPropagation();\n            this.callback(ev);\n        }).on('click', '.button-abort', (ev) => {\n            ev.preventDefault();\n            ev.stopPropagation();\n            this.handleLightbox();\n        }).on('click', '.button-callback', (ev) => {\n            ev.preventDefault();\n            ev.stopPropagation();\n            var callback = $(ev.target).data('callback');\n            this.callback = this.parent[callback];\n            this.callback(ev);\n        });\n    }\n\n    static hideMessages(instant = false)\n    {\n        let message = $.find('.message, .dialog');\n        if (message.length && ! instant) {\n            setTimeout(() => {\n                $(message).not('.message-keep').fadeOut().remove();\n            }, settings.hideMessageTime * 1000)\n        } else if (message.length && instant) {\n            $(message).not('.message-keep').fadeOut().remove();\n        }\n    }\n}\n\nexport default DialogHandler\n","import $ from 'jquery'\n\nclass ExceptionHandler {\n\n    constructor (element, options) {\n        this.$main = $(element)\n        this.message = options.message;\n        this.parent = options.parent || this.$main;\n        this.code = options.code;\n        this.callback = options.callback || this.closeException;\n        this.bindEvents();\n        this.render();\n    }\n\n    render() {\n        var $message = $(this.message).filter('div.exception');\n        if ($message.length == 0) {\n            $message = $(this.message).find('div.exception');\n        }\n\n        this.$messageElement = $($message.get(0).outerHTML);\n        this.$main.find('.dialog','.exception').remove();\n        this.$main.find('.body').first().prepend(this.$messageElement);\n        var $buttons = this.$messageElement.find('.btn');\n        if ($buttons.length == 0) {\n            $buttons = $('<a class=\"btn button-cancel right\">X</a>');\n            this.$messageElement.find('.header').append($buttons);\n        }\n        $buttons.on('click', (ev) => {\n            ev.preventDefault();\n            ev.stopPropagation();\n            var callback = $(ev.target).data('callback');\n            if (this.parent[callback])\n                this.callback = this.parent[callback];\n            this.callback(ev);\n        })\n        /*setTimeout(() => {\n            this.closeException();\n        },8000)\n        */\n    }\n\n    closeException() {\n        if (this.$messageElement) {\n            this.$messageElement.remove();\n        }\n    }\n\n    bindEvents() {\n    }\n}\n\nexport default ExceptionHandler\n","import Baseview from './baseview';\nimport $ from 'jquery'\nimport moment from 'moment'\nimport settings from '../settings';\n\nexport const timeToFloat = (time) => {\n    const momentTime = moment(time, 'HH:mm:ss')\n\n    return momentTime.hours() + (momentTime.minutes() / 60)\n}\n\nexport const timestampToFloat = timestamp => {\n    const momentTime = moment(timestamp, 'X')\n\n    return momentTime.hours() + (momentTime.minutes() / 60)\n}\n\nexport const range = (start, end, step = 1) => {\n    const result = []\n    for (let i = start; i <= end; i += step) {\n        result.push(i)\n    }\n\n    return result\n}\n\nexport const deepGet = (obj, path = []) => path.reduce((carry, current) => carry ? carry[current] : undefined, obj)\n\nconst attributesToArray = attributes => Array.prototype.slice.call(attributes, 0)\n\nexport const getDataAttributes = (element) => {\n    const attributes = attributesToArray(element.attributes)\n    const dataRegex = /^data-/i\n\n    return attributes\n        .filter(attribute => (dataRegex.test(attribute.nodeName)))\n        .map(attribute => [\n            attribute.name.replace(dataRegex, ''),\n            attribute.value]\n        )\n        .reduce((carry, [key, value]) => {\n            carry[key] = tryJson(value)\n            return carry\n        }, {})\n}\n\nexport const tryJson = (input) => {\n    try {\n        return JSON.parse(input)\n    } catch (e) {\n        return input\n    }\n}\n\nconst lightboxHtml = '<div class=\"lightbox\"><div class=\"lightbox__content\"></div></div>'\n\nexport const lightbox = (parentElement, onBackgroundClick) => {\n    const lightboxElement = $(lightboxHtml)\n\n    if (!parentElement) {\n        parentElement = $('body')\n        lightboxElement.addClass('fixed')\n    }\n\n    const destroyLightbox = () => {\n        lightboxElement.off()\n        lightboxElement.remove()\n    }\n\n    const lightboxContentElement = lightboxElement.find('.lightbox__content');\n\n    lightboxElement.on('click', (ev) => {\n        console.log('background click', ev);\n        ev.stopPropagation()\n        ev.preventDefault()\n        destroyLightbox()\n        onBackgroundClick()\n    }).on('click', '.lightbox__content', (ev) => {\n        ev.stopPropagation();\n    })\n\n    $(parentElement).append(lightboxElement)\n\n    return {\n        lightboxContentElement,\n        destroyLightbox\n    }\n}\n\nexport const noOp = () => {}\n\nexport const getUrlParameters = () => {\n    return document.location.search.replace(/^\\?/, \"\")\n                   .split(\"&\")\n                   .reduce((carry, current) => {\n                       const [key, value] = current.split('=')\n\n                       if (key) {\n                           return Object.assign({}, carry, {[key]: value})\n                       } else {\n                           return carry\n                       }\n                   }, {})\n}\n\nexport const forceHttps = () => {\n    if (document.location.protocol !== \"https:\") {\n        Baseview.loadCallStatic(`${settings.includeUrl}/dialog/?template=force_https`).then((response) => {\n            Baseview.loadDialogStatic(response,\n                () => {\n                    document.location.href = \"https://\" + document.location.href.substring(document.location.protocol.length, document.location.href.length);\n                },\n                Baseview,\n                true\n            );\n        });\n    }\n}\n","\nexport default {\n    'includeUrl': '/terminvereinbarung/statistic'\n};\n","/* MIT license */\nvar convert = require('color-convert');\nvar string = require('chartjs-color-string');\n\nvar Color = function (obj) {\n\tif (obj instanceof Color) {\n\t\treturn obj;\n\t}\n\tif (!(this instanceof Color)) {\n\t\treturn new Color(obj);\n\t}\n\n\tthis.valid = false;\n\tthis.values = {\n\t\trgb: [0, 0, 0],\n\t\thsl: [0, 0, 0],\n\t\thsv: [0, 0, 0],\n\t\thwb: [0, 0, 0],\n\t\tcmyk: [0, 0, 0, 0],\n\t\talpha: 1\n\t};\n\n\t// parse Color() argument\n\tvar vals;\n\tif (typeof obj === 'string') {\n\t\tvals = string.getRgba(obj);\n\t\tif (vals) {\n\t\t\tthis.setValues('rgb', vals);\n\t\t} else if (vals = string.getHsla(obj)) {\n\t\t\tthis.setValues('hsl', vals);\n\t\t} else if (vals = string.getHwb(obj)) {\n\t\t\tthis.setValues('hwb', vals);\n\t\t}\n\t} else if (typeof obj === 'object') {\n\t\tvals = obj;\n\t\tif (vals.r !== undefined || vals.red !== undefined) {\n\t\t\tthis.setValues('rgb', vals);\n\t\t} else if (vals.l !== undefined || vals.lightness !== undefined) {\n\t\t\tthis.setValues('hsl', vals);\n\t\t} else if (vals.v !== undefined || vals.value !== undefined) {\n\t\t\tthis.setValues('hsv', vals);\n\t\t} else if (vals.w !== undefined || vals.whiteness !== undefined) {\n\t\t\tthis.setValues('hwb', vals);\n\t\t} else if (vals.c !== undefined || vals.cyan !== undefined) {\n\t\t\tthis.setValues('cmyk', vals);\n\t\t}\n\t}\n};\n\nColor.prototype = {\n\tisValid: function () {\n\t\treturn this.valid;\n\t},\n\trgb: function () {\n\t\treturn this.setSpace('rgb', arguments);\n\t},\n\thsl: function () {\n\t\treturn this.setSpace('hsl', arguments);\n\t},\n\thsv: function () {\n\t\treturn this.setSpace('hsv', arguments);\n\t},\n\thwb: function () {\n\t\treturn this.setSpace('hwb', arguments);\n\t},\n\tcmyk: function () {\n\t\treturn this.setSpace('cmyk', arguments);\n\t},\n\n\trgbArray: function () {\n\t\treturn this.values.rgb;\n\t},\n\thslArray: function () {\n\t\treturn this.values.hsl;\n\t},\n\thsvArray: function () {\n\t\treturn this.values.hsv;\n\t},\n\thwbArray: function () {\n\t\tvar values = this.values;\n\t\tif (values.alpha !== 1) {\n\t\t\treturn values.hwb.concat([values.alpha]);\n\t\t}\n\t\treturn values.hwb;\n\t},\n\tcmykArray: function () {\n\t\treturn this.values.cmyk;\n\t},\n\trgbaArray: function () {\n\t\tvar values = this.values;\n\t\treturn values.rgb.concat([values.alpha]);\n\t},\n\thslaArray: function () {\n\t\tvar values = this.values;\n\t\treturn values.hsl.concat([values.alpha]);\n\t},\n\talpha: function (val) {\n\t\tif (val === undefined) {\n\t\t\treturn this.values.alpha;\n\t\t}\n\t\tthis.setValues('alpha', val);\n\t\treturn this;\n\t},\n\n\tred: function (val) {\n\t\treturn this.setChannel('rgb', 0, val);\n\t},\n\tgreen: function (val) {\n\t\treturn this.setChannel('rgb', 1, val);\n\t},\n\tblue: function (val) {\n\t\treturn this.setChannel('rgb', 2, val);\n\t},\n\thue: function (val) {\n\t\tif (val) {\n\t\t\tval %= 360;\n\t\t\tval = val < 0 ? 360 + val : val;\n\t\t}\n\t\treturn this.setChannel('hsl', 0, val);\n\t},\n\tsaturation: function (val) {\n\t\treturn this.setChannel('hsl', 1, val);\n\t},\n\tlightness: function (val) {\n\t\treturn this.setChannel('hsl', 2, val);\n\t},\n\tsaturationv: function (val) {\n\t\treturn this.setChannel('hsv', 1, val);\n\t},\n\twhiteness: function (val) {\n\t\treturn this.setChannel('hwb', 1, val);\n\t},\n\tblackness: function (val) {\n\t\treturn this.setChannel('hwb', 2, val);\n\t},\n\tvalue: function (val) {\n\t\treturn this.setChannel('hsv', 2, val);\n\t},\n\tcyan: function (val) {\n\t\treturn this.setChannel('cmyk', 0, val);\n\t},\n\tmagenta: function (val) {\n\t\treturn this.setChannel('cmyk', 1, val);\n\t},\n\tyellow: function (val) {\n\t\treturn this.setChannel('cmyk', 2, val);\n\t},\n\tblack: function (val) {\n\t\treturn this.setChannel('cmyk', 3, val);\n\t},\n\n\thexString: function () {\n\t\treturn string.hexString(this.values.rgb);\n\t},\n\trgbString: function () {\n\t\treturn string.rgbString(this.values.rgb, this.values.alpha);\n\t},\n\trgbaString: function () {\n\t\treturn string.rgbaString(this.values.rgb, this.values.alpha);\n\t},\n\tpercentString: function () {\n\t\treturn string.percentString(this.values.rgb, this.values.alpha);\n\t},\n\thslString: function () {\n\t\treturn string.hslString(this.values.hsl, this.values.alpha);\n\t},\n\thslaString: function () {\n\t\treturn string.hslaString(this.values.hsl, this.values.alpha);\n\t},\n\thwbString: function () {\n\t\treturn string.hwbString(this.values.hwb, this.values.alpha);\n\t},\n\tkeyword: function () {\n\t\treturn string.keyword(this.values.rgb, this.values.alpha);\n\t},\n\n\trgbNumber: function () {\n\t\tvar rgb = this.values.rgb;\n\t\treturn (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];\n\t},\n\n\tluminosity: function () {\n\t\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\n\t\tvar rgb = this.values.rgb;\n\t\tvar lum = [];\n\t\tfor (var i = 0; i < rgb.length; i++) {\n\t\t\tvar chan = rgb[i] / 255;\n\t\t\tlum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);\n\t\t}\n\t\treturn 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n\t},\n\n\tcontrast: function (color2) {\n\t\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n\t\tvar lum1 = this.luminosity();\n\t\tvar lum2 = color2.luminosity();\n\t\tif (lum1 > lum2) {\n\t\t\treturn (lum1 + 0.05) / (lum2 + 0.05);\n\t\t}\n\t\treturn (lum2 + 0.05) / (lum1 + 0.05);\n\t},\n\n\tlevel: function (color2) {\n\t\tvar contrastRatio = this.contrast(color2);\n\t\tif (contrastRatio >= 7.1) {\n\t\t\treturn 'AAA';\n\t\t}\n\n\t\treturn (contrastRatio >= 4.5) ? 'AA' : '';\n\t},\n\n\tdark: function () {\n\t\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\n\t\tvar rgb = this.values.rgb;\n\t\tvar yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\n\t\treturn yiq < 128;\n\t},\n\n\tlight: function () {\n\t\treturn !this.dark();\n\t},\n\n\tnegate: function () {\n\t\tvar rgb = [];\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\trgb[i] = 255 - this.values.rgb[i];\n\t\t}\n\t\tthis.setValues('rgb', rgb);\n\t\treturn this;\n\t},\n\n\tlighten: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[2] += hsl[2] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tdarken: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[2] -= hsl[2] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tsaturate: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[1] += hsl[1] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tdesaturate: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[1] -= hsl[1] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\twhiten: function (ratio) {\n\t\tvar hwb = this.values.hwb;\n\t\thwb[1] += hwb[1] * ratio;\n\t\tthis.setValues('hwb', hwb);\n\t\treturn this;\n\t},\n\n\tblacken: function (ratio) {\n\t\tvar hwb = this.values.hwb;\n\t\thwb[2] += hwb[2] * ratio;\n\t\tthis.setValues('hwb', hwb);\n\t\treturn this;\n\t},\n\n\tgreyscale: function () {\n\t\tvar rgb = this.values.rgb;\n\t\t// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n\t\tvar val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n\t\tthis.setValues('rgb', [val, val, val]);\n\t\treturn this;\n\t},\n\n\tclearer: function (ratio) {\n\t\tvar alpha = this.values.alpha;\n\t\tthis.setValues('alpha', alpha - (alpha * ratio));\n\t\treturn this;\n\t},\n\n\topaquer: function (ratio) {\n\t\tvar alpha = this.values.alpha;\n\t\tthis.setValues('alpha', alpha + (alpha * ratio));\n\t\treturn this;\n\t},\n\n\trotate: function (degrees) {\n\t\tvar hsl = this.values.hsl;\n\t\tvar hue = (hsl[0] + degrees) % 360;\n\t\thsl[0] = hue < 0 ? 360 + hue : hue;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\t/**\n\t * Ported from sass implementation in C\n\t * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\n\t */\n\tmix: function (mixinColor, weight) {\n\t\tvar color1 = this;\n\t\tvar color2 = mixinColor;\n\t\tvar p = weight === undefined ? 0.5 : weight;\n\n\t\tvar w = 2 * p - 1;\n\t\tvar a = color1.alpha() - color2.alpha();\n\n\t\tvar w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n\t\tvar w2 = 1 - w1;\n\n\t\treturn this\n\t\t\t.rgb(\n\t\t\t\tw1 * color1.red() + w2 * color2.red(),\n\t\t\t\tw1 * color1.green() + w2 * color2.green(),\n\t\t\t\tw1 * color1.blue() + w2 * color2.blue()\n\t\t\t)\n\t\t\t.alpha(color1.alpha() * p + color2.alpha() * (1 - p));\n\t},\n\n\ttoJSON: function () {\n\t\treturn this.rgb();\n\t},\n\n\tclone: function () {\n\t\t// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,\n\t\t// making the final build way to big to embed in Chart.js. So let's do it manually,\n\t\t// assuming that values to clone are 1 dimension arrays containing only numbers,\n\t\t// except 'alpha' which is a number.\n\t\tvar result = new Color();\n\t\tvar source = this.values;\n\t\tvar target = result.values;\n\t\tvar value, type;\n\n\t\tfor (var prop in source) {\n\t\t\tif (source.hasOwnProperty(prop)) {\n\t\t\t\tvalue = source[prop];\n\t\t\t\ttype = ({}).toString.call(value);\n\t\t\t\tif (type === '[object Array]') {\n\t\t\t\t\ttarget[prop] = value.slice(0);\n\t\t\t\t} else if (type === '[object Number]') {\n\t\t\t\t\ttarget[prop] = value;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error('unexpected color value:', value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n};\n\nColor.prototype.spaces = {\n\trgb: ['red', 'green', 'blue'],\n\thsl: ['hue', 'saturation', 'lightness'],\n\thsv: ['hue', 'saturation', 'value'],\n\thwb: ['hue', 'whiteness', 'blackness'],\n\tcmyk: ['cyan', 'magenta', 'yellow', 'black']\n};\n\nColor.prototype.maxes = {\n\trgb: [255, 255, 255],\n\thsl: [360, 100, 100],\n\thsv: [360, 100, 100],\n\thwb: [360, 100, 100],\n\tcmyk: [100, 100, 100, 100]\n};\n\nColor.prototype.getValues = function (space) {\n\tvar values = this.values;\n\tvar vals = {};\n\n\tfor (var i = 0; i < space.length; i++) {\n\t\tvals[space.charAt(i)] = values[space][i];\n\t}\n\n\tif (values.alpha !== 1) {\n\t\tvals.a = values.alpha;\n\t}\n\n\t// {r: 255, g: 255, b: 255, a: 0.4}\n\treturn vals;\n};\n\nColor.prototype.setValues = function (space, vals) {\n\tvar values = this.values;\n\tvar spaces = this.spaces;\n\tvar maxes = this.maxes;\n\tvar alpha = 1;\n\tvar i;\n\n\tthis.valid = true;\n\n\tif (space === 'alpha') {\n\t\talpha = vals;\n\t} else if (vals.length) {\n\t\t// [10, 10, 10]\n\t\tvalues[space] = vals.slice(0, space.length);\n\t\talpha = vals[space.length];\n\t} else if (vals[space.charAt(0)] !== undefined) {\n\t\t// {r: 10, g: 10, b: 10}\n\t\tfor (i = 0; i < space.length; i++) {\n\t\t\tvalues[space][i] = vals[space.charAt(i)];\n\t\t}\n\n\t\talpha = vals.a;\n\t} else if (vals[spaces[space][0]] !== undefined) {\n\t\t// {red: 10, green: 10, blue: 10}\n\t\tvar chans = spaces[space];\n\n\t\tfor (i = 0; i < space.length; i++) {\n\t\t\tvalues[space][i] = vals[chans[i]];\n\t\t}\n\n\t\talpha = vals.alpha;\n\t}\n\n\tvalues.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));\n\n\tif (space === 'alpha') {\n\t\treturn false;\n\t}\n\n\tvar capped;\n\n\t// cap values of the space prior converting all values\n\tfor (i = 0; i < space.length; i++) {\n\t\tcapped = Math.max(0, Math.min(maxes[space][i], values[space][i]));\n\t\tvalues[space][i] = Math.round(capped);\n\t}\n\n\t// convert to all the other color spaces\n\tfor (var sname in spaces) {\n\t\tif (sname !== space) {\n\t\t\tvalues[sname] = convert[space][sname](values[space]);\n\t\t}\n\t}\n\n\treturn true;\n};\n\nColor.prototype.setSpace = function (space, args) {\n\tvar vals = args[0];\n\n\tif (vals === undefined) {\n\t\t// color.rgb()\n\t\treturn this.getValues(space);\n\t}\n\n\t// color.rgb(10, 10, 10)\n\tif (typeof vals === 'number') {\n\t\tvals = Array.prototype.slice.call(args);\n\t}\n\n\tthis.setValues(space, vals);\n\treturn this;\n};\n\nColor.prototype.setChannel = function (space, index, val) {\n\tvar svalues = this.values[space];\n\tif (val === undefined) {\n\t\t// color.red()\n\t\treturn svalues[index];\n\t} else if (val === svalues[index]) {\n\t\t// color.red(color.red())\n\t\treturn this;\n\t}\n\n\t// color.red(100)\n\tsvalues[index] = val;\n\tthis.setValues(space, svalues);\n\n\treturn this;\n};\n\nif (typeof window !== 'undefined') {\n\twindow.Color = Color;\n}\n\nmodule.exports = Color;\n","/* MIT license */\nvar colorNames = require('color-name');\n\nmodule.exports = {\n   getRgba: getRgba,\n   getHsla: getHsla,\n   getRgb: getRgb,\n   getHsl: getHsl,\n   getHwb: getHwb,\n   getAlpha: getAlpha,\n\n   hexString: hexString,\n   rgbString: rgbString,\n   rgbaString: rgbaString,\n   percentString: percentString,\n   percentaString: percentaString,\n   hslString: hslString,\n   hslaString: hslaString,\n   hwbString: hwbString,\n   keyword: keyword\n}\n\nfunction getRgba(string) {\n   if (!string) {\n      return;\n   }\n   var abbr =  /^#([a-fA-F0-9]{3})$/i,\n       hex =  /^#([a-fA-F0-9]{6})$/i,\n       rgba = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/i,\n       per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/i,\n       keyword = /(\\w+)/;\n\n   var rgb = [0, 0, 0],\n       a = 1,\n       match = string.match(abbr);\n   if (match) {\n      match = match[1];\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = parseInt(match[i] + match[i], 16);\n      }\n   }\n   else if (match = string.match(hex)) {\n      match = match[1];\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);\n      }\n   }\n   else if (match = string.match(rgba)) {\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = parseInt(match[i + 1]);\n      }\n      a = parseFloat(match[4]);\n   }\n   else if (match = string.match(per)) {\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\n      }\n      a = parseFloat(match[4]);\n   }\n   else if (match = string.match(keyword)) {\n      if (match[1] == \"transparent\") {\n         return [0, 0, 0, 0];\n      }\n      rgb = colorNames[match[1]];\n      if (!rgb) {\n         return;\n      }\n   }\n\n   for (var i = 0; i < rgb.length; i++) {\n      rgb[i] = scale(rgb[i], 0, 255);\n   }\n   if (!a && a != 0) {\n      a = 1;\n   }\n   else {\n      a = scale(a, 0, 1);\n   }\n   rgb[3] = a;\n   return rgb;\n}\n\nfunction getHsla(string) {\n   if (!string) {\n      return;\n   }\n   var hsl = /^hsla?\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n   var match = string.match(hsl);\n   if (match) {\n      var alpha = parseFloat(match[4]);\n      var h = scale(parseInt(match[1]), 0, 360),\n          s = scale(parseFloat(match[2]), 0, 100),\n          l = scale(parseFloat(match[3]), 0, 100),\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\n      return [h, s, l, a];\n   }\n}\n\nfunction getHwb(string) {\n   if (!string) {\n      return;\n   }\n   var hwb = /^hwb\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n   var match = string.match(hwb);\n   if (match) {\n    var alpha = parseFloat(match[4]);\n      var h = scale(parseInt(match[1]), 0, 360),\n          w = scale(parseFloat(match[2]), 0, 100),\n          b = scale(parseFloat(match[3]), 0, 100),\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\n      return [h, w, b, a];\n   }\n}\n\nfunction getRgb(string) {\n   var rgba = getRgba(string);\n   return rgba && rgba.slice(0, 3);\n}\n\nfunction getHsl(string) {\n  var hsla = getHsla(string);\n  return hsla && hsla.slice(0, 3);\n}\n\nfunction getAlpha(string) {\n   var vals = getRgba(string);\n   if (vals) {\n      return vals[3];\n   }\n   else if (vals = getHsla(string)) {\n      return vals[3];\n   }\n   else if (vals = getHwb(string)) {\n      return vals[3];\n   }\n}\n\n// generators\nfunction hexString(rgb) {\n   return \"#\" + hexDouble(rgb[0]) + hexDouble(rgb[1])\n              + hexDouble(rgb[2]);\n}\n\nfunction rgbString(rgba, alpha) {\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\n      return rgbaString(rgba, alpha);\n   }\n   return \"rgb(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2] + \")\";\n}\n\nfunction rgbaString(rgba, alpha) {\n   if (alpha === undefined) {\n      alpha = (rgba[3] !== undefined ? rgba[3] : 1);\n   }\n   return \"rgba(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2]\n           + \", \" + alpha + \")\";\n}\n\nfunction percentString(rgba, alpha) {\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\n      return percentaString(rgba, alpha);\n   }\n   var r = Math.round(rgba[0]/255 * 100),\n       g = Math.round(rgba[1]/255 * 100),\n       b = Math.round(rgba[2]/255 * 100);\n\n   return \"rgb(\" + r + \"%, \" + g + \"%, \" + b + \"%)\";\n}\n\nfunction percentaString(rgba, alpha) {\n   var r = Math.round(rgba[0]/255 * 100),\n       g = Math.round(rgba[1]/255 * 100),\n       b = Math.round(rgba[2]/255 * 100);\n   return \"rgba(\" + r + \"%, \" + g + \"%, \" + b + \"%, \" + (alpha || rgba[3] || 1) + \")\";\n}\n\nfunction hslString(hsla, alpha) {\n   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {\n      return hslaString(hsla, alpha);\n   }\n   return \"hsl(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%)\";\n}\n\nfunction hslaString(hsla, alpha) {\n   if (alpha === undefined) {\n      alpha = (hsla[3] !== undefined ? hsla[3] : 1);\n   }\n   return \"hsla(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%, \"\n           + alpha + \")\";\n}\n\n// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\n// (hwb have alpha optional & 1 is default value)\nfunction hwbString(hwb, alpha) {\n   if (alpha === undefined) {\n      alpha = (hwb[3] !== undefined ? hwb[3] : 1);\n   }\n   return \"hwb(\" + hwb[0] + \", \" + hwb[1] + \"%, \" + hwb[2] + \"%\"\n           + (alpha !== undefined && alpha !== 1 ? \", \" + alpha : \"\") + \")\";\n}\n\nfunction keyword(rgb) {\n  return reverseNames[rgb.slice(0, 3)];\n}\n\n// helpers\nfunction scale(num, min, max) {\n   return Math.min(Math.max(min, num), max);\n}\n\nfunction hexDouble(num) {\n  var str = num.toString(16).toUpperCase();\n  return (str.length < 2) ? \"0\" + str : str;\n}\n\n\n//create a list of reverse color names\nvar reverseNames = {};\nfor (var name in colorNames) {\n   reverseNames[colorNames[name]] = name;\n}\n","'use strict'\r\n\r\nmodule.exports = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\r\n","/* MIT license */\n\nmodule.exports = {\n  rgb2hsl: rgb2hsl,\n  rgb2hsv: rgb2hsv,\n  rgb2hwb: rgb2hwb,\n  rgb2cmyk: rgb2cmyk,\n  rgb2keyword: rgb2keyword,\n  rgb2xyz: rgb2xyz,\n  rgb2lab: rgb2lab,\n  rgb2lch: rgb2lch,\n\n  hsl2rgb: hsl2rgb,\n  hsl2hsv: hsl2hsv,\n  hsl2hwb: hsl2hwb,\n  hsl2cmyk: hsl2cmyk,\n  hsl2keyword: hsl2keyword,\n\n  hsv2rgb: hsv2rgb,\n  hsv2hsl: hsv2hsl,\n  hsv2hwb: hsv2hwb,\n  hsv2cmyk: hsv2cmyk,\n  hsv2keyword: hsv2keyword,\n\n  hwb2rgb: hwb2rgb,\n  hwb2hsl: hwb2hsl,\n  hwb2hsv: hwb2hsv,\n  hwb2cmyk: hwb2cmyk,\n  hwb2keyword: hwb2keyword,\n\n  cmyk2rgb: cmyk2rgb,\n  cmyk2hsl: cmyk2hsl,\n  cmyk2hsv: cmyk2hsv,\n  cmyk2hwb: cmyk2hwb,\n  cmyk2keyword: cmyk2keyword,\n\n  keyword2rgb: keyword2rgb,\n  keyword2hsl: keyword2hsl,\n  keyword2hsv: keyword2hsv,\n  keyword2hwb: keyword2hwb,\n  keyword2cmyk: keyword2cmyk,\n  keyword2lab: keyword2lab,\n  keyword2xyz: keyword2xyz,\n\n  xyz2rgb: xyz2rgb,\n  xyz2lab: xyz2lab,\n  xyz2lch: xyz2lch,\n\n  lab2xyz: lab2xyz,\n  lab2rgb: lab2rgb,\n  lab2lch: lab2lch,\n\n  lch2lab: lch2lab,\n  lch2xyz: lch2xyz,\n  lch2rgb: lch2rgb\n}\n\n\nfunction rgb2hsl(rgb) {\n  var r = rgb[0]/255,\n      g = rgb[1]/255,\n      b = rgb[2]/255,\n      min = Math.min(r, g, b),\n      max = Math.max(r, g, b),\n      delta = max - min,\n      h, s, l;\n\n  if (max == min)\n    h = 0;\n  else if (r == max)\n    h = (g - b) / delta;\n  else if (g == max)\n    h = 2 + (b - r) / delta;\n  else if (b == max)\n    h = 4 + (r - g)/ delta;\n\n  h = Math.min(h * 60, 360);\n\n  if (h < 0)\n    h += 360;\n\n  l = (min + max) / 2;\n\n  if (max == min)\n    s = 0;\n  else if (l <= 0.5)\n    s = delta / (max + min);\n  else\n    s = delta / (2 - max - min);\n\n  return [h, s * 100, l * 100];\n}\n\nfunction rgb2hsv(rgb) {\n  var r = rgb[0],\n      g = rgb[1],\n      b = rgb[2],\n      min = Math.min(r, g, b),\n      max = Math.max(r, g, b),\n      delta = max - min,\n      h, s, v;\n\n  if (max == 0)\n    s = 0;\n  else\n    s = (delta/max * 1000)/10;\n\n  if (max == min)\n    h = 0;\n  else if (r == max)\n    h = (g - b) / delta;\n  else if (g == max)\n    h = 2 + (b - r) / delta;\n  else if (b == max)\n    h = 4 + (r - g) / delta;\n\n  h = Math.min(h * 60, 360);\n\n  if (h < 0)\n    h += 360;\n\n  v = ((max / 255) * 1000) / 10;\n\n  return [h, s, v];\n}\n\nfunction rgb2hwb(rgb) {\n  var r = rgb[0],\n      g = rgb[1],\n      b = rgb[2],\n      h = rgb2hsl(rgb)[0],\n      w = 1/255 * Math.min(r, Math.min(g, b)),\n      b = 1 - 1/255 * Math.max(r, Math.max(g, b));\n\n  return [h, w * 100, b * 100];\n}\n\nfunction rgb2cmyk(rgb) {\n  var r = rgb[0] / 255,\n      g = rgb[1] / 255,\n      b = rgb[2] / 255,\n      c, m, y, k;\n\n  k = Math.min(1 - r, 1 - g, 1 - b);\n  c = (1 - r - k) / (1 - k) || 0;\n  m = (1 - g - k) / (1 - k) || 0;\n  y = (1 - b - k) / (1 - k) || 0;\n  return [c * 100, m * 100, y * 100, k * 100];\n}\n\nfunction rgb2keyword(rgb) {\n  return reverseKeywords[JSON.stringify(rgb)];\n}\n\nfunction rgb2xyz(rgb) {\n  var r = rgb[0] / 255,\n      g = rgb[1] / 255,\n      b = rgb[2] / 255;\n\n  // assume sRGB\n  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n  return [x * 100, y *100, z * 100];\n}\n\nfunction rgb2lab(rgb) {\n  var xyz = rgb2xyz(rgb),\n        x = xyz[0],\n        y = xyz[1],\n        z = xyz[2],\n        l, a, b;\n\n  x /= 95.047;\n  y /= 100;\n  z /= 108.883;\n\n  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\n  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\n  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\n\n  l = (116 * y) - 16;\n  a = 500 * (x - y);\n  b = 200 * (y - z);\n\n  return [l, a, b];\n}\n\nfunction rgb2lch(args) {\n  return lab2lch(rgb2lab(args));\n}\n\nfunction hsl2rgb(hsl) {\n  var h = hsl[0] / 360,\n      s = hsl[1] / 100,\n      l = hsl[2] / 100,\n      t1, t2, t3, rgb, val;\n\n  if (s == 0) {\n    val = l * 255;\n    return [val, val, val];\n  }\n\n  if (l < 0.5)\n    t2 = l * (1 + s);\n  else\n    t2 = l + s - l * s;\n  t1 = 2 * l - t2;\n\n  rgb = [0, 0, 0];\n  for (var i = 0; i < 3; i++) {\n    t3 = h + 1 / 3 * - (i - 1);\n    t3 < 0 && t3++;\n    t3 > 1 && t3--;\n\n    if (6 * t3 < 1)\n      val = t1 + (t2 - t1) * 6 * t3;\n    else if (2 * t3 < 1)\n      val = t2;\n    else if (3 * t3 < 2)\n      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n    else\n      val = t1;\n\n    rgb[i] = val * 255;\n  }\n\n  return rgb;\n}\n\nfunction hsl2hsv(hsl) {\n  var h = hsl[0],\n      s = hsl[1] / 100,\n      l = hsl[2] / 100,\n      sv, v;\n\n  if(l === 0) {\n      // no need to do calc on black\n      // also avoids divide by 0 error\n      return [0, 0, 0];\n  }\n\n  l *= 2;\n  s *= (l <= 1) ? l : 2 - l;\n  v = (l + s) / 2;\n  sv = (2 * s) / (l + s);\n  return [h, sv * 100, v * 100];\n}\n\nfunction hsl2hwb(args) {\n  return rgb2hwb(hsl2rgb(args));\n}\n\nfunction hsl2cmyk(args) {\n  return rgb2cmyk(hsl2rgb(args));\n}\n\nfunction hsl2keyword(args) {\n  return rgb2keyword(hsl2rgb(args));\n}\n\n\nfunction hsv2rgb(hsv) {\n  var h = hsv[0] / 60,\n      s = hsv[1] / 100,\n      v = hsv[2] / 100,\n      hi = Math.floor(h) % 6;\n\n  var f = h - Math.floor(h),\n      p = 255 * v * (1 - s),\n      q = 255 * v * (1 - (s * f)),\n      t = 255 * v * (1 - (s * (1 - f))),\n      v = 255 * v;\n\n  switch(hi) {\n    case 0:\n      return [v, t, p];\n    case 1:\n      return [q, v, p];\n    case 2:\n      return [p, v, t];\n    case 3:\n      return [p, q, v];\n    case 4:\n      return [t, p, v];\n    case 5:\n      return [v, p, q];\n  }\n}\n\nfunction hsv2hsl(hsv) {\n  var h = hsv[0],\n      s = hsv[1] / 100,\n      v = hsv[2] / 100,\n      sl, l;\n\n  l = (2 - s) * v;\n  sl = s * v;\n  sl /= (l <= 1) ? l : 2 - l;\n  sl = sl || 0;\n  l /= 2;\n  return [h, sl * 100, l * 100];\n}\n\nfunction hsv2hwb(args) {\n  return rgb2hwb(hsv2rgb(args))\n}\n\nfunction hsv2cmyk(args) {\n  return rgb2cmyk(hsv2rgb(args));\n}\n\nfunction hsv2keyword(args) {\n  return rgb2keyword(hsv2rgb(args));\n}\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nfunction hwb2rgb(hwb) {\n  var h = hwb[0] / 360,\n      wh = hwb[1] / 100,\n      bl = hwb[2] / 100,\n      ratio = wh + bl,\n      i, v, f, n;\n\n  // wh + bl cant be > 1\n  if (ratio > 1) {\n    wh /= ratio;\n    bl /= ratio;\n  }\n\n  i = Math.floor(6 * h);\n  v = 1 - bl;\n  f = 6 * h - i;\n  if ((i & 0x01) != 0) {\n    f = 1 - f;\n  }\n  n = wh + f * (v - wh);  // linear interpolation\n\n  switch (i) {\n    default:\n    case 6:\n    case 0: r = v; g = n; b = wh; break;\n    case 1: r = n; g = v; b = wh; break;\n    case 2: r = wh; g = v; b = n; break;\n    case 3: r = wh; g = n; b = v; break;\n    case 4: r = n; g = wh; b = v; break;\n    case 5: r = v; g = wh; b = n; break;\n  }\n\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction hwb2hsl(args) {\n  return rgb2hsl(hwb2rgb(args));\n}\n\nfunction hwb2hsv(args) {\n  return rgb2hsv(hwb2rgb(args));\n}\n\nfunction hwb2cmyk(args) {\n  return rgb2cmyk(hwb2rgb(args));\n}\n\nfunction hwb2keyword(args) {\n  return rgb2keyword(hwb2rgb(args));\n}\n\nfunction cmyk2rgb(cmyk) {\n  var c = cmyk[0] / 100,\n      m = cmyk[1] / 100,\n      y = cmyk[2] / 100,\n      k = cmyk[3] / 100,\n      r, g, b;\n\n  r = 1 - Math.min(1, c * (1 - k) + k);\n  g = 1 - Math.min(1, m * (1 - k) + k);\n  b = 1 - Math.min(1, y * (1 - k) + k);\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction cmyk2hsl(args) {\n  return rgb2hsl(cmyk2rgb(args));\n}\n\nfunction cmyk2hsv(args) {\n  return rgb2hsv(cmyk2rgb(args));\n}\n\nfunction cmyk2hwb(args) {\n  return rgb2hwb(cmyk2rgb(args));\n}\n\nfunction cmyk2keyword(args) {\n  return rgb2keyword(cmyk2rgb(args));\n}\n\n\nfunction xyz2rgb(xyz) {\n  var x = xyz[0] / 100,\n      y = xyz[1] / 100,\n      z = xyz[2] / 100,\n      r, g, b;\n\n  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n  // assume sRGB\n  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n    : r = (r * 12.92);\n\n  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n    : g = (g * 12.92);\n\n  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n    : b = (b * 12.92);\n\n  r = Math.min(Math.max(0, r), 1);\n  g = Math.min(Math.max(0, g), 1);\n  b = Math.min(Math.max(0, b), 1);\n\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction xyz2lab(xyz) {\n  var x = xyz[0],\n      y = xyz[1],\n      z = xyz[2],\n      l, a, b;\n\n  x /= 95.047;\n  y /= 100;\n  z /= 108.883;\n\n  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\n  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\n  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\n\n  l = (116 * y) - 16;\n  a = 500 * (x - y);\n  b = 200 * (y - z);\n\n  return [l, a, b];\n}\n\nfunction xyz2lch(args) {\n  return lab2lch(xyz2lab(args));\n}\n\nfunction lab2xyz(lab) {\n  var l = lab[0],\n      a = lab[1],\n      b = lab[2],\n      x, y, z, y2;\n\n  if (l <= 8) {\n    y = (l * 100) / 903.3;\n    y2 = (7.787 * (y / 100)) + (16 / 116);\n  } else {\n    y = 100 * Math.pow((l + 16) / 116, 3);\n    y2 = Math.pow(y / 100, 1/3);\n  }\n\n  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);\n\n  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);\n\n  return [x, y, z];\n}\n\nfunction lab2lch(lab) {\n  var l = lab[0],\n      a = lab[1],\n      b = lab[2],\n      hr, h, c;\n\n  hr = Math.atan2(b, a);\n  h = hr * 360 / 2 / Math.PI;\n  if (h < 0) {\n    h += 360;\n  }\n  c = Math.sqrt(a * a + b * b);\n  return [l, c, h];\n}\n\nfunction lab2rgb(args) {\n  return xyz2rgb(lab2xyz(args));\n}\n\nfunction lch2lab(lch) {\n  var l = lch[0],\n      c = lch[1],\n      h = lch[2],\n      a, b, hr;\n\n  hr = h / 360 * 2 * Math.PI;\n  a = c * Math.cos(hr);\n  b = c * Math.sin(hr);\n  return [l, a, b];\n}\n\nfunction lch2xyz(args) {\n  return lab2xyz(lch2lab(args));\n}\n\nfunction lch2rgb(args) {\n  return lab2rgb(lch2lab(args));\n}\n\nfunction keyword2rgb(keyword) {\n  return cssKeywords[keyword];\n}\n\nfunction keyword2hsl(args) {\n  return rgb2hsl(keyword2rgb(args));\n}\n\nfunction keyword2hsv(args) {\n  return rgb2hsv(keyword2rgb(args));\n}\n\nfunction keyword2hwb(args) {\n  return rgb2hwb(keyword2rgb(args));\n}\n\nfunction keyword2cmyk(args) {\n  return rgb2cmyk(keyword2rgb(args));\n}\n\nfunction keyword2lab(args) {\n  return rgb2lab(keyword2rgb(args));\n}\n\nfunction keyword2xyz(args) {\n  return rgb2xyz(keyword2rgb(args));\n}\n\nvar cssKeywords = {\n  aliceblue:  [240,248,255],\n  antiquewhite: [250,235,215],\n  aqua: [0,255,255],\n  aquamarine: [127,255,212],\n  azure:  [240,255,255],\n  beige:  [245,245,220],\n  bisque: [255,228,196],\n  black:  [0,0,0],\n  blanchedalmond: [255,235,205],\n  blue: [0,0,255],\n  blueviolet: [138,43,226],\n  brown:  [165,42,42],\n  burlywood:  [222,184,135],\n  cadetblue:  [95,158,160],\n  chartreuse: [127,255,0],\n  chocolate:  [210,105,30],\n  coral:  [255,127,80],\n  cornflowerblue: [100,149,237],\n  cornsilk: [255,248,220],\n  crimson:  [220,20,60],\n  cyan: [0,255,255],\n  darkblue: [0,0,139],\n  darkcyan: [0,139,139],\n  darkgoldenrod:  [184,134,11],\n  darkgray: [169,169,169],\n  darkgreen:  [0,100,0],\n  darkgrey: [169,169,169],\n  darkkhaki:  [189,183,107],\n  darkmagenta:  [139,0,139],\n  darkolivegreen: [85,107,47],\n  darkorange: [255,140,0],\n  darkorchid: [153,50,204],\n  darkred:  [139,0,0],\n  darksalmon: [233,150,122],\n  darkseagreen: [143,188,143],\n  darkslateblue:  [72,61,139],\n  darkslategray:  [47,79,79],\n  darkslategrey:  [47,79,79],\n  darkturquoise:  [0,206,209],\n  darkviolet: [148,0,211],\n  deeppink: [255,20,147],\n  deepskyblue:  [0,191,255],\n  dimgray:  [105,105,105],\n  dimgrey:  [105,105,105],\n  dodgerblue: [30,144,255],\n  firebrick:  [178,34,34],\n  floralwhite:  [255,250,240],\n  forestgreen:  [34,139,34],\n  fuchsia:  [255,0,255],\n  gainsboro:  [220,220,220],\n  ghostwhite: [248,248,255],\n  gold: [255,215,0],\n  goldenrod:  [218,165,32],\n  gray: [128,128,128],\n  green:  [0,128,0],\n  greenyellow:  [173,255,47],\n  grey: [128,128,128],\n  honeydew: [240,255,240],\n  hotpink:  [255,105,180],\n  indianred:  [205,92,92],\n  indigo: [75,0,130],\n  ivory:  [255,255,240],\n  khaki:  [240,230,140],\n  lavender: [230,230,250],\n  lavenderblush:  [255,240,245],\n  lawngreen:  [124,252,0],\n  lemonchiffon: [255,250,205],\n  lightblue:  [173,216,230],\n  lightcoral: [240,128,128],\n  lightcyan:  [224,255,255],\n  lightgoldenrodyellow: [250,250,210],\n  lightgray:  [211,211,211],\n  lightgreen: [144,238,144],\n  lightgrey:  [211,211,211],\n  lightpink:  [255,182,193],\n  lightsalmon:  [255,160,122],\n  lightseagreen:  [32,178,170],\n  lightskyblue: [135,206,250],\n  lightslategray: [119,136,153],\n  lightslategrey: [119,136,153],\n  lightsteelblue: [176,196,222],\n  lightyellow:  [255,255,224],\n  lime: [0,255,0],\n  limegreen:  [50,205,50],\n  linen:  [250,240,230],\n  magenta:  [255,0,255],\n  maroon: [128,0,0],\n  mediumaquamarine: [102,205,170],\n  mediumblue: [0,0,205],\n  mediumorchid: [186,85,211],\n  mediumpurple: [147,112,219],\n  mediumseagreen: [60,179,113],\n  mediumslateblue:  [123,104,238],\n  mediumspringgreen:  [0,250,154],\n  mediumturquoise:  [72,209,204],\n  mediumvioletred:  [199,21,133],\n  midnightblue: [25,25,112],\n  mintcream:  [245,255,250],\n  mistyrose:  [255,228,225],\n  moccasin: [255,228,181],\n  navajowhite:  [255,222,173],\n  navy: [0,0,128],\n  oldlace:  [253,245,230],\n  olive:  [128,128,0],\n  olivedrab:  [107,142,35],\n  orange: [255,165,0],\n  orangered:  [255,69,0],\n  orchid: [218,112,214],\n  palegoldenrod:  [238,232,170],\n  palegreen:  [152,251,152],\n  paleturquoise:  [175,238,238],\n  palevioletred:  [219,112,147],\n  papayawhip: [255,239,213],\n  peachpuff:  [255,218,185],\n  peru: [205,133,63],\n  pink: [255,192,203],\n  plum: [221,160,221],\n  powderblue: [176,224,230],\n  purple: [128,0,128],\n  rebeccapurple: [102, 51, 153],\n  red:  [255,0,0],\n  rosybrown:  [188,143,143],\n  royalblue:  [65,105,225],\n  saddlebrown:  [139,69,19],\n  salmon: [250,128,114],\n  sandybrown: [244,164,96],\n  seagreen: [46,139,87],\n  seashell: [255,245,238],\n  sienna: [160,82,45],\n  silver: [192,192,192],\n  skyblue:  [135,206,235],\n  slateblue:  [106,90,205],\n  slategray:  [112,128,144],\n  slategrey:  [112,128,144],\n  snow: [255,250,250],\n  springgreen:  [0,255,127],\n  steelblue:  [70,130,180],\n  tan:  [210,180,140],\n  teal: [0,128,128],\n  thistle:  [216,191,216],\n  tomato: [255,99,71],\n  turquoise:  [64,224,208],\n  violet: [238,130,238],\n  wheat:  [245,222,179],\n  white:  [255,255,255],\n  whitesmoke: [245,245,245],\n  yellow: [255,255,0],\n  yellowgreen:  [154,205,50]\n};\n\nvar reverseKeywords = {};\nfor (var key in cssKeywords) {\n  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;\n}\n","var conversions = require(\"./conversions\");\n\nvar convert = function() {\n   return new Converter();\n}\n\nfor (var func in conversions) {\n  // export Raw versions\n  convert[func + \"Raw\"] =  (function(func) {\n    // accept array or plain args\n    return function(arg) {\n      if (typeof arg == \"number\")\n        arg = Array.prototype.slice.call(arguments);\n      return conversions[func](arg);\n    }\n  })(func);\n\n  var pair = /(\\w+)2(\\w+)/.exec(func),\n      from = pair[1],\n      to = pair[2];\n\n  // export rgb2hsl and [\"rgb\"][\"hsl\"]\n  convert[from] = convert[from] || {};\n\n  convert[from][to] = convert[func] = (function(func) { \n    return function(arg) {\n      if (typeof arg == \"number\")\n        arg = Array.prototype.slice.call(arguments);\n      \n      var val = conversions[func](arg);\n      if (typeof val == \"string\" || val === undefined)\n        return val; // keyword\n\n      for (var i = 0; i < val.length; i++)\n        val[i] = Math.round(val[i]);\n      return val;\n    }\n  })(func);\n}\n\n\n/* Converter does lazy conversion and caching */\nvar Converter = function() {\n   this.convs = {};\n};\n\n/* Either get the values for a space or\n  set the values for a space, depending on args */\nConverter.prototype.routeSpace = function(space, args) {\n   var values = args[0];\n   if (values === undefined) {\n      // color.rgb()\n      return this.getValues(space);\n   }\n   // color.rgb(10, 10, 10)\n   if (typeof values == \"number\") {\n      values = Array.prototype.slice.call(args);        \n   }\n\n   return this.setValues(space, values);\n};\n  \n/* Set the values for a space, invalidating cache */\nConverter.prototype.setValues = function(space, values) {\n   this.space = space;\n   this.convs = {};\n   this.convs[space] = values;\n   return this;\n};\n\n/* Get the values for a space. If there's already\n  a conversion for the space, fetch it, otherwise\n  compute it */\nConverter.prototype.getValues = function(space) {\n   var vals = this.convs[space];\n   if (!vals) {\n      var fspace = this.space,\n          from = this.convs[fspace];\n      vals = convert[fspace][space](from);\n\n      this.convs[space] = vals;\n   }\n  return vals;\n};\n\n[\"rgb\", \"hsl\", \"hsv\", \"cmyk\", \"keyword\"].forEach(function(space) {\n   Converter.prototype[space] = function(vals) {\n      return this.routeSpace(space, arguments);\n   }\n});\n\nmodule.exports = convert;","/**\n * @namespace Chart\n */\nvar Chart = require('./core/core')();\n\nChart.helpers = require('./helpers/index');\n\n// @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!\nrequire('./core/core.helpers')(Chart);\n\nChart.defaults = require('./core/core.defaults');\nChart.Element = require('./core/core.element');\nChart.elements = require('./elements/index');\nChart.Interaction = require('./core/core.interaction');\nChart.layouts = require('./core/core.layouts');\nChart.platform = require('./platforms/platform');\nChart.plugins = require('./core/core.plugins');\nChart.Ticks = require('./core/core.ticks');\n\nrequire('./core/core.animation')(Chart);\nrequire('./core/core.controller')(Chart);\nrequire('./core/core.datasetController')(Chart);\nrequire('./core/core.scaleService')(Chart);\nrequire('./core/core.scale')(Chart);\nrequire('./core/core.tooltip')(Chart);\n\nrequire('./scales/scale.linearbase')(Chart);\nrequire('./scales/scale.category')(Chart);\nrequire('./scales/scale.linear')(Chart);\nrequire('./scales/scale.logarithmic')(Chart);\nrequire('./scales/scale.radialLinear')(Chart);\nrequire('./scales/scale.time')(Chart);\n\n// Controllers must be loaded after elements\n// See Chart.core.datasetController.dataElementType\nrequire('./controllers/controller.bar')(Chart);\nrequire('./controllers/controller.bubble')(Chart);\nrequire('./controllers/controller.doughnut')(Chart);\nrequire('./controllers/controller.line')(Chart);\nrequire('./controllers/controller.polarArea')(Chart);\nrequire('./controllers/controller.radar')(Chart);\nrequire('./controllers/controller.scatter')(Chart);\n\nrequire('./charts/Chart.Bar')(Chart);\nrequire('./charts/Chart.Bubble')(Chart);\nrequire('./charts/Chart.Doughnut')(Chart);\nrequire('./charts/Chart.Line')(Chart);\nrequire('./charts/Chart.PolarArea')(Chart);\nrequire('./charts/Chart.Radar')(Chart);\nrequire('./charts/Chart.Scatter')(Chart);\n\n// Loading built-it plugins\nvar plugins = require('./plugins');\nfor (var k in plugins) {\n\tif (plugins.hasOwnProperty(k)) {\n\t\tChart.plugins.register(plugins[k]);\n\t}\n}\n\nChart.platform.initialize();\n\nmodule.exports = Chart;\nif (typeof window !== 'undefined') {\n\twindow.Chart = Chart;\n}\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, not available anymore\n * @namespace Chart.Legend\n * @deprecated since version 2.1.5\n * @todo remove at version 3\n * @private\n */\nChart.Legend = plugins.legend._element;\n\n/**\n * Provided for backward compatibility, not available anymore\n * @namespace Chart.Title\n * @deprecated since version 2.1.5\n * @todo remove at version 3\n * @private\n */\nChart.Title = plugins.title._element;\n\n/**\n * Provided for backward compatibility, use Chart.plugins instead\n * @namespace Chart.pluginService\n * @deprecated since version 2.1.5\n * @todo remove at version 3\n * @private\n */\nChart.pluginService = Chart.plugins;\n\n/**\n * Provided for backward compatibility, inheriting from Chart.PlugingBase has no\n * effect, instead simply create/register plugins via plain JavaScript objects.\n * @interface Chart.PluginBase\n * @deprecated since version 2.5.0\n * @todo remove at version 3\n * @private\n */\nChart.PluginBase = Chart.Element.extend({});\n\n/**\n * Provided for backward compatibility, use Chart.helpers.canvas instead.\n * @namespace Chart.canvasHelpers\n * @deprecated since version 2.6.0\n * @todo remove at version 3\n * @private\n */\nChart.canvasHelpers = Chart.helpers.canvas;\n\n/**\n * Provided for backward compatibility, use Chart.layouts instead.\n * @namespace Chart.layoutService\n * @deprecated since version 2.8.0\n * @todo remove at version 3\n * @private\n */\nChart.layoutService = Chart.layouts;\n","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Bar = function(context, config) {\n\t\tconfig.type = 'bar';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Bubble = function(context, config) {\n\t\tconfig.type = 'bubble';\n\t\treturn new Chart(context, config);\n\t};\n\n};\n","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Doughnut = function(context, config) {\n\t\tconfig.type = 'doughnut';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Line = function(context, config) {\n\t\tconfig.type = 'line';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.PolarArea = function(context, config) {\n\t\tconfig.type = 'polarArea';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Radar = function(context, config) {\n\t\tconfig.type = 'radar';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n","'use strict';\n\nmodule.exports = function(Chart) {\n\tChart.Scatter = function(context, config) {\n\t\tconfig.type = 'scatter';\n\t\treturn new Chart(context, config);\n\t};\n};\n","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('bar', {\n\thover: {\n\t\tmode: 'label'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'category',\n\n\t\t\t// Specific to Bar Controller\n\t\t\tcategoryPercentage: 0.8,\n\t\t\tbarPercentage: 0.9,\n\n\t\t\t// offset settings\n\t\t\toffset: true,\n\n\t\t\t// grid line settings\n\t\t\tgridLines: {\n\t\t\t\toffsetGridLines: true\n\t\t\t}\n\t\t}],\n\n\t\tyAxes: [{\n\t\t\ttype: 'linear'\n\t\t}]\n\t}\n});\n\ndefaults._set('horizontalBar', {\n\thover: {\n\t\tmode: 'index',\n\t\taxis: 'y'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'linear',\n\t\t\tposition: 'bottom'\n\t\t}],\n\n\t\tyAxes: [{\n\t\t\tposition: 'left',\n\t\t\ttype: 'category',\n\n\t\t\t// Specific to Horizontal Bar Controller\n\t\t\tcategoryPercentage: 0.8,\n\t\t\tbarPercentage: 0.9,\n\n\t\t\t// offset settings\n\t\t\toffset: true,\n\n\t\t\t// grid line settings\n\t\t\tgridLines: {\n\t\t\t\toffsetGridLines: true\n\t\t\t}\n\t\t}]\n\t},\n\n\telements: {\n\t\trectangle: {\n\t\t\tborderSkipped: 'left'\n\t\t}\n\t},\n\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function(item, data) {\n\t\t\t\t// Pick first xLabel for now\n\t\t\t\tvar title = '';\n\n\t\t\t\tif (item.length > 0) {\n\t\t\t\t\tif (item[0].yLabel) {\n\t\t\t\t\t\ttitle = item[0].yLabel;\n\t\t\t\t\t} else if (data.labels.length > 0 && item[0].index < data.labels.length) {\n\t\t\t\t\t\ttitle = data.labels[item[0].index];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn title;\n\t\t\t},\n\n\t\t\tlabel: function(item, data) {\n\t\t\t\tvar datasetLabel = data.datasets[item.datasetIndex].label || '';\n\t\t\t\treturn datasetLabel + ': ' + item.xLabel;\n\t\t\t}\n\t\t},\n\t\tmode: 'index',\n\t\taxis: 'y'\n\t}\n});\n\n/**\n * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\n * @private\n */\nfunction computeMinSampleSize(scale, pixels) {\n\tvar min = scale.isHorizontal() ? scale.width : scale.height;\n\tvar ticks = scale.getTicks();\n\tvar prev, curr, i, ilen;\n\n\tfor (i = 1, ilen = pixels.length; i < ilen; ++i) {\n\t\tmin = Math.min(min, pixels[i] - pixels[i - 1]);\n\t}\n\n\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\tcurr = scale.getPixelForTick(i);\n\t\tmin = i > 0 ? Math.min(min, curr - prev) : min;\n\t\tprev = curr;\n\t}\n\n\treturn min;\n}\n\n/**\n * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\n * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\n * mode currently always generates bars equally sized (until we introduce scriptable options?).\n * @private\n */\nfunction computeFitCategoryTraits(index, ruler, options) {\n\tvar thickness = options.barThickness;\n\tvar count = ruler.stackCount;\n\tvar curr = ruler.pixels[index];\n\tvar size, ratio;\n\n\tif (helpers.isNullOrUndef(thickness)) {\n\t\tsize = ruler.min * options.categoryPercentage;\n\t\tratio = options.barPercentage;\n\t} else {\n\t\t// When bar thickness is enforced, category and bar percentages are ignored.\n\t\t// Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\n\t\t// and deprecate barPercentage since this value is ignored when thickness is absolute.\n\t\tsize = thickness * count;\n\t\tratio = 1;\n\t}\n\n\treturn {\n\t\tchunk: size / count,\n\t\tratio: ratio,\n\t\tstart: curr - (size / 2)\n\t};\n}\n\n/**\n * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\n * percentage options are 1), based on the previous and following categories. This mode\n * generates bars with different widths when data are not evenly spaced.\n * @private\n */\nfunction computeFlexCategoryTraits(index, ruler, options) {\n\tvar pixels = ruler.pixels;\n\tvar curr = pixels[index];\n\tvar prev = index > 0 ? pixels[index - 1] : null;\n\tvar next = index < pixels.length - 1 ? pixels[index + 1] : null;\n\tvar percent = options.categoryPercentage;\n\tvar start, size;\n\n\tif (prev === null) {\n\t\t// first data: its size is double based on the next point or,\n\t\t// if it's also the last data, we use the scale end extremity.\n\t\tprev = curr - (next === null ? ruler.end - curr : next - curr);\n\t}\n\n\tif (next === null) {\n\t\t// last data: its size is also double based on the previous point.\n\t\tnext = curr + curr - prev;\n\t}\n\n\tstart = curr - ((curr - prev) / 2) * percent;\n\tsize = ((next - prev) / 2) * percent;\n\n\treturn {\n\t\tchunk: size / ruler.stackCount,\n\t\tratio: options.barPercentage,\n\t\tstart: start\n\t};\n}\n\nmodule.exports = function(Chart) {\n\n\tChart.controllers.bar = Chart.DatasetController.extend({\n\n\t\tdataElementType: elements.Rectangle,\n\n\t\tinitialize: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta;\n\n\t\t\tChart.DatasetController.prototype.initialize.apply(me, arguments);\n\n\t\t\tmeta = me.getMeta();\n\t\t\tmeta.stack = me.getDataset().stack;\n\t\t\tmeta.bar = true;\n\t\t},\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar rects = me.getMeta().data;\n\t\t\tvar i, ilen;\n\n\t\t\tme._ruler = me.getRuler();\n\n\t\t\tfor (i = 0, ilen = rects.length; i < ilen; ++i) {\n\t\t\t\tme.updateElement(rects[i], i, reset);\n\t\t\t}\n\t\t},\n\n\t\tupdateElement: function(rectangle, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar rectangleOptions = chart.options.elements.rectangle;\n\n\t\t\trectangle._xScale = me.getScaleForId(meta.xAxisID);\n\t\t\trectangle._yScale = me.getScaleForId(meta.yAxisID);\n\t\t\trectangle._datasetIndex = me.index;\n\t\t\trectangle._index = index;\n\n\t\t\trectangle._model = {\n\t\t\t\tdatasetLabel: dataset.label,\n\t\t\t\tlabel: chart.data.labels[index],\n\t\t\t\tborderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,\n\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),\n\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),\n\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)\n\t\t\t};\n\n\t\t\tme.updateElementGeometry(rectangle, index, reset);\n\n\t\t\trectangle.pivot();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tupdateElementGeometry: function(rectangle, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar model = rectangle._model;\n\t\t\tvar vscale = me.getValueScale();\n\t\t\tvar base = vscale.getBasePixel();\n\t\t\tvar horizontal = vscale.isHorizontal();\n\t\t\tvar ruler = me._ruler || me.getRuler();\n\t\t\tvar vpixels = me.calculateBarValuePixels(me.index, index);\n\t\t\tvar ipixels = me.calculateBarIndexPixels(me.index, index, ruler);\n\n\t\t\tmodel.horizontal = horizontal;\n\t\t\tmodel.base = reset ? base : vpixels.base;\n\t\t\tmodel.x = horizontal ? reset ? base : vpixels.head : ipixels.center;\n\t\t\tmodel.y = horizontal ? ipixels.center : reset ? base : vpixels.head;\n\t\t\tmodel.height = horizontal ? ipixels.size : undefined;\n\t\t\tmodel.width = horizontal ? undefined : ipixels.size;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetValueScaleId: function() {\n\t\t\treturn this.getMeta().yAxisID;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetIndexScaleId: function() {\n\t\t\treturn this.getMeta().xAxisID;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetValueScale: function() {\n\t\t\treturn this.getScaleForId(this.getValueScaleId());\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetIndexScale: function() {\n\t\t\treturn this.getScaleForId(this.getIndexScaleId());\n\t\t},\n\n\t\t/**\n\t\t * Returns the stacks based on groups and bar visibility.\n\t\t * @param {Number} [last] - The dataset index\n\t\t * @returns {Array} The stack list\n\t\t * @private\n\t\t */\n\t\t_getStacks: function(last) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar scale = me.getIndexScale();\n\t\t\tvar stacked = scale.options.stacked;\n\t\t\tvar ilen = last === undefined ? chart.data.datasets.length : last + 1;\n\t\t\tvar stacks = [];\n\t\t\tvar i, meta;\n\n\t\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\tif (meta.bar && chart.isDatasetVisible(i) &&\n\t\t\t\t\t(stacked === false ||\n\t\t\t\t\t(stacked === true && stacks.indexOf(meta.stack) === -1) ||\n\t\t\t\t\t(stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1)))) {\n\t\t\t\t\tstacks.push(meta.stack);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn stacks;\n\t\t},\n\n\t\t/**\n\t\t * Returns the effective number of stacks based on groups and bar visibility.\n\t\t * @private\n\t\t */\n\t\tgetStackCount: function() {\n\t\t\treturn this._getStacks().length;\n\t\t},\n\n\t\t/**\n\t\t * Returns the stack index for the given dataset based on groups and bar visibility.\n\t\t * @param {Number} [datasetIndex] - The dataset index\n\t\t * @param {String} [name] - The stack name to find\n\t\t * @returns {Number} The stack index\n\t\t * @private\n\t\t */\n\t\tgetStackIndex: function(datasetIndex, name) {\n\t\t\tvar stacks = this._getStacks(datasetIndex);\n\t\t\tvar index = (name !== undefined)\n\t\t\t\t? stacks.indexOf(name)\n\t\t\t\t: -1; // indexOf returns -1 if element is not present\n\n\t\t\treturn (index === -1)\n\t\t\t\t? stacks.length - 1\n\t\t\t\t: index;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetRuler: function() {\n\t\t\tvar me = this;\n\t\t\tvar scale = me.getIndexScale();\n\t\t\tvar stackCount = me.getStackCount();\n\t\t\tvar datasetIndex = me.index;\n\t\t\tvar isHorizontal = scale.isHorizontal();\n\t\t\tvar start = isHorizontal ? scale.left : scale.top;\n\t\t\tvar end = start + (isHorizontal ? scale.width : scale.height);\n\t\t\tvar pixels = [];\n\t\t\tvar i, ilen, min;\n\n\t\t\tfor (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {\n\t\t\t\tpixels.push(scale.getPixelForValue(null, i, datasetIndex));\n\t\t\t}\n\n\t\t\tmin = helpers.isNullOrUndef(scale.options.barThickness)\n\t\t\t\t? computeMinSampleSize(scale, pixels)\n\t\t\t\t: -1;\n\n\t\t\treturn {\n\t\t\t\tmin: min,\n\t\t\t\tpixels: pixels,\n\t\t\t\tstart: start,\n\t\t\t\tend: end,\n\t\t\t\tstackCount: stackCount,\n\t\t\t\tscale: scale\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Note: pixel values are not clamped to the scale area.\n\t\t * @private\n\t\t */\n\t\tcalculateBarValuePixels: function(datasetIndex, index) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar scale = me.getValueScale();\n\t\t\tvar datasets = chart.data.datasets;\n\t\t\tvar value = scale.getRightValue(datasets[datasetIndex].data[index]);\n\t\t\tvar stacked = scale.options.stacked;\n\t\t\tvar stack = meta.stack;\n\t\t\tvar start = 0;\n\t\t\tvar i, imeta, ivalue, base, head, size;\n\n\t\t\tif (stacked || (stacked === undefined && stack !== undefined)) {\n\t\t\t\tfor (i = 0; i < datasetIndex; ++i) {\n\t\t\t\t\timeta = chart.getDatasetMeta(i);\n\n\t\t\t\t\tif (imeta.bar &&\n\t\t\t\t\t\timeta.stack === stack &&\n\t\t\t\t\t\timeta.controller.getValueScaleId() === scale.id &&\n\t\t\t\t\t\tchart.isDatasetVisible(i)) {\n\n\t\t\t\t\t\tivalue = scale.getRightValue(datasets[i].data[index]);\n\t\t\t\t\t\tif ((value < 0 && ivalue < 0) || (value >= 0 && ivalue > 0)) {\n\t\t\t\t\t\t\tstart += ivalue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbase = scale.getPixelForValue(start);\n\t\t\thead = scale.getPixelForValue(start + value);\n\t\t\tsize = (head - base) / 2;\n\n\t\t\treturn {\n\t\t\t\tsize: size,\n\t\t\t\tbase: base,\n\t\t\t\thead: head,\n\t\t\t\tcenter: head + size / 2\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tcalculateBarIndexPixels: function(datasetIndex, index, ruler) {\n\t\t\tvar me = this;\n\t\t\tvar options = ruler.scale.options;\n\t\t\tvar range = options.barThickness === 'flex'\n\t\t\t\t? computeFlexCategoryTraits(index, ruler, options)\n\t\t\t\t: computeFitCategoryTraits(index, ruler, options);\n\n\t\t\tvar stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);\n\t\t\tvar center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n\t\t\tvar size = Math.min(\n\t\t\t\thelpers.valueOrDefault(options.maxBarThickness, Infinity),\n\t\t\t\trange.chunk * range.ratio);\n\n\t\t\treturn {\n\t\t\t\tbase: center - size / 2,\n\t\t\t\thead: center + size / 2,\n\t\t\t\tcenter: center,\n\t\t\t\tsize: size\n\t\t\t};\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar scale = me.getValueScale();\n\t\t\tvar rects = me.getMeta().data;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar ilen = rects.length;\n\t\t\tvar i = 0;\n\n\t\t\thelpers.canvas.clipArea(chart.ctx, chart.chartArea);\n\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\tif (!isNaN(scale.getRightValue(dataset.data[i]))) {\n\t\t\t\t\trects[i].draw();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thelpers.canvas.unclipArea(chart.ctx);\n\t\t},\n\n\t\tsetHoverStyle: function(rectangle) {\n\t\t\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\n\t\t\tvar index = rectangle._index;\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar model = rectangle._model;\n\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\tremoveHoverStyle: function(rectangle) {\n\t\t\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\n\t\t\tvar index = rectangle._index;\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar model = rectangle._model;\n\t\t\tvar rectangleElementOptions = this.chart.options.elements.rectangle;\n\n\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);\n\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);\n\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);\n\t\t}\n\t});\n\n\tChart.controllers.horizontalBar = Chart.controllers.bar.extend({\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetValueScaleId: function() {\n\t\t\treturn this.getMeta().xAxisID;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetIndexScaleId: function() {\n\t\t\treturn this.getMeta().yAxisID;\n\t\t}\n\t});\n};\n","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('bubble', {\n\thover: {\n\t\tmode: 'single'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'linear', // bubble should probably use a linear scale by default\n\t\t\tposition: 'bottom',\n\t\t\tid: 'x-axis-0' // need an ID so datasets can reference the scale\n\t\t}],\n\t\tyAxes: [{\n\t\t\ttype: 'linear',\n\t\t\tposition: 'left',\n\t\t\tid: 'y-axis-0'\n\t\t}]\n\t},\n\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function() {\n\t\t\t\t// Title doesn't make sense for scatter since we format the data as a point\n\t\t\t\treturn '';\n\t\t\t},\n\t\t\tlabel: function(item, data) {\n\t\t\t\tvar datasetLabel = data.datasets[item.datasetIndex].label || '';\n\t\t\t\tvar dataPoint = data.datasets[item.datasetIndex].data[item.index];\n\t\t\t\treturn datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';\n\t\t\t}\n\t\t}\n\t}\n});\n\n\nmodule.exports = function(Chart) {\n\n\tChart.controllers.bubble = Chart.DatasetController.extend({\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tdataElementType: elements.Point,\n\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar points = meta.data;\n\n\t\t\t// Update Points\n\t\t\thelpers.each(points, function(point, index) {\n\t\t\t\tme.updateElement(point, index, reset);\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar options = me._resolveElementOptions(point, index);\n\t\t\tvar data = me.getDataset().data[index];\n\t\t\tvar dsIndex = me.index;\n\n\t\t\tvar x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);\n\t\t\tvar y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);\n\n\t\t\tpoint._xScale = xScale;\n\t\t\tpoint._yScale = yScale;\n\t\t\tpoint._options = options;\n\t\t\tpoint._datasetIndex = dsIndex;\n\t\t\tpoint._index = index;\n\t\t\tpoint._model = {\n\t\t\t\tbackgroundColor: options.backgroundColor,\n\t\t\t\tborderColor: options.borderColor,\n\t\t\t\tborderWidth: options.borderWidth,\n\t\t\t\thitRadius: options.hitRadius,\n\t\t\t\tpointStyle: options.pointStyle,\n\t\t\t\tradius: reset ? 0 : options.radius,\n\t\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t};\n\n\t\t\tpoint.pivot();\n\t\t},\n\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tsetHoverStyle: function(point) {\n\t\t\tvar model = point._model;\n\t\t\tvar options = point._options;\n\n\t\t\tmodel.backgroundColor = helpers.valueOrDefault(options.hoverBackgroundColor, helpers.getHoverColor(options.backgroundColor));\n\t\t\tmodel.borderColor = helpers.valueOrDefault(options.hoverBorderColor, helpers.getHoverColor(options.borderColor));\n\t\t\tmodel.borderWidth = helpers.valueOrDefault(options.hoverBorderWidth, options.borderWidth);\n\t\t\tmodel.radius = options.radius + options.hoverRadius;\n\t\t},\n\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tremoveHoverStyle: function(point) {\n\t\t\tvar model = point._model;\n\t\t\tvar options = point._options;\n\n\t\t\tmodel.backgroundColor = options.backgroundColor;\n\t\t\tmodel.borderColor = options.borderColor;\n\t\t\tmodel.borderWidth = options.borderWidth;\n\t\t\tmodel.radius = options.radius;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_resolveElementOptions: function(point, index) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar datasets = chart.data.datasets;\n\t\t\tvar dataset = datasets[me.index];\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar options = chart.options.elements.point;\n\t\t\tvar resolve = helpers.options.resolve;\n\t\t\tvar data = dataset.data[index];\n\t\t\tvar values = {};\n\t\t\tvar i, ilen, key;\n\n\t\t\t// Scriptable options\n\t\t\tvar context = {\n\t\t\t\tchart: chart,\n\t\t\t\tdataIndex: index,\n\t\t\t\tdataset: dataset,\n\t\t\t\tdatasetIndex: me.index\n\t\t\t};\n\n\t\t\tvar keys = [\n\t\t\t\t'backgroundColor',\n\t\t\t\t'borderColor',\n\t\t\t\t'borderWidth',\n\t\t\t\t'hoverBackgroundColor',\n\t\t\t\t'hoverBorderColor',\n\t\t\t\t'hoverBorderWidth',\n\t\t\t\t'hoverRadius',\n\t\t\t\t'hitRadius',\n\t\t\t\t'pointStyle'\n\t\t\t];\n\n\t\t\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\t\t\tkey = keys[i];\n\t\t\t\tvalues[key] = resolve([\n\t\t\t\t\tcustom[key],\n\t\t\t\t\tdataset[key],\n\t\t\t\t\toptions[key]\n\t\t\t\t], context, index);\n\t\t\t}\n\n\t\t\t// Custom radius resolution\n\t\t\tvalues.radius = resolve([\n\t\t\t\tcustom.radius,\n\t\t\t\tdata ? data.r : undefined,\n\t\t\t\tdataset.radius,\n\t\t\t\toptions.radius\n\t\t\t], context, index);\n\n\t\t\treturn values;\n\t\t}\n\t});\n};\n","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('doughnut', {\n\tanimation: {\n\t\t// Boolean - Whether we animate the rotation of the Doughnut\n\t\tanimateRotate: true,\n\t\t// Boolean - Whether we animate scaling the Doughnut from the centre\n\t\tanimateScale: false\n\t},\n\thover: {\n\t\tmode: 'single'\n\t},\n\tlegendCallback: function(chart) {\n\t\tvar text = [];\n\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\n\t\tvar data = chart.data;\n\t\tvar datasets = data.datasets;\n\t\tvar labels = data.labels;\n\n\t\tif (datasets.length) {\n\t\t\tfor (var i = 0; i < datasets[0].data.length; ++i) {\n\t\t\t\ttext.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n\t\t\t\tif (labels[i]) {\n\t\t\t\t\ttext.push(labels[i]);\n\t\t\t\t}\n\t\t\t\ttext.push('</li>');\n\t\t\t}\n\t\t}\n\n\t\ttext.push('</ul>');\n\t\treturn text.join('');\n\t},\n\tlegend: {\n\t\tlabels: {\n\t\t\tgenerateLabels: function(chart) {\n\t\t\t\tvar data = chart.data;\n\t\t\t\tif (data.labels.length && data.datasets.length) {\n\t\t\t\t\treturn data.labels.map(function(label, i) {\n\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\n\t\t\t\t\t\tvar ds = data.datasets[0];\n\t\t\t\t\t\tvar arc = meta.data[i];\n\t\t\t\t\t\tvar custom = arc && arc.custom || {};\n\t\t\t\t\t\tvar valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n\t\t\t\t\t\tvar arcOpts = chart.options.elements.arc;\n\t\t\t\t\t\tvar fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\n\t\t\t\t\t\tvar stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\n\t\t\t\t\t\tvar bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\tfillStyle: fill,\n\t\t\t\t\t\t\tstrokeStyle: stroke,\n\t\t\t\t\t\t\tlineWidth: bw,\n\t\t\t\t\t\t\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n\n\t\t\t\t\t\t\t// Extra data used for toggling the correct item\n\t\t\t\t\t\t\tindex: i\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn [];\n\t\t\t}\n\t\t},\n\n\t\tonClick: function(e, legendItem) {\n\t\t\tvar index = legendItem.index;\n\t\t\tvar chart = this.chart;\n\t\t\tvar i, ilen, meta;\n\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\t// toggle visibility of index if exists\n\t\t\t\tif (meta.data[index]) {\n\t\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchart.update();\n\t\t}\n\t},\n\n\t// The percentage of the chart that we cut out of the middle.\n\tcutoutPercentage: 50,\n\n\t// The rotation of the chart, where the first data arc begins.\n\trotation: Math.PI * -0.5,\n\n\t// The total circumference of the chart.\n\tcircumference: Math.PI * 2.0,\n\n\t// Need to override these to give a nice default\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function() {\n\t\t\t\treturn '';\n\t\t\t},\n\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\tvar dataLabel = data.labels[tooltipItem.index];\n\t\t\t\tvar value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\n\n\t\t\t\tif (helpers.isArray(dataLabel)) {\n\t\t\t\t\t// show value on first line of multiline label\n\t\t\t\t\t// need to clone because we are changing the value\n\t\t\t\t\tdataLabel = dataLabel.slice();\n\t\t\t\t\tdataLabel[0] += value;\n\t\t\t\t} else {\n\t\t\t\t\tdataLabel += value;\n\t\t\t\t}\n\n\t\t\t\treturn dataLabel;\n\t\t\t}\n\t\t}\n\t}\n});\n\ndefaults._set('pie', helpers.clone(defaults.doughnut));\ndefaults._set('pie', {\n\tcutoutPercentage: 0\n});\n\nmodule.exports = function(Chart) {\n\n\tChart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({\n\n\t\tdataElementType: elements.Arc,\n\n\t\tlinkScales: helpers.noop,\n\n\t\t// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly\n\t\tgetRingIndex: function(datasetIndex) {\n\t\t\tvar ringIndex = 0;\n\n\t\t\tfor (var j = 0; j < datasetIndex; ++j) {\n\t\t\t\tif (this.chart.isDatasetVisible(j)) {\n\t\t\t\t\t++ringIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ringIndex;\n\t\t},\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar chartArea = chart.chartArea;\n\t\t\tvar opts = chart.options;\n\t\t\tvar arcOpts = opts.elements.arc;\n\t\t\tvar availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth;\n\t\t\tvar availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth;\n\t\t\tvar minSize = Math.min(availableWidth, availableHeight);\n\t\t\tvar offset = {x: 0, y: 0};\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar cutoutPercentage = opts.cutoutPercentage;\n\t\t\tvar circumference = opts.circumference;\n\n\t\t\t// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc\n\t\t\tif (circumference < Math.PI * 2.0) {\n\t\t\t\tvar startAngle = opts.rotation % (Math.PI * 2.0);\n\t\t\t\tstartAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);\n\t\t\t\tvar endAngle = startAngle + circumference;\n\t\t\t\tvar start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};\n\t\t\t\tvar end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};\n\t\t\t\tvar contains0 = (startAngle <= 0 && endAngle >= 0) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);\n\t\t\t\tvar contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);\n\t\t\t\tvar contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);\n\t\t\t\tvar contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);\n\t\t\t\tvar cutout = cutoutPercentage / 100.0;\n\t\t\t\tvar min = {x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))};\n\t\t\t\tvar max = {x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))};\n\t\t\t\tvar size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};\n\t\t\t\tminSize = Math.min(availableWidth / size.width, availableHeight / size.height);\n\t\t\t\toffset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};\n\t\t\t}\n\n\t\t\tchart.borderWidth = me.getMaxBorderWidth(meta.data);\n\t\t\tchart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);\n\t\t\tchart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 0, 0);\n\t\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n\t\t\tchart.offsetX = offset.x * chart.outerRadius;\n\t\t\tchart.offsetY = offset.y * chart.outerRadius;\n\n\t\t\tmeta.total = me.calculateTotal();\n\n\t\t\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.getRingIndex(me.index));\n\t\t\tme.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);\n\n\t\t\thelpers.each(meta.data, function(arc, index) {\n\t\t\t\tme.updateElement(arc, index, reset);\n\t\t\t});\n\t\t},\n\n\t\tupdateElement: function(arc, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar chartArea = chart.chartArea;\n\t\t\tvar opts = chart.options;\n\t\t\tvar animationOpts = opts.animation;\n\t\t\tvar centerX = (chartArea.left + chartArea.right) / 2;\n\t\t\tvar centerY = (chartArea.top + chartArea.bottom) / 2;\n\t\t\tvar startAngle = opts.rotation; // non reset case handled later\n\t\t\tvar endAngle = opts.rotation; // non reset case handled later\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));\n\t\t\tvar innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;\n\t\t\tvar outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;\n\t\t\tvar valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n\n\t\t\thelpers.extend(arc, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index,\n\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tx: centerX + chart.offsetX,\n\t\t\t\t\ty: centerY + chart.offsetY,\n\t\t\t\t\tstartAngle: startAngle,\n\t\t\t\t\tendAngle: endAngle,\n\t\t\t\t\tcircumference: circumference,\n\t\t\t\t\touterRadius: outerRadius,\n\t\t\t\t\tinnerRadius: innerRadius,\n\t\t\t\t\tlabel: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tvar model = arc._model;\n\t\t\t// Resets the visual styles\n\t\t\tthis.removeHoverStyle(arc);\n\n\t\t\t// Set correct angles if not resetting\n\t\t\tif (!reset || !animationOpts.animateRotate) {\n\t\t\t\tif (index === 0) {\n\t\t\t\t\tmodel.startAngle = opts.rotation;\n\t\t\t\t} else {\n\t\t\t\t\tmodel.startAngle = me.getMeta().data[index - 1]._model.endAngle;\n\t\t\t\t}\n\n\t\t\t\tmodel.endAngle = model.startAngle + model.circumference;\n\t\t\t}\n\n\t\t\tarc.pivot();\n\t\t},\n\n\t\tremoveHoverStyle: function(arc) {\n\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\n\t\t},\n\n\t\tcalculateTotal: function() {\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar total = 0;\n\t\t\tvar value;\n\n\t\t\thelpers.each(meta.data, function(element, index) {\n\t\t\t\tvalue = dataset.data[index];\n\t\t\t\tif (!isNaN(value) && !element.hidden) {\n\t\t\t\t\ttotal += Math.abs(value);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/* if (total === 0) {\n\t\t\t\ttotal = NaN;\n\t\t\t}*/\n\n\t\t\treturn total;\n\t\t},\n\n\t\tcalculateCircumference: function(value) {\n\t\t\tvar total = this.getMeta().total;\n\t\t\tif (total > 0 && !isNaN(value)) {\n\t\t\t\treturn (Math.PI * 2.0) * (Math.abs(value) / total);\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\n\t\t// gets the max border or hover width to properly scale pie charts\n\t\tgetMaxBorderWidth: function(arcs) {\n\t\t\tvar max = 0;\n\t\t\tvar index = this.index;\n\t\t\tvar length = arcs.length;\n\t\t\tvar borderWidth;\n\t\t\tvar hoverWidth;\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tborderWidth = arcs[i]._model ? arcs[i]._model.borderWidth : 0;\n\t\t\t\thoverWidth = arcs[i]._chart ? arcs[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;\n\n\t\t\t\tmax = borderWidth > max ? borderWidth : max;\n\t\t\t\tmax = hoverWidth > max ? hoverWidth : max;\n\t\t\t}\n\t\t\treturn max;\n\t\t}\n\t});\n};\n","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('line', {\n\tshowLines: true,\n\tspanGaps: false,\n\n\thover: {\n\t\tmode: 'label'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'category',\n\t\t\tid: 'x-axis-0'\n\t\t}],\n\t\tyAxes: [{\n\t\t\ttype: 'linear',\n\t\t\tid: 'y-axis-0'\n\t\t}]\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\tfunction lineEnabled(dataset, options) {\n\t\treturn helpers.valueOrDefault(dataset.showLine, options.showLines);\n\t}\n\n\tChart.controllers.line = Chart.DatasetController.extend({\n\n\t\tdatasetElementType: elements.Line,\n\n\t\tdataElementType: elements.Point,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar line = meta.dataset;\n\t\t\tvar points = meta.data || [];\n\t\t\tvar options = me.chart.options;\n\t\t\tvar lineElementOptions = options.elements.line;\n\t\t\tvar scale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar i, ilen, custom;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar showLine = lineEnabled(dataset, options);\n\n\t\t\t// Update Line\n\t\t\tif (showLine) {\n\t\t\t\tcustom = line.custom || {};\n\n\t\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\t\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\n\t\t\t\t\tdataset.lineTension = dataset.tension;\n\t\t\t\t}\n\n\t\t\t\t// Utility\n\t\t\t\tline._scale = scale;\n\t\t\t\tline._datasetIndex = me.index;\n\t\t\t\t// Data\n\t\t\t\tline._children = points;\n\t\t\t\t// Model\n\t\t\t\tline._model = {\n\t\t\t\t\t// Appearance\n\t\t\t\t\t// The default behavior of lines is to break at null values, according\n\t\t\t\t\t// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158\n\t\t\t\t\t// This option gives lines the ability to span gaps\n\t\t\t\t\tspanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,\n\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),\n\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\n\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\n\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\n\t\t\t\t\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\n\t\t\t\t\tborderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\n\t\t\t\t\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\n\t\t\t\t\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\n\t\t\t\t\tfill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\n\t\t\t\t\tsteppedLine: custom.steppedLine ? custom.steppedLine : helpers.valueOrDefault(dataset.steppedLine, lineElementOptions.stepped),\n\t\t\t\t\tcubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.valueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),\n\t\t\t\t};\n\n\t\t\t\tline.pivot();\n\t\t\t}\n\n\t\t\t// Update Points\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\tme.updateElement(points[i], i, reset);\n\t\t\t}\n\n\t\t\tif (showLine && line._model.tension !== 0) {\n\t\t\t\tme.updateBezierControlPoints();\n\t\t\t}\n\n\t\t\t// Now pivot the point for animation\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\tpoints[i].pivot();\n\t\t\t}\n\t\t},\n\n\t\tgetPointBackgroundColor: function(point, index) {\n\t\t\tvar backgroundColor = this.chart.options.elements.point.backgroundColor;\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar custom = point.custom || {};\n\n\t\t\tif (custom.backgroundColor) {\n\t\t\t\tbackgroundColor = custom.backgroundColor;\n\t\t\t} else if (dataset.pointBackgroundColor) {\n\t\t\t\tbackgroundColor = helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);\n\t\t\t} else if (dataset.backgroundColor) {\n\t\t\t\tbackgroundColor = dataset.backgroundColor;\n\t\t\t}\n\n\t\t\treturn backgroundColor;\n\t\t},\n\n\t\tgetPointBorderColor: function(point, index) {\n\t\t\tvar borderColor = this.chart.options.elements.point.borderColor;\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar custom = point.custom || {};\n\n\t\t\tif (custom.borderColor) {\n\t\t\t\tborderColor = custom.borderColor;\n\t\t\t} else if (dataset.pointBorderColor) {\n\t\t\t\tborderColor = helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);\n\t\t\t} else if (dataset.borderColor) {\n\t\t\t\tborderColor = dataset.borderColor;\n\t\t\t}\n\n\t\t\treturn borderColor;\n\t\t},\n\n\t\tgetPointBorderWidth: function(point, index) {\n\t\t\tvar borderWidth = this.chart.options.elements.point.borderWidth;\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar custom = point.custom || {};\n\n\t\t\tif (!isNaN(custom.borderWidth)) {\n\t\t\t\tborderWidth = custom.borderWidth;\n\t\t\t} else if (!isNaN(dataset.pointBorderWidth) || helpers.isArray(dataset.pointBorderWidth)) {\n\t\t\t\tborderWidth = helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);\n\t\t\t} else if (!isNaN(dataset.borderWidth)) {\n\t\t\t\tborderWidth = dataset.borderWidth;\n\t\t\t}\n\n\t\t\treturn borderWidth;\n\t\t},\n\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar datasetIndex = me.index;\n\t\t\tvar value = dataset.data[index];\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tvar pointOptions = me.chart.options.elements.point;\n\t\t\tvar x, y;\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t}\n\t\t\tif ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {\n\t\t\t\tdataset.pointHitRadius = dataset.hitRadius;\n\t\t\t}\n\n\t\t\tx = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);\n\t\t\ty = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);\n\n\t\t\t// Utility\n\t\t\tpoint._xScale = xScale;\n\t\t\tpoint._yScale = yScale;\n\t\t\tpoint._datasetIndex = datasetIndex;\n\t\t\tpoint._index = index;\n\n\t\t\t// Desired view properties\n\t\t\tpoint._model = {\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\n\t\t\t\t// Appearance\n\t\t\t\tradius: custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),\n\t\t\t\tpointStyle: custom.pointStyle || helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),\n\t\t\t\tbackgroundColor: me.getPointBackgroundColor(point, index),\n\t\t\t\tborderColor: me.getPointBorderColor(point, index),\n\t\t\t\tborderWidth: me.getPointBorderWidth(point, index),\n\t\t\t\ttension: meta.dataset._model ? meta.dataset._model.tension : 0,\n\t\t\t\tsteppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,\n\t\t\t\t// Tooltip\n\t\t\t\thitRadius: custom.hitRadius || helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)\n\t\t\t};\n\t\t},\n\n\t\tcalculatePointY: function(value, index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar sumPos = 0;\n\t\t\tvar sumNeg = 0;\n\t\t\tvar i, ds, dsMeta;\n\n\t\t\tif (yScale.options.stacked) {\n\t\t\t\tfor (i = 0; i < datasetIndex; i++) {\n\t\t\t\t\tds = chart.data.datasets[i];\n\t\t\t\t\tdsMeta = chart.getDatasetMeta(i);\n\t\t\t\t\tif (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {\n\t\t\t\t\t\tvar stackedRightValue = Number(yScale.getRightValue(ds.data[index]));\n\t\t\t\t\t\tif (stackedRightValue < 0) {\n\t\t\t\t\t\t\tsumNeg += stackedRightValue || 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsumPos += stackedRightValue || 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar rightValue = Number(yScale.getRightValue(value));\n\t\t\t\tif (rightValue < 0) {\n\t\t\t\t\treturn yScale.getPixelForValue(sumNeg + rightValue);\n\t\t\t\t}\n\t\t\t\treturn yScale.getPixelForValue(sumPos + rightValue);\n\t\t\t}\n\n\t\t\treturn yScale.getPixelForValue(value);\n\t\t},\n\n\t\tupdateBezierControlPoints: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar area = me.chart.chartArea;\n\t\t\tvar points = (meta.data || []);\n\t\t\tvar i, ilen, point, model, controlPoints;\n\n\t\t\t// Only consider points that are drawn in case the spanGaps option is used\n\t\t\tif (meta.dataset._model.spanGaps) {\n\t\t\t\tpoints = points.filter(function(pt) {\n\t\t\t\t\treturn !pt._model.skip;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction capControlPoint(pt, min, max) {\n\t\t\t\treturn Math.max(Math.min(pt, max), min);\n\t\t\t}\n\n\t\t\tif (meta.dataset._model.cubicInterpolationMode === 'monotone') {\n\t\t\t\thelpers.splineCurveMonotone(points);\n\t\t\t} else {\n\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\tpoint = points[i];\n\t\t\t\t\tmodel = point._model;\n\t\t\t\t\tcontrolPoints = helpers.splineCurve(\n\t\t\t\t\t\thelpers.previousItem(points, i)._model,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\thelpers.nextItem(points, i)._model,\n\t\t\t\t\t\tmeta.dataset._model.tension\n\t\t\t\t\t);\n\t\t\t\t\tmodel.controlPointPreviousX = controlPoints.previous.x;\n\t\t\t\t\tmodel.controlPointPreviousY = controlPoints.previous.y;\n\t\t\t\t\tmodel.controlPointNextX = controlPoints.next.x;\n\t\t\t\t\tmodel.controlPointNextY = controlPoints.next.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (me.chart.options.elements.line.capBezierPoints) {\n\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\tmodel = points[i]._model;\n\t\t\t\t\tmodel.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\n\t\t\t\t\tmodel.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\n\t\t\t\t\tmodel.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\n\t\t\t\t\tmodel.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar points = meta.data || [];\n\t\t\tvar area = chart.chartArea;\n\t\t\tvar ilen = points.length;\n\t\t\tvar i = 0;\n\n\t\t\thelpers.canvas.clipArea(chart.ctx, area);\n\n\t\t\tif (lineEnabled(me.getDataset(), chart.options)) {\n\t\t\t\tmeta.dataset.draw();\n\t\t\t}\n\n\t\t\thelpers.canvas.unclipArea(chart.ctx);\n\n\t\t\t// Draw the points\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\tpoints[i].draw(area);\n\t\t\t}\n\t\t},\n\n\t\tsetHoverStyle: function(point) {\n\t\t\t// Point\n\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\tvar index = point._index;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar model = point._model;\n\n\t\t\tmodel.radius = custom.hoverRadius || helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\tremoveHoverStyle: function(point) {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.chart.data.datasets[point._datasetIndex];\n\t\t\tvar index = point._index;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar model = point._model;\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t}\n\n\t\t\tmodel.radius = custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);\n\t\t\tmodel.backgroundColor = me.getPointBackgroundColor(point, index);\n\t\t\tmodel.borderColor = me.getPointBorderColor(point, index);\n\t\t\tmodel.borderWidth = me.getPointBorderWidth(point, index);\n\t\t}\n\t});\n};\n","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('polarArea', {\n\tscale: {\n\t\ttype: 'radialLinear',\n\t\tangleLines: {\n\t\t\tdisplay: false\n\t\t},\n\t\tgridLines: {\n\t\t\tcircular: true\n\t\t},\n\t\tpointLabels: {\n\t\t\tdisplay: false\n\t\t},\n\t\tticks: {\n\t\t\tbeginAtZero: true\n\t\t}\n\t},\n\n\t// Boolean - Whether to animate the rotation of the chart\n\tanimation: {\n\t\tanimateRotate: true,\n\t\tanimateScale: true\n\t},\n\n\tstartAngle: -0.5 * Math.PI,\n\tlegendCallback: function(chart) {\n\t\tvar text = [];\n\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\n\t\tvar data = chart.data;\n\t\tvar datasets = data.datasets;\n\t\tvar labels = data.labels;\n\n\t\tif (datasets.length) {\n\t\t\tfor (var i = 0; i < datasets[0].data.length; ++i) {\n\t\t\t\ttext.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n\t\t\t\tif (labels[i]) {\n\t\t\t\t\ttext.push(labels[i]);\n\t\t\t\t}\n\t\t\t\ttext.push('</li>');\n\t\t\t}\n\t\t}\n\n\t\ttext.push('</ul>');\n\t\treturn text.join('');\n\t},\n\tlegend: {\n\t\tlabels: {\n\t\t\tgenerateLabels: function(chart) {\n\t\t\t\tvar data = chart.data;\n\t\t\t\tif (data.labels.length && data.datasets.length) {\n\t\t\t\t\treturn data.labels.map(function(label, i) {\n\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\n\t\t\t\t\t\tvar ds = data.datasets[0];\n\t\t\t\t\t\tvar arc = meta.data[i];\n\t\t\t\t\t\tvar custom = arc.custom || {};\n\t\t\t\t\t\tvar valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n\t\t\t\t\t\tvar arcOpts = chart.options.elements.arc;\n\t\t\t\t\t\tvar fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\n\t\t\t\t\t\tvar stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\n\t\t\t\t\t\tvar bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\tfillStyle: fill,\n\t\t\t\t\t\t\tstrokeStyle: stroke,\n\t\t\t\t\t\t\tlineWidth: bw,\n\t\t\t\t\t\t\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n\n\t\t\t\t\t\t\t// Extra data used for toggling the correct item\n\t\t\t\t\t\t\tindex: i\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn [];\n\t\t\t}\n\t\t},\n\n\t\tonClick: function(e, legendItem) {\n\t\t\tvar index = legendItem.index;\n\t\t\tvar chart = this.chart;\n\t\t\tvar i, ilen, meta;\n\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;\n\t\t\t}\n\n\t\t\tchart.update();\n\t\t}\n\t},\n\n\t// Need to override these to give a nice default\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function() {\n\t\t\t\treturn '';\n\t\t\t},\n\t\t\tlabel: function(item, data) {\n\t\t\t\treturn data.labels[item.index] + ': ' + item.yLabel;\n\t\t\t}\n\t\t}\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\tChart.controllers.polarArea = Chart.DatasetController.extend({\n\n\t\tdataElementType: elements.Arc,\n\n\t\tlinkScales: helpers.noop,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar chartArea = chart.chartArea;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar opts = chart.options;\n\t\t\tvar arcOpts = opts.elements.arc;\n\t\t\tvar minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n\t\t\tchart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);\n\t\t\tchart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n\t\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n\n\t\t\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);\n\t\t\tme.innerRadius = me.outerRadius - chart.radiusLength;\n\n\t\t\tmeta.count = me.countVisibleElements();\n\n\t\t\thelpers.each(meta.data, function(arc, index) {\n\t\t\t\tme.updateElement(arc, index, reset);\n\t\t\t});\n\t\t},\n\n\t\tupdateElement: function(arc, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar opts = chart.options;\n\t\t\tvar animationOpts = opts.animation;\n\t\t\tvar scale = chart.scale;\n\t\t\tvar labels = chart.data.labels;\n\n\t\t\tvar circumference = me.calculateCircumference(dataset.data[index]);\n\t\t\tvar centerX = scale.xCenter;\n\t\t\tvar centerY = scale.yCenter;\n\n\t\t\t// If there is NaN data before us, we need to calculate the starting angle correctly.\n\t\t\t// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data\n\t\t\tvar visibleCount = 0;\n\t\t\tvar meta = me.getMeta();\n\t\t\tfor (var i = 0; i < index; ++i) {\n\t\t\t\tif (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {\n\t\t\t\t\t++visibleCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// var negHalfPI = -0.5 * Math.PI;\n\t\t\tvar datasetStartAngle = opts.startAngle;\n\t\t\tvar distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n\t\t\tvar startAngle = datasetStartAngle + (circumference * visibleCount);\n\t\t\tvar endAngle = startAngle + (arc.hidden ? 0 : circumference);\n\n\t\t\tvar resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n\n\t\t\thelpers.extend(arc, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index,\n\t\t\t\t_scale: scale,\n\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tx: centerX,\n\t\t\t\t\ty: centerY,\n\t\t\t\t\tinnerRadius: 0,\n\t\t\t\t\touterRadius: reset ? resetRadius : distance,\n\t\t\t\t\tstartAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,\n\t\t\t\t\tendAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,\n\t\t\t\t\tlabel: helpers.valueAtIndexOrDefault(labels, index, labels[index])\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Apply border and fill style\n\t\t\tme.removeHoverStyle(arc);\n\n\t\t\tarc.pivot();\n\t\t},\n\n\t\tremoveHoverStyle: function(arc) {\n\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\n\t\t},\n\n\t\tcountVisibleElements: function() {\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar count = 0;\n\n\t\t\thelpers.each(meta.data, function(element, index) {\n\t\t\t\tif (!isNaN(dataset.data[index]) && !element.hidden) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn count;\n\t\t},\n\n\t\tcalculateCircumference: function(value) {\n\t\t\tvar count = this.getMeta().count;\n\t\t\tif (count > 0 && !isNaN(value)) {\n\t\t\t\treturn (2 * Math.PI) / count;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t});\n};\n","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('radar', {\n\tscale: {\n\t\ttype: 'radialLinear'\n\t},\n\telements: {\n\t\tline: {\n\t\t\ttension: 0 // no bezier in radar\n\t\t}\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\tChart.controllers.radar = Chart.DatasetController.extend({\n\n\t\tdatasetElementType: elements.Line,\n\n\t\tdataElementType: elements.Point,\n\n\t\tlinkScales: helpers.noop,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar line = meta.dataset;\n\t\t\tvar points = meta.data;\n\t\t\tvar custom = line.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar lineElementOptions = me.chart.options.elements.line;\n\t\t\tvar scale = me.chart.scale;\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\n\t\t\t\tdataset.lineTension = dataset.tension;\n\t\t\t}\n\n\t\t\thelpers.extend(meta.dataset, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_scale: scale,\n\t\t\t\t// Data\n\t\t\t\t_children: points,\n\t\t\t\t_loop: true,\n\t\t\t\t// Model\n\t\t\t\t_model: {\n\t\t\t\t\t// Appearance\n\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),\n\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\n\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\n\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\n\t\t\t\t\tfill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\n\t\t\t\t\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\n\t\t\t\t\tborderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\n\t\t\t\t\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\n\t\t\t\t\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tmeta.dataset.pivot();\n\n\t\t\t// Update Points\n\t\t\thelpers.each(points, function(point, index) {\n\t\t\t\tme.updateElement(point, index, reset);\n\t\t\t}, me);\n\n\t\t\t// Update bezier control points\n\t\t\tme.updateBezierControlPoints();\n\t\t},\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar scale = me.chart.scale;\n\t\t\tvar pointElementOptions = me.chart.options.elements.point;\n\t\t\tvar pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t}\n\t\t\tif ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {\n\t\t\t\tdataset.pointHitRadius = dataset.hitRadius;\n\t\t\t}\n\n\t\t\thelpers.extend(point, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index,\n\t\t\t\t_scale: scale,\n\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tx: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales\n\t\t\t\t\ty: reset ? scale.yCenter : pointPosition.y,\n\n\t\t\t\t\t// Appearance\n\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),\n\t\t\t\t\tradius: custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),\n\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),\n\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),\n\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),\n\t\t\t\t\tpointStyle: custom.pointStyle ? custom.pointStyle : helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),\n\n\t\t\t\t\t// Tooltip\n\t\t\t\t\thitRadius: custom.hitRadius ? custom.hitRadius : helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointElementOptions.hitRadius)\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tpoint._model.skip = custom.skip ? custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));\n\t\t},\n\t\tupdateBezierControlPoints: function() {\n\t\t\tvar chartArea = this.chart.chartArea;\n\t\t\tvar meta = this.getMeta();\n\n\t\t\thelpers.each(meta.data, function(point, index) {\n\t\t\t\tvar model = point._model;\n\t\t\t\tvar controlPoints = helpers.splineCurve(\n\t\t\t\t\thelpers.previousItem(meta.data, index, true)._model,\n\t\t\t\t\tmodel,\n\t\t\t\t\thelpers.nextItem(meta.data, index, true)._model,\n\t\t\t\t\tmodel.tension\n\t\t\t\t);\n\n\t\t\t\t// Prevent the bezier going outside of the bounds of the graph\n\t\t\t\tmodel.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);\n\t\t\t\tmodel.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);\n\n\t\t\t\tmodel.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);\n\t\t\t\tmodel.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);\n\n\t\t\t\t// Now pivot the point for animation\n\t\t\t\tpoint.pivot();\n\t\t\t});\n\t\t},\n\n\t\tsetHoverStyle: function(point) {\n\t\t\t// Point\n\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar index = point._index;\n\t\t\tvar model = point._model;\n\n\t\t\tmodel.radius = custom.hoverRadius ? custom.hoverRadius : helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\tremoveHoverStyle: function(point) {\n\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar index = point._index;\n\t\t\tvar model = point._model;\n\t\t\tvar pointElementOptions = this.chart.options.elements.point;\n\n\t\t\tmodel.radius = custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius);\n\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);\n\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);\n\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);\n\t\t}\n\t});\n};\n","'use strict';\n\nvar defaults = require('../core/core.defaults');\n\ndefaults._set('scatter', {\n\thover: {\n\t\tmode: 'single'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\tid: 'x-axis-1',    // need an ID so datasets can reference the scale\n\t\t\ttype: 'linear',    // scatter should not use a category axis\n\t\t\tposition: 'bottom'\n\t\t}],\n\t\tyAxes: [{\n\t\t\tid: 'y-axis-1',\n\t\t\ttype: 'linear',\n\t\t\tposition: 'left'\n\t\t}]\n\t},\n\n\tshowLines: false,\n\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function() {\n\t\t\t\treturn '';     // doesn't make sense for scatter since data are formatted as a point\n\t\t\t},\n\t\t\tlabel: function(item) {\n\t\t\t\treturn '(' + item.xLabel + ', ' + item.yLabel + ')';\n\t\t\t}\n\t\t}\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\t// Scatter charts use line controllers\n\tChart.controllers.scatter = Chart.controllers.line;\n\n};\n","/* global window: false */\n'use strict';\n\nvar defaults = require('./core.defaults');\nvar Element = require('./core.element');\nvar helpers = require('../helpers/index');\n\ndefaults._set('global', {\n\tanimation: {\n\t\tduration: 1000,\n\t\teasing: 'easeOutQuart',\n\t\tonProgress: helpers.noop,\n\t\tonComplete: helpers.noop\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\tChart.Animation = Element.extend({\n\t\tchart: null, // the animation associated chart instance\n\t\tcurrentStep: 0, // the current animation step\n\t\tnumSteps: 60, // default number of steps\n\t\teasing: '', // the easing to use for this animation\n\t\trender: null, // render function used by the animation service\n\n\t\tonAnimationProgress: null, // user specified callback to fire on each step of the animation\n\t\tonAnimationComplete: null, // user specified callback to fire when the animation finishes\n\t});\n\n\tChart.animationService = {\n\t\tframeDuration: 17,\n\t\tanimations: [],\n\t\tdropFrames: 0,\n\t\trequest: null,\n\n\t\t/**\n\t\t * @param {Chart} chart - The chart to animate.\n\t\t * @param {Chart.Animation} animation - The animation that we will animate.\n\t\t * @param {Number} duration - The animation duration in ms.\n\t\t * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions\n\t\t */\n\t\taddAnimation: function(chart, animation, duration, lazy) {\n\t\t\tvar animations = this.animations;\n\t\t\tvar i, ilen;\n\n\t\t\tanimation.chart = chart;\n\n\t\t\tif (!lazy) {\n\t\t\t\tchart.animating = true;\n\t\t\t}\n\n\t\t\tfor (i = 0, ilen = animations.length; i < ilen; ++i) {\n\t\t\t\tif (animations[i].chart === chart) {\n\t\t\t\t\tanimations[i] = animation;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tanimations.push(animation);\n\n\t\t\t// If there are no animations queued, manually kickstart a digest, for lack of a better word\n\t\t\tif (animations.length === 1) {\n\t\t\t\tthis.requestAnimationFrame();\n\t\t\t}\n\t\t},\n\n\t\tcancelAnimation: function(chart) {\n\t\t\tvar index = helpers.findIndex(this.animations, function(animation) {\n\t\t\t\treturn animation.chart === chart;\n\t\t\t});\n\n\t\t\tif (index !== -1) {\n\t\t\t\tthis.animations.splice(index, 1);\n\t\t\t\tchart.animating = false;\n\t\t\t}\n\t\t},\n\n\t\trequestAnimationFrame: function() {\n\t\t\tvar me = this;\n\t\t\tif (me.request === null) {\n\t\t\t\t// Skip animation frame requests until the active one is executed.\n\t\t\t\t// This can happen when processing mouse events, e.g. 'mousemove'\n\t\t\t\t// and 'mouseout' events will trigger multiple renders.\n\t\t\t\tme.request = helpers.requestAnimFrame.call(window, function() {\n\t\t\t\t\tme.request = null;\n\t\t\t\t\tme.startDigest();\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tstartDigest: function() {\n\t\t\tvar me = this;\n\t\t\tvar startTime = Date.now();\n\t\t\tvar framesToDrop = 0;\n\n\t\t\tif (me.dropFrames > 1) {\n\t\t\t\tframesToDrop = Math.floor(me.dropFrames);\n\t\t\t\tme.dropFrames = me.dropFrames % 1;\n\t\t\t}\n\n\t\t\tme.advance(1 + framesToDrop);\n\n\t\t\tvar endTime = Date.now();\n\n\t\t\tme.dropFrames += (endTime - startTime) / me.frameDuration;\n\n\t\t\t// Do we have more stuff to animate?\n\t\t\tif (me.animations.length > 0) {\n\t\t\t\tme.requestAnimationFrame();\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tadvance: function(count) {\n\t\t\tvar animations = this.animations;\n\t\t\tvar animation, chart;\n\t\t\tvar i = 0;\n\n\t\t\twhile (i < animations.length) {\n\t\t\t\tanimation = animations[i];\n\t\t\t\tchart = animation.chart;\n\n\t\t\t\tanimation.currentStep = (animation.currentStep || 0) + count;\n\t\t\t\tanimation.currentStep = Math.min(animation.currentStep, animation.numSteps);\n\n\t\t\t\thelpers.callback(animation.render, [chart, animation], chart);\n\t\t\t\thelpers.callback(animation.onAnimationProgress, [animation], chart);\n\n\t\t\t\tif (animation.currentStep >= animation.numSteps) {\n\t\t\t\t\thelpers.callback(animation.onAnimationComplete, [animation], chart);\n\t\t\t\t\tchart.animating = false;\n\t\t\t\t\tanimations.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\t++i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Provided for backward compatibility, use Chart.Animation instead\n\t * @prop Chart.Animation#animationObject\n\t * @deprecated since version 2.6.0\n\t * @todo remove at version 3\n\t */\n\tObject.defineProperty(Chart.Animation.prototype, 'animationObject', {\n\t\tget: function() {\n\t\t\treturn this;\n\t\t}\n\t});\n\n\t/**\n\t * Provided for backward compatibility, use Chart.Animation#chart instead\n\t * @prop Chart.Animation#chartInstance\n\t * @deprecated since version 2.6.0\n\t * @todo remove at version 3\n\t */\n\tObject.defineProperty(Chart.Animation.prototype, 'chartInstance', {\n\t\tget: function() {\n\t\t\treturn this.chart;\n\t\t},\n\t\tset: function(value) {\n\t\t\tthis.chart = value;\n\t\t}\n\t});\n\n};\n","'use strict';\n\nvar defaults = require('./core.defaults');\nvar helpers = require('../helpers/index');\nvar Interaction = require('./core.interaction');\nvar layouts = require('./core.layouts');\nvar platform = require('../platforms/platform');\nvar plugins = require('./core.plugins');\n\nmodule.exports = function(Chart) {\n\n\t// Create a dictionary of chart types, to allow for extension of existing types\n\tChart.types = {};\n\n\t// Store a reference to each instance - allowing us to globally resize chart instances on window resize.\n\t// Destroy method on the chart will remove the instance of the chart from this reference.\n\tChart.instances = {};\n\n\t// Controllers available for dataset visualization eg. bar, line, slice, etc.\n\tChart.controllers = {};\n\n\t/**\n\t * Initializes the given config with global and chart default values.\n\t */\n\tfunction initConfig(config) {\n\t\tconfig = config || {};\n\n\t\t// Do NOT use configMerge() for the data object because this method merges arrays\n\t\t// and so would change references to labels and datasets, preventing data updates.\n\t\tvar data = config.data = config.data || {};\n\t\tdata.datasets = data.datasets || [];\n\t\tdata.labels = data.labels || [];\n\n\t\tconfig.options = helpers.configMerge(\n\t\t\tdefaults.global,\n\t\t\tdefaults[config.type],\n\t\t\tconfig.options || {});\n\n\t\treturn config;\n\t}\n\n\t/**\n\t * Updates the config of the chart\n\t * @param chart {Chart} chart to update the options for\n\t */\n\tfunction updateConfig(chart) {\n\t\tvar newOptions = chart.options;\n\n\t\thelpers.each(chart.scales, function(scale) {\n\t\t\tlayouts.removeBox(chart, scale);\n\t\t});\n\n\t\tnewOptions = helpers.configMerge(\n\t\t\tChart.defaults.global,\n\t\t\tChart.defaults[chart.config.type],\n\t\t\tnewOptions);\n\n\t\tchart.options = chart.config.options = newOptions;\n\t\tchart.ensureScalesHaveIDs();\n\t\tchart.buildOrUpdateScales();\n\t\t// Tooltip\n\t\tchart.tooltip._options = newOptions.tooltips;\n\t\tchart.tooltip.initialize();\n\t}\n\n\tfunction positionIsHorizontal(position) {\n\t\treturn position === 'top' || position === 'bottom';\n\t}\n\n\thelpers.extend(Chart.prototype, /** @lends Chart */ {\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tconstruct: function(item, config) {\n\t\t\tvar me = this;\n\n\t\t\tconfig = initConfig(config);\n\n\t\t\tvar context = platform.acquireContext(item, config);\n\t\t\tvar canvas = context && context.canvas;\n\t\t\tvar height = canvas && canvas.height;\n\t\t\tvar width = canvas && canvas.width;\n\n\t\t\tme.id = helpers.uid();\n\t\t\tme.ctx = context;\n\t\t\tme.canvas = canvas;\n\t\t\tme.config = config;\n\t\t\tme.width = width;\n\t\t\tme.height = height;\n\t\t\tme.aspectRatio = height ? width / height : null;\n\t\t\tme.options = config.options;\n\t\t\tme._bufferedRender = false;\n\n\t\t\t/**\n\t\t\t * Provided for backward compatibility, Chart and Chart.Controller have been merged,\n\t\t\t * the \"instance\" still need to be defined since it might be called from plugins.\n\t\t\t * @prop Chart#chart\n\t\t\t * @deprecated since version 2.6.0\n\t\t\t * @todo remove at version 3\n\t\t\t * @private\n\t\t\t */\n\t\t\tme.chart = me;\n\t\t\tme.controller = me; // chart.chart.controller #inception\n\n\t\t\t// Add the chart instance to the global namespace\n\t\t\tChart.instances[me.id] = me;\n\n\t\t\t// Define alias to the config data: `chart.data === chart.config.data`\n\t\t\tObject.defineProperty(me, 'data', {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn me.config.data;\n\t\t\t\t},\n\t\t\t\tset: function(value) {\n\t\t\t\t\tme.config.data = value;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!context || !canvas) {\n\t\t\t\t// The given item is not a compatible context2d element, let's return before finalizing\n\t\t\t\t// the chart initialization but after setting basic chart / controller properties that\n\t\t\t\t// can help to figure out that the chart is not valid (e.g chart.canvas !== null);\n\t\t\t\t// https://github.com/chartjs/Chart.js/issues/2807\n\t\t\t\tconsole.error(\"Failed to create chart: can't acquire context from the given item\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tme.initialize();\n\t\t\tme.update();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tinitialize: function() {\n\t\t\tvar me = this;\n\n\t\t\t// Before init plugin notification\n\t\t\tplugins.notify(me, 'beforeInit');\n\n\t\t\thelpers.retinaScale(me, me.options.devicePixelRatio);\n\n\t\t\tme.bindEvents();\n\n\t\t\tif (me.options.responsive) {\n\t\t\t\t// Initial resize before chart draws (must be silent to preserve initial animations).\n\t\t\t\tme.resize(true);\n\t\t\t}\n\n\t\t\t// Make sure scales have IDs and are built before we build any controllers.\n\t\t\tme.ensureScalesHaveIDs();\n\t\t\tme.buildOrUpdateScales();\n\t\t\tme.initToolTip();\n\n\t\t\t// After init plugin notification\n\t\t\tplugins.notify(me, 'afterInit');\n\n\t\t\treturn me;\n\t\t},\n\n\t\tclear: function() {\n\t\t\thelpers.canvas.clear(this);\n\t\t\treturn this;\n\t\t},\n\n\t\tstop: function() {\n\t\t\t// Stops any current animation loop occurring\n\t\t\tChart.animationService.cancelAnimation(this);\n\t\t\treturn this;\n\t\t},\n\n\t\tresize: function(silent) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tvar canvas = me.canvas;\n\t\t\tvar aspectRatio = (options.maintainAspectRatio && me.aspectRatio) || null;\n\n\t\t\t// the canvas render width and height will be casted to integers so make sure that\n\t\t\t// the canvas display style uses the same integer values to avoid blurring effect.\n\n\t\t\t// Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collased\n\t\t\tvar newWidth = Math.max(0, Math.floor(helpers.getMaximumWidth(canvas)));\n\t\t\tvar newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas)));\n\n\t\t\tif (me.width === newWidth && me.height === newHeight) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcanvas.width = me.width = newWidth;\n\t\t\tcanvas.height = me.height = newHeight;\n\t\t\tcanvas.style.width = newWidth + 'px';\n\t\t\tcanvas.style.height = newHeight + 'px';\n\n\t\t\thelpers.retinaScale(me, options.devicePixelRatio);\n\n\t\t\tif (!silent) {\n\t\t\t\t// Notify any plugins about the resize\n\t\t\t\tvar newSize = {width: newWidth, height: newHeight};\n\t\t\t\tplugins.notify(me, 'resize', [newSize]);\n\n\t\t\t\t// Notify of resize\n\t\t\t\tif (me.options.onResize) {\n\t\t\t\t\tme.options.onResize(me, newSize);\n\t\t\t\t}\n\n\t\t\t\tme.stop();\n\t\t\t\tme.update(me.options.responsiveAnimationDuration);\n\t\t\t}\n\t\t},\n\n\t\tensureScalesHaveIDs: function() {\n\t\t\tvar options = this.options;\n\t\t\tvar scalesOptions = options.scales || {};\n\t\t\tvar scaleOptions = options.scale;\n\n\t\t\thelpers.each(scalesOptions.xAxes, function(xAxisOptions, index) {\n\t\t\t\txAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);\n\t\t\t});\n\n\t\t\thelpers.each(scalesOptions.yAxes, function(yAxisOptions, index) {\n\t\t\t\tyAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);\n\t\t\t});\n\n\t\t\tif (scaleOptions) {\n\t\t\t\tscaleOptions.id = scaleOptions.id || 'scale';\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Builds a map of scale ID to scale object for future lookup.\n\t\t */\n\t\tbuildOrUpdateScales: function() {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tvar scales = me.scales || {};\n\t\t\tvar items = [];\n\t\t\tvar updated = Object.keys(scales).reduce(function(obj, id) {\n\t\t\t\tobj[id] = false;\n\t\t\t\treturn obj;\n\t\t\t}, {});\n\n\t\t\tif (options.scales) {\n\t\t\t\titems = items.concat(\n\t\t\t\t\t(options.scales.xAxes || []).map(function(xAxisOptions) {\n\t\t\t\t\t\treturn {options: xAxisOptions, dtype: 'category', dposition: 'bottom'};\n\t\t\t\t\t}),\n\t\t\t\t\t(options.scales.yAxes || []).map(function(yAxisOptions) {\n\t\t\t\t\t\treturn {options: yAxisOptions, dtype: 'linear', dposition: 'left'};\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (options.scale) {\n\t\t\t\titems.push({\n\t\t\t\t\toptions: options.scale,\n\t\t\t\t\tdtype: 'radialLinear',\n\t\t\t\t\tisDefault: true,\n\t\t\t\t\tdposition: 'chartArea'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thelpers.each(items, function(item) {\n\t\t\t\tvar scaleOptions = item.options;\n\t\t\t\tvar id = scaleOptions.id;\n\t\t\t\tvar scaleType = helpers.valueOrDefault(scaleOptions.type, item.dtype);\n\n\t\t\t\tif (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {\n\t\t\t\t\tscaleOptions.position = item.dposition;\n\t\t\t\t}\n\n\t\t\t\tupdated[id] = true;\n\t\t\t\tvar scale = null;\n\t\t\t\tif (id in scales && scales[id].type === scaleType) {\n\t\t\t\t\tscale = scales[id];\n\t\t\t\t\tscale.options = scaleOptions;\n\t\t\t\t\tscale.ctx = me.ctx;\n\t\t\t\t\tscale.chart = me;\n\t\t\t\t} else {\n\t\t\t\t\tvar scaleClass = Chart.scaleService.getScaleConstructor(scaleType);\n\t\t\t\t\tif (!scaleClass) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tscale = new scaleClass({\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\ttype: scaleType,\n\t\t\t\t\t\toptions: scaleOptions,\n\t\t\t\t\t\tctx: me.ctx,\n\t\t\t\t\t\tchart: me\n\t\t\t\t\t});\n\t\t\t\t\tscales[scale.id] = scale;\n\t\t\t\t}\n\n\t\t\t\tscale.mergeTicksOptions();\n\n\t\t\t\t// TODO(SB): I think we should be able to remove this custom case (options.scale)\n\t\t\t\t// and consider it as a regular scale part of the \"scales\"\" map only! This would\n\t\t\t\t// make the logic easier and remove some useless? custom code.\n\t\t\t\tif (item.isDefault) {\n\t\t\t\t\tme.scale = scale;\n\t\t\t\t}\n\t\t\t});\n\t\t\t// clear up discarded scales\n\t\t\thelpers.each(updated, function(hasUpdated, id) {\n\t\t\t\tif (!hasUpdated) {\n\t\t\t\t\tdelete scales[id];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tme.scales = scales;\n\n\t\t\tChart.scaleService.addScalesToLayout(this);\n\t\t},\n\n\t\tbuildOrUpdateControllers: function() {\n\t\t\tvar me = this;\n\t\t\tvar types = [];\n\t\t\tvar newControllers = [];\n\n\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tvar meta = me.getDatasetMeta(datasetIndex);\n\t\t\t\tvar type = dataset.type || me.config.type;\n\n\t\t\t\tif (meta.type && meta.type !== type) {\n\t\t\t\t\tme.destroyDatasetMeta(datasetIndex);\n\t\t\t\t\tmeta = me.getDatasetMeta(datasetIndex);\n\t\t\t\t}\n\t\t\t\tmeta.type = type;\n\n\t\t\t\ttypes.push(meta.type);\n\n\t\t\t\tif (meta.controller) {\n\t\t\t\t\tmeta.controller.updateIndex(datasetIndex);\n\t\t\t\t\tmeta.controller.linkScales();\n\t\t\t\t} else {\n\t\t\t\t\tvar ControllerClass = Chart.controllers[meta.type];\n\t\t\t\t\tif (ControllerClass === undefined) {\n\t\t\t\t\t\tthrow new Error('\"' + meta.type + '\" is not a chart type.');\n\t\t\t\t\t}\n\n\t\t\t\t\tmeta.controller = new ControllerClass(me, datasetIndex);\n\t\t\t\t\tnewControllers.push(meta.controller);\n\t\t\t\t}\n\t\t\t}, me);\n\n\t\t\treturn newControllers;\n\t\t},\n\n\t\t/**\n\t\t * Reset the elements of all datasets\n\t\t * @private\n\t\t */\n\t\tresetElements: function() {\n\t\t\tvar me = this;\n\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tme.getDatasetMeta(datasetIndex).controller.reset();\n\t\t\t}, me);\n\t\t},\n\n\t\t/**\n\t\t* Resets the chart back to it's state before the initial animation\n\t\t*/\n\t\treset: function() {\n\t\t\tthis.resetElements();\n\t\t\tthis.tooltip.initialize();\n\t\t},\n\n\t\tupdate: function(config) {\n\t\t\tvar me = this;\n\n\t\t\tif (!config || typeof config !== 'object') {\n\t\t\t\t// backwards compatibility\n\t\t\t\tconfig = {\n\t\t\t\t\tduration: config,\n\t\t\t\t\tlazy: arguments[1]\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tupdateConfig(me);\n\n\t\t\t// plugins options references might have change, let's invalidate the cache\n\t\t\t// https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\n\t\t\tplugins._invalidate(me);\n\n\t\t\tif (plugins.notify(me, 'beforeUpdate') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// In case the entire data object changed\n\t\t\tme.tooltip._data = me.data;\n\n\t\t\t// Make sure dataset controllers are updated and new controllers are reset\n\t\t\tvar newControllers = me.buildOrUpdateControllers();\n\n\t\t\t// Make sure all dataset controllers have correct meta data counts\n\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tme.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();\n\t\t\t}, me);\n\n\t\t\tme.updateLayout();\n\n\t\t\t// Can only reset the new controllers after the scales have been updated\n\t\t\tif (me.options.animation && me.options.animation.duration) {\n\t\t\t\thelpers.each(newControllers, function(controller) {\n\t\t\t\t\tcontroller.reset();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tme.updateDatasets();\n\n\t\t\t// Need to reset tooltip in case it is displayed with elements that are removed\n\t\t\t// after update.\n\t\t\tme.tooltip.initialize();\n\n\t\t\t// Last active contains items that were previously in the tooltip.\n\t\t\t// When we reset the tooltip, we need to clear it\n\t\t\tme.lastActive = [];\n\n\t\t\t// Do this before render so that any plugins that need final scale updates can use it\n\t\t\tplugins.notify(me, 'afterUpdate');\n\n\t\t\tif (me._bufferedRender) {\n\t\t\t\tme._bufferedRequest = {\n\t\t\t\t\tduration: config.duration,\n\t\t\t\t\teasing: config.easing,\n\t\t\t\t\tlazy: config.lazy\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tme.render(config);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\n\t\t * hook, in which case, plugins will not be called on `afterLayout`.\n\t\t * @private\n\t\t */\n\t\tupdateLayout: function() {\n\t\t\tvar me = this;\n\n\t\t\tif (plugins.notify(me, 'beforeLayout') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlayouts.update(this, this.width, this.height);\n\n\t\t\t/**\n\t\t\t * Provided for backward compatibility, use `afterLayout` instead.\n\t\t\t * @method IPlugin#afterScaleUpdate\n\t\t\t * @deprecated since version 2.5.0\n\t\t\t * @todo remove at version 3\n\t\t\t * @private\n\t\t\t */\n\t\t\tplugins.notify(me, 'afterScaleUpdate');\n\t\t\tplugins.notify(me, 'afterLayout');\n\t\t},\n\n\t\t/**\n\t\t * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\n\t\t * @private\n\t\t */\n\t\tupdateDatasets: function() {\n\t\t\tvar me = this;\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetsUpdate') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n\t\t\t\tme.updateDataset(i);\n\t\t\t}\n\n\t\t\tplugins.notify(me, 'afterDatasetsUpdate');\n\t\t},\n\n\t\t/**\n\t\t * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetUpdate`.\n\t\t * @private\n\t\t */\n\t\tupdateDataset: function(index) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getDatasetMeta(index);\n\t\t\tvar args = {\n\t\t\t\tmeta: meta,\n\t\t\t\tindex: index\n\t\t\t};\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmeta.controller.update();\n\n\t\t\tplugins.notify(me, 'afterDatasetUpdate', [args]);\n\t\t},\n\n\t\trender: function(config) {\n\t\t\tvar me = this;\n\n\t\t\tif (!config || typeof config !== 'object') {\n\t\t\t\t// backwards compatibility\n\t\t\t\tconfig = {\n\t\t\t\t\tduration: config,\n\t\t\t\t\tlazy: arguments[1]\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tvar duration = config.duration;\n\t\t\tvar lazy = config.lazy;\n\n\t\t\tif (plugins.notify(me, 'beforeRender') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar animationOptions = me.options.animation;\n\t\t\tvar onComplete = function(animation) {\n\t\t\t\tplugins.notify(me, 'afterRender');\n\t\t\t\thelpers.callback(animationOptions && animationOptions.onComplete, [animation], me);\n\t\t\t};\n\n\t\t\tif (animationOptions && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && animationOptions.duration !== 0))) {\n\t\t\t\tvar animation = new Chart.Animation({\n\t\t\t\t\tnumSteps: (duration || animationOptions.duration) / 16.66, // 60 fps\n\t\t\t\t\teasing: config.easing || animationOptions.easing,\n\n\t\t\t\t\trender: function(chart, animationObject) {\n\t\t\t\t\t\tvar easingFunction = helpers.easing.effects[animationObject.easing];\n\t\t\t\t\t\tvar currentStep = animationObject.currentStep;\n\t\t\t\t\t\tvar stepDecimal = currentStep / animationObject.numSteps;\n\n\t\t\t\t\t\tchart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);\n\t\t\t\t\t},\n\n\t\t\t\t\tonAnimationProgress: animationOptions.onProgress,\n\t\t\t\t\tonAnimationComplete: onComplete\n\t\t\t\t});\n\n\t\t\t\tChart.animationService.addAnimation(me, animation, duration, lazy);\n\t\t\t} else {\n\t\t\t\tme.draw();\n\n\t\t\t\t// See https://github.com/chartjs/Chart.js/issues/3781\n\t\t\t\tonComplete(new Chart.Animation({numSteps: 0, chart: me}));\n\t\t\t}\n\n\t\t\treturn me;\n\t\t},\n\n\t\tdraw: function(easingValue) {\n\t\t\tvar me = this;\n\n\t\t\tme.clear();\n\n\t\t\tif (helpers.isNullOrUndef(easingValue)) {\n\t\t\t\teasingValue = 1;\n\t\t\t}\n\n\t\t\tme.transition(easingValue);\n\n\t\t\tif (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Draw all the scales\n\t\t\thelpers.each(me.boxes, function(box) {\n\t\t\t\tbox.draw(me.chartArea);\n\t\t\t}, me);\n\n\t\t\tif (me.scale) {\n\t\t\t\tme.scale.draw();\n\t\t\t}\n\n\t\t\tme.drawDatasets(easingValue);\n\t\t\tme._drawTooltip(easingValue);\n\n\t\t\tplugins.notify(me, 'afterDraw', [easingValue]);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\ttransition: function(easingValue) {\n\t\t\tvar me = this;\n\n\t\t\tfor (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\tif (me.isDatasetVisible(i)) {\n\t\t\t\t\tme.getDatasetMeta(i).controller.transition(easingValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.tooltip.transition(easingValue);\n\t\t},\n\n\t\t/**\n\t\t * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\n\t\t * @private\n\t\t */\n\t\tdrawDatasets: function(easingValue) {\n\t\t\tvar me = this;\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Draw datasets reversed to support proper line stacking\n\t\t\tfor (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {\n\t\t\t\tif (me.isDatasetVisible(i)) {\n\t\t\t\t\tme.drawDataset(i, easingValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplugins.notify(me, 'afterDatasetsDraw', [easingValue]);\n\t\t},\n\n\t\t/**\n\t\t * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetDraw`.\n\t\t * @private\n\t\t */\n\t\tdrawDataset: function(index, easingValue) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getDatasetMeta(index);\n\t\t\tvar args = {\n\t\t\t\tmeta: meta,\n\t\t\t\tindex: index,\n\t\t\t\teasingValue: easingValue\n\t\t\t};\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmeta.controller.draw(easingValue);\n\n\t\t\tplugins.notify(me, 'afterDatasetDraw', [args]);\n\t\t},\n\n\t\t/**\n\t\t * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`\n\t\t * hook, in which case, plugins will not be called on `afterTooltipDraw`.\n\t\t * @private\n\t\t */\n\t\t_drawTooltip: function(easingValue) {\n\t\t\tvar me = this;\n\t\t\tvar tooltip = me.tooltip;\n\t\t\tvar args = {\n\t\t\t\ttooltip: tooltip,\n\t\t\t\teasingValue: easingValue\n\t\t\t};\n\n\t\t\tif (plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttooltip.draw();\n\n\t\t\tplugins.notify(me, 'afterTooltipDraw', [args]);\n\t\t},\n\n\t\t// Get the single element that was clicked on\n\t\t// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw\n\t\tgetElementAtEvent: function(e) {\n\t\t\treturn Interaction.modes.single(this, e);\n\t\t},\n\n\t\tgetElementsAtEvent: function(e) {\n\t\t\treturn Interaction.modes.label(this, e, {intersect: true});\n\t\t},\n\n\t\tgetElementsAtXAxis: function(e) {\n\t\t\treturn Interaction.modes['x-axis'](this, e, {intersect: true});\n\t\t},\n\n\t\tgetElementsAtEventForMode: function(e, mode, options) {\n\t\t\tvar method = Interaction.modes[mode];\n\t\t\tif (typeof method === 'function') {\n\t\t\t\treturn method(this, e, options);\n\t\t\t}\n\n\t\t\treturn [];\n\t\t},\n\n\t\tgetDatasetAtEvent: function(e) {\n\t\t\treturn Interaction.modes.dataset(this, e, {intersect: true});\n\t\t},\n\n\t\tgetDatasetMeta: function(datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.data.datasets[datasetIndex];\n\t\t\tif (!dataset._meta) {\n\t\t\t\tdataset._meta = {};\n\t\t\t}\n\n\t\t\tvar meta = dataset._meta[me.id];\n\t\t\tif (!meta) {\n\t\t\t\tmeta = dataset._meta[me.id] = {\n\t\t\t\t\ttype: null,\n\t\t\t\t\tdata: [],\n\t\t\t\t\tdataset: null,\n\t\t\t\t\tcontroller: null,\n\t\t\t\t\thidden: null,\t\t\t// See isDatasetVisible() comment\n\t\t\t\t\txAxisID: null,\n\t\t\t\t\tyAxisID: null\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn meta;\n\t\t},\n\n\t\tgetVisibleDatasetCount: function() {\n\t\t\tvar count = 0;\n\t\t\tfor (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n\t\t\t\tif (this.isDatasetVisible(i)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn count;\n\t\t},\n\n\t\tisDatasetVisible: function(datasetIndex) {\n\t\t\tvar meta = this.getDatasetMeta(datasetIndex);\n\n\t\t\t// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\n\t\t\t// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\n\t\t\treturn typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;\n\t\t},\n\n\t\tgenerateLegend: function() {\n\t\t\treturn this.options.legendCallback(this);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tdestroyDatasetMeta: function(datasetIndex) {\n\t\t\tvar id = this.id;\n\t\t\tvar dataset = this.data.datasets[datasetIndex];\n\t\t\tvar meta = dataset._meta && dataset._meta[id];\n\n\t\t\tif (meta) {\n\t\t\t\tmeta.controller.destroy();\n\t\t\t\tdelete dataset._meta[id];\n\t\t\t}\n\t\t},\n\n\t\tdestroy: function() {\n\t\t\tvar me = this;\n\t\t\tvar canvas = me.canvas;\n\t\t\tvar i, ilen;\n\n\t\t\tme.stop();\n\n\t\t\t// dataset controllers need to cleanup associated data\n\t\t\tfor (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n\t\t\t\tme.destroyDatasetMeta(i);\n\t\t\t}\n\n\t\t\tif (canvas) {\n\t\t\t\tme.unbindEvents();\n\t\t\t\thelpers.canvas.clear(me);\n\t\t\t\tplatform.releaseContext(me.ctx);\n\t\t\t\tme.canvas = null;\n\t\t\t\tme.ctx = null;\n\t\t\t}\n\n\t\t\tplugins.notify(me, 'destroy');\n\n\t\t\tdelete Chart.instances[me.id];\n\t\t},\n\n\t\ttoBase64Image: function() {\n\t\t\treturn this.canvas.toDataURL.apply(this.canvas, arguments);\n\t\t},\n\n\t\tinitToolTip: function() {\n\t\t\tvar me = this;\n\t\t\tme.tooltip = new Chart.Tooltip({\n\t\t\t\t_chart: me,\n\t\t\t\t_chartInstance: me, // deprecated, backward compatibility\n\t\t\t\t_data: me.data,\n\t\t\t\t_options: me.options.tooltips\n\t\t\t}, me);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tbindEvents: function() {\n\t\t\tvar me = this;\n\t\t\tvar listeners = me._listeners = {};\n\t\t\tvar listener = function() {\n\t\t\t\tme.eventHandler.apply(me, arguments);\n\t\t\t};\n\n\t\t\thelpers.each(me.options.events, function(type) {\n\t\t\t\tplatform.addEventListener(me, type, listener);\n\t\t\t\tlisteners[type] = listener;\n\t\t\t});\n\n\t\t\t// Elements used to detect size change should not be injected for non responsive charts.\n\t\t\t// See https://github.com/chartjs/Chart.js/issues/2210\n\t\t\tif (me.options.responsive) {\n\t\t\t\tlistener = function() {\n\t\t\t\t\tme.resize();\n\t\t\t\t};\n\n\t\t\t\tplatform.addEventListener(me, 'resize', listener);\n\t\t\t\tlisteners.resize = listener;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tunbindEvents: function() {\n\t\t\tvar me = this;\n\t\t\tvar listeners = me._listeners;\n\t\t\tif (!listeners) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdelete me._listeners;\n\t\t\thelpers.each(listeners, function(listener, type) {\n\t\t\t\tplatform.removeEventListener(me, type, listener);\n\t\t\t});\n\t\t},\n\n\t\tupdateHoverStyle: function(elements, mode, enabled) {\n\t\t\tvar method = enabled ? 'setHoverStyle' : 'removeHoverStyle';\n\t\t\tvar element, i, ilen;\n\n\t\t\tfor (i = 0, ilen = elements.length; i < ilen; ++i) {\n\t\t\t\telement = elements[i];\n\t\t\t\tif (element) {\n\t\t\t\t\tthis.getDatasetMeta(element._datasetIndex).controller[method](element);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\teventHandler: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar tooltip = me.tooltip;\n\n\t\t\tif (plugins.notify(me, 'beforeEvent', [e]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Buffer any update calls so that renders do not occur\n\t\t\tme._bufferedRender = true;\n\t\t\tme._bufferedRequest = null;\n\n\t\t\tvar changed = me.handleEvent(e);\n\t\t\t// for smooth tooltip animations issue #4989\n\t\t\t// the tooltip should be the source of change\n\t\t\t// Animation check workaround:\n\t\t\t// tooltip._start will be null when tooltip isn't animating\n\t\t\tif (tooltip) {\n\t\t\t\tchanged = tooltip._start\n\t\t\t\t\t? tooltip.handleEvent(e)\n\t\t\t\t\t: changed | tooltip.handleEvent(e);\n\t\t\t}\n\n\t\t\tplugins.notify(me, 'afterEvent', [e]);\n\n\t\t\tvar bufferedRequest = me._bufferedRequest;\n\t\t\tif (bufferedRequest) {\n\t\t\t\t// If we have an update that was triggered, we need to do a normal render\n\t\t\t\tme.render(bufferedRequest);\n\t\t\t} else if (changed && !me.animating) {\n\t\t\t\t// If entering, leaving, or changing elements, animate the change via pivot\n\t\t\t\tme.stop();\n\n\t\t\t\t// We only need to render at this point. Updating will cause scales to be\n\t\t\t\t// recomputed generating flicker & using more memory than necessary.\n\t\t\t\tme.render(me.options.hover.animationDuration, true);\n\t\t\t}\n\n\t\t\tme._bufferedRender = false;\n\t\t\tme._bufferedRequest = null;\n\n\t\t\treturn me;\n\t\t},\n\n\t\t/**\n\t\t * Handle an event\n\t\t * @private\n\t\t * @param {IEvent} event the event to handle\n\t\t * @return {Boolean} true if the chart needs to re-render\n\t\t */\n\t\thandleEvent: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options || {};\n\t\t\tvar hoverOptions = options.hover;\n\t\t\tvar changed = false;\n\n\t\t\tme.lastActive = me.lastActive || [];\n\n\t\t\t// Find Active Elements for hover and tooltips\n\t\t\tif (e.type === 'mouseout') {\n\t\t\t\tme.active = [];\n\t\t\t} else {\n\t\t\t\tme.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);\n\t\t\t}\n\n\t\t\t// Invoke onHover hook\n\t\t\t// Need to call with native event here to not break backwards compatibility\n\t\t\thelpers.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);\n\n\t\t\tif (e.type === 'mouseup' || e.type === 'click') {\n\t\t\t\tif (options.onClick) {\n\t\t\t\t\t// Use e.native here for backwards compatibility\n\t\t\t\t\toptions.onClick.call(me, e.native, me.active);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove styling for last active (even if it may still be active)\n\t\t\tif (me.lastActive.length) {\n\t\t\t\tme.updateHoverStyle(me.lastActive, hoverOptions.mode, false);\n\t\t\t}\n\n\t\t\t// Built in hover styling\n\t\t\tif (me.active.length && hoverOptions.mode) {\n\t\t\t\tme.updateHoverStyle(me.active, hoverOptions.mode, true);\n\t\t\t}\n\n\t\t\tchanged = !helpers.arrayEquals(me.active, me.lastActive);\n\n\t\t\t// Remember Last Actives\n\t\t\tme.lastActive = me.active;\n\n\t\t\treturn changed;\n\t\t}\n\t});\n\n\t/**\n\t * Provided for backward compatibility, use Chart instead.\n\t * @class Chart.Controller\n\t * @deprecated since version 2.6.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\tChart.Controller = Chart;\n};\n","'use strict';\n\nvar helpers = require('../helpers/index');\n\nmodule.exports = function(Chart) {\n\n\tvar arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\n\n\t/**\n\t * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\n\t * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\n\t * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.\n\t */\n\tfunction listenArrayEvents(array, listener) {\n\t\tif (array._chartjs) {\n\t\t\tarray._chartjs.listeners.push(listener);\n\t\t\treturn;\n\t\t}\n\n\t\tObject.defineProperty(array, '_chartjs', {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: {\n\t\t\t\tlisteners: [listener]\n\t\t\t}\n\t\t});\n\n\t\tarrayEvents.forEach(function(key) {\n\t\t\tvar method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);\n\t\t\tvar base = array[key];\n\n\t\t\tObject.defineProperty(array, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: function() {\n\t\t\t\t\tvar args = Array.prototype.slice.call(arguments);\n\t\t\t\t\tvar res = base.apply(this, args);\n\n\t\t\t\t\thelpers.each(array._chartjs.listeners, function(object) {\n\t\t\t\t\t\tif (typeof object[method] === 'function') {\n\t\t\t\t\t\t\tobject[method].apply(object, args);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Removes the given array event listener and cleanup extra attached properties (such as\n\t * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\n\t */\n\tfunction unlistenArrayEvents(array, listener) {\n\t\tvar stub = array._chartjs;\n\t\tif (!stub) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar listeners = stub.listeners;\n\t\tvar index = listeners.indexOf(listener);\n\t\tif (index !== -1) {\n\t\t\tlisteners.splice(index, 1);\n\t\t}\n\n\t\tif (listeners.length > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tarrayEvents.forEach(function(key) {\n\t\t\tdelete array[key];\n\t\t});\n\n\t\tdelete array._chartjs;\n\t}\n\n\t// Base class for all dataset controllers (line, bar, etc)\n\tChart.DatasetController = function(chart, datasetIndex) {\n\t\tthis.initialize(chart, datasetIndex);\n\t};\n\n\thelpers.extend(Chart.DatasetController.prototype, {\n\n\t\t/**\n\t\t * Element type used to generate a meta dataset (e.g. Chart.element.Line).\n\t\t * @type {Chart.core.element}\n\t\t */\n\t\tdatasetElementType: null,\n\n\t\t/**\n\t\t * Element type used to generate a meta data (e.g. Chart.element.Point).\n\t\t * @type {Chart.core.element}\n\t\t */\n\t\tdataElementType: null,\n\n\t\tinitialize: function(chart, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tme.chart = chart;\n\t\t\tme.index = datasetIndex;\n\t\t\tme.linkScales();\n\t\t\tme.addElements();\n\t\t},\n\n\t\tupdateIndex: function(datasetIndex) {\n\t\t\tthis.index = datasetIndex;\n\t\t},\n\n\t\tlinkScales: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar dataset = me.getDataset();\n\n\t\t\tif (meta.xAxisID === null || !(meta.xAxisID in me.chart.scales)) {\n\t\t\t\tmeta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;\n\t\t\t}\n\t\t\tif (meta.yAxisID === null || !(meta.yAxisID in me.chart.scales)) {\n\t\t\t\tmeta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;\n\t\t\t}\n\t\t},\n\n\t\tgetDataset: function() {\n\t\t\treturn this.chart.data.datasets[this.index];\n\t\t},\n\n\t\tgetMeta: function() {\n\t\t\treturn this.chart.getDatasetMeta(this.index);\n\t\t},\n\n\t\tgetScaleForId: function(scaleID) {\n\t\t\treturn this.chart.scales[scaleID];\n\t\t},\n\n\t\treset: function() {\n\t\t\tthis.update(true);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tdestroy: function() {\n\t\t\tif (this._data) {\n\t\t\t\tunlistenArrayEvents(this._data, this);\n\t\t\t}\n\t\t},\n\n\t\tcreateMetaDataset: function() {\n\t\t\tvar me = this;\n\t\t\tvar type = me.datasetElementType;\n\t\t\treturn type && new type({\n\t\t\t\t_chart: me.chart,\n\t\t\t\t_datasetIndex: me.index\n\t\t\t});\n\t\t},\n\n\t\tcreateMetaData: function(index) {\n\t\t\tvar me = this;\n\t\t\tvar type = me.dataElementType;\n\t\t\treturn type && new type({\n\t\t\t\t_chart: me.chart,\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index\n\t\t\t});\n\t\t},\n\n\t\taddElements: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar data = me.getDataset().data || [];\n\t\t\tvar metaData = meta.data;\n\t\t\tvar i, ilen;\n\n\t\t\tfor (i = 0, ilen = data.length; i < ilen; ++i) {\n\t\t\t\tmetaData[i] = metaData[i] || me.createMetaData(i);\n\t\t\t}\n\n\t\t\tmeta.dataset = meta.dataset || me.createMetaDataset();\n\t\t},\n\n\t\taddElementAndReset: function(index) {\n\t\t\tvar element = this.createMetaData(index);\n\t\t\tthis.getMeta().data.splice(index, 0, element);\n\t\t\tthis.updateElement(element, index, true);\n\t\t},\n\n\t\tbuildOrUpdateElements: function() {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar data = dataset.data || (dataset.data = []);\n\n\t\t\t// In order to correctly handle data addition/deletion animation (an thus simulate\n\t\t\t// real-time charts), we need to monitor these data modifications and synchronize\n\t\t\t// the internal meta data accordingly.\n\t\t\tif (me._data !== data) {\n\t\t\t\tif (me._data) {\n\t\t\t\t\t// This case happens when the user replaced the data array instance.\n\t\t\t\t\tunlistenArrayEvents(me._data, me);\n\t\t\t\t}\n\n\t\t\t\tlistenArrayEvents(data, me);\n\t\t\t\tme._data = data;\n\t\t\t}\n\n\t\t\t// Re-sync meta data in case the user replaced the data array or if we missed\n\t\t\t// any updates and so make sure that we handle number of datapoints changing.\n\t\t\tme.resyncElements();\n\t\t},\n\n\t\tupdate: helpers.noop,\n\n\t\ttransition: function(easingValue) {\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar elements = meta.data || [];\n\t\t\tvar ilen = elements.length;\n\t\t\tvar i = 0;\n\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\telements[i].transition(easingValue);\n\t\t\t}\n\n\t\t\tif (meta.dataset) {\n\t\t\t\tmeta.dataset.transition(easingValue);\n\t\t\t}\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar elements = meta.data || [];\n\t\t\tvar ilen = elements.length;\n\t\t\tvar i = 0;\n\n\t\t\tif (meta.dataset) {\n\t\t\t\tmeta.dataset.draw();\n\t\t\t}\n\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\telements[i].draw();\n\t\t\t}\n\t\t},\n\n\t\tremoveHoverStyle: function(element, elementOpts) {\n\t\t\tvar dataset = this.chart.data.datasets[element._datasetIndex];\n\t\t\tvar index = element._index;\n\t\t\tvar custom = element.custom || {};\n\t\t\tvar valueOrDefault = helpers.valueAtIndexOrDefault;\n\t\t\tvar model = element._model;\n\n\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);\n\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);\n\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);\n\t\t},\n\n\t\tsetHoverStyle: function(element) {\n\t\t\tvar dataset = this.chart.data.datasets[element._datasetIndex];\n\t\t\tvar index = element._index;\n\t\t\tvar custom = element.custom || {};\n\t\t\tvar valueOrDefault = helpers.valueAtIndexOrDefault;\n\t\t\tvar getHoverColor = helpers.getHoverColor;\n\t\t\tvar model = element._model;\n\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tresyncElements: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar data = me.getDataset().data;\n\t\t\tvar numMeta = meta.data.length;\n\t\t\tvar numData = data.length;\n\n\t\t\tif (numData < numMeta) {\n\t\t\t\tmeta.data.splice(numData, numMeta - numData);\n\t\t\t} else if (numData > numMeta) {\n\t\t\t\tme.insertElements(numMeta, numData - numMeta);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tinsertElements: function(start, count) {\n\t\t\tfor (var i = 0; i < count; ++i) {\n\t\t\t\tthis.addElementAndReset(start + i);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataPush: function() {\n\t\t\tthis.insertElements(this.getDataset().data.length - 1, arguments.length);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataPop: function() {\n\t\t\tthis.getMeta().data.pop();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataShift: function() {\n\t\t\tthis.getMeta().data.shift();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataSplice: function(start, count) {\n\t\t\tthis.getMeta().data.splice(start, count);\n\t\t\tthis.insertElements(start, arguments.length - 2);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataUnshift: function() {\n\t\t\tthis.insertElements(0, arguments.length);\n\t\t}\n\t});\n\n\tChart.DatasetController.extend = helpers.inherits;\n};\n","'use strict';\n\nvar helpers = require('../helpers/index');\n\nmodule.exports = {\n\t/**\n\t * @private\n\t */\n\t_set: function(scope, values) {\n\t\treturn helpers.merge(this[scope] || (this[scope] = {}), values);\n\t}\n};\n","'use strict';\n\nvar color = require('chartjs-color');\nvar helpers = require('../helpers/index');\n\nfunction interpolate(start, view, model, ease) {\n\tvar keys = Object.keys(model);\n\tvar i, ilen, key, actual, origin, target, type, c0, c1;\n\n\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\tkey = keys[i];\n\n\t\ttarget = model[key];\n\n\t\t// if a value is added to the model after pivot() has been called, the view\n\t\t// doesn't contain it, so let's initialize the view to the target value.\n\t\tif (!view.hasOwnProperty(key)) {\n\t\t\tview[key] = target;\n\t\t}\n\n\t\tactual = view[key];\n\n\t\tif (actual === target || key[0] === '_') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!start.hasOwnProperty(key)) {\n\t\t\tstart[key] = actual;\n\t\t}\n\n\t\torigin = start[key];\n\n\t\ttype = typeof target;\n\n\t\tif (type === typeof origin) {\n\t\t\tif (type === 'string') {\n\t\t\t\tc0 = color(origin);\n\t\t\t\tif (c0.valid) {\n\t\t\t\t\tc1 = color(target);\n\t\t\t\t\tif (c1.valid) {\n\t\t\t\t\t\tview[key] = c1.mix(c0, ease).rgbString();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'number' && isFinite(origin) && isFinite(target)) {\n\t\t\t\tview[key] = origin + (target - origin) * ease;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tview[key] = target;\n\t}\n}\n\nvar Element = function(configuration) {\n\thelpers.extend(this, configuration);\n\tthis.initialize.apply(this, arguments);\n};\n\nhelpers.extend(Element.prototype, {\n\n\tinitialize: function() {\n\t\tthis.hidden = false;\n\t},\n\n\tpivot: function() {\n\t\tvar me = this;\n\t\tif (!me._view) {\n\t\t\tme._view = helpers.clone(me._model);\n\t\t}\n\t\tme._start = {};\n\t\treturn me;\n\t},\n\n\ttransition: function(ease) {\n\t\tvar me = this;\n\t\tvar model = me._model;\n\t\tvar start = me._start;\n\t\tvar view = me._view;\n\n\t\t// No animation -> No Transition\n\t\tif (!model || ease === 1) {\n\t\t\tme._view = model;\n\t\t\tme._start = null;\n\t\t\treturn me;\n\t\t}\n\n\t\tif (!view) {\n\t\t\tview = me._view = {};\n\t\t}\n\n\t\tif (!start) {\n\t\t\tstart = me._start = {};\n\t\t}\n\n\t\tinterpolate(start, view, model, ease);\n\n\t\treturn me;\n\t},\n\n\ttooltipPosition: function() {\n\t\treturn {\n\t\t\tx: this._model.x,\n\t\t\ty: this._model.y\n\t\t};\n\t},\n\n\thasValue: function() {\n\t\treturn helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);\n\t}\n});\n\nElement.extend = helpers.inherits;\n\nmodule.exports = Element;\n","/* global window: false */\n/* global document: false */\n'use strict';\n\nvar color = require('chartjs-color');\nvar defaults = require('./core.defaults');\nvar helpers = require('../helpers/index');\n\nmodule.exports = function(Chart) {\n\n\t// -- Basic js utility methods\n\n\thelpers.configMerge = function(/* objects ... */) {\n\t\treturn helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {\n\t\t\tmerger: function(key, target, source, options) {\n\t\t\t\tvar tval = target[key] || {};\n\t\t\t\tvar sval = source[key];\n\n\t\t\t\tif (key === 'scales') {\n\t\t\t\t\t// scale config merging is complex. Add our own function here for that\n\t\t\t\t\ttarget[key] = helpers.scaleMerge(tval, sval);\n\t\t\t\t} else if (key === 'scale') {\n\t\t\t\t\t// used in polar area & radar charts since there is only one scale\n\t\t\t\t\ttarget[key] = helpers.merge(tval, [Chart.scaleService.getScaleDefaults(sval.type), sval]);\n\t\t\t\t} else {\n\t\t\t\t\thelpers._merger(key, target, source, options);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\thelpers.scaleMerge = function(/* objects ... */) {\n\t\treturn helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {\n\t\t\tmerger: function(key, target, source, options) {\n\t\t\t\tif (key === 'xAxes' || key === 'yAxes') {\n\t\t\t\t\tvar slen = source[key].length;\n\t\t\t\t\tvar i, type, scale;\n\n\t\t\t\t\tif (!target[key]) {\n\t\t\t\t\t\ttarget[key] = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (i = 0; i < slen; ++i) {\n\t\t\t\t\t\tscale = source[key][i];\n\t\t\t\t\t\ttype = helpers.valueOrDefault(scale.type, key === 'xAxes' ? 'category' : 'linear');\n\n\t\t\t\t\t\tif (i >= target[key].length) {\n\t\t\t\t\t\t\ttarget[key].push({});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!target[key][i].type || (scale.type && scale.type !== target[key][i].type)) {\n\t\t\t\t\t\t\t// new/untyped scale or type changed: let's apply the new defaults\n\t\t\t\t\t\t\t// then merge source scale to correctly overwrite the defaults.\n\t\t\t\t\t\t\thelpers.merge(target[key][i], [Chart.scaleService.getScaleDefaults(type), scale]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// scales type are the same\n\t\t\t\t\t\t\thelpers.merge(target[key][i], scale);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thelpers._merger(key, target, source, options);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\thelpers.where = function(collection, filterCallback) {\n\t\tif (helpers.isArray(collection) && Array.prototype.filter) {\n\t\t\treturn collection.filter(filterCallback);\n\t\t}\n\t\tvar filtered = [];\n\n\t\thelpers.each(collection, function(item) {\n\t\t\tif (filterCallback(item)) {\n\t\t\t\tfiltered.push(item);\n\t\t\t}\n\t\t});\n\n\t\treturn filtered;\n\t};\n\thelpers.findIndex = Array.prototype.findIndex ?\n\t\tfunction(array, callback, scope) {\n\t\t\treturn array.findIndex(callback, scope);\n\t\t} :\n\t\tfunction(array, callback, scope) {\n\t\t\tscope = scope === undefined ? array : scope;\n\t\t\tfor (var i = 0, ilen = array.length; i < ilen; ++i) {\n\t\t\t\tif (callback.call(scope, array[i], i, array)) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t};\n\thelpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {\n\t\t// Default to start of the array\n\t\tif (helpers.isNullOrUndef(startIndex)) {\n\t\t\tstartIndex = -1;\n\t\t}\n\t\tfor (var i = startIndex + 1; i < arrayToSearch.length; i++) {\n\t\t\tvar currentItem = arrayToSearch[i];\n\t\t\tif (filterCallback(currentItem)) {\n\t\t\t\treturn currentItem;\n\t\t\t}\n\t\t}\n\t};\n\thelpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {\n\t\t// Default to end of the array\n\t\tif (helpers.isNullOrUndef(startIndex)) {\n\t\t\tstartIndex = arrayToSearch.length;\n\t\t}\n\t\tfor (var i = startIndex - 1; i >= 0; i--) {\n\t\t\tvar currentItem = arrayToSearch[i];\n\t\t\tif (filterCallback(currentItem)) {\n\t\t\t\treturn currentItem;\n\t\t\t}\n\t\t}\n\t};\n\n\t// -- Math methods\n\thelpers.isNumber = function(n) {\n\t\treturn !isNaN(parseFloat(n)) && isFinite(n);\n\t};\n\thelpers.almostEquals = function(x, y, epsilon) {\n\t\treturn Math.abs(x - y) < epsilon;\n\t};\n\thelpers.almostWhole = function(x, epsilon) {\n\t\tvar rounded = Math.round(x);\n\t\treturn (((rounded - epsilon) < x) && ((rounded + epsilon) > x));\n\t};\n\thelpers.max = function(array) {\n\t\treturn array.reduce(function(max, value) {\n\t\t\tif (!isNaN(value)) {\n\t\t\t\treturn Math.max(max, value);\n\t\t\t}\n\t\t\treturn max;\n\t\t}, Number.NEGATIVE_INFINITY);\n\t};\n\thelpers.min = function(array) {\n\t\treturn array.reduce(function(min, value) {\n\t\t\tif (!isNaN(value)) {\n\t\t\t\treturn Math.min(min, value);\n\t\t\t}\n\t\t\treturn min;\n\t\t}, Number.POSITIVE_INFINITY);\n\t};\n\thelpers.sign = Math.sign ?\n\t\tfunction(x) {\n\t\t\treturn Math.sign(x);\n\t\t} :\n\t\tfunction(x) {\n\t\t\tx = +x; // convert to a number\n\t\t\tif (x === 0 || isNaN(x)) {\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\treturn x > 0 ? 1 : -1;\n\t\t};\n\thelpers.log10 = Math.log10 ?\n\t\tfunction(x) {\n\t\t\treturn Math.log10(x);\n\t\t} :\n\t\tfunction(x) {\n\t\t\tvar exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.\n\t\t\t// Check for whole powers of 10,\n\t\t\t// which due to floating point rounding error should be corrected.\n\t\t\tvar powerOf10 = Math.round(exponent);\n\t\t\tvar isPowerOf10 = x === Math.pow(10, powerOf10);\n\n\t\t\treturn isPowerOf10 ? powerOf10 : exponent;\n\t\t};\n\thelpers.toRadians = function(degrees) {\n\t\treturn degrees * (Math.PI / 180);\n\t};\n\thelpers.toDegrees = function(radians) {\n\t\treturn radians * (180 / Math.PI);\n\t};\n\t// Gets the angle from vertical upright to the point about a centre.\n\thelpers.getAngleFromPoint = function(centrePoint, anglePoint) {\n\t\tvar distanceFromXCenter = anglePoint.x - centrePoint.x;\n\t\tvar distanceFromYCenter = anglePoint.y - centrePoint.y;\n\t\tvar radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n\n\t\tvar angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\n\t\tif (angle < (-0.5 * Math.PI)) {\n\t\t\tangle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n\t\t}\n\n\t\treturn {\n\t\t\tangle: angle,\n\t\t\tdistance: radialDistanceFromCenter\n\t\t};\n\t};\n\thelpers.distanceBetweenPoints = function(pt1, pt2) {\n\t\treturn Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n\t};\n\thelpers.aliasPixel = function(pixelWidth) {\n\t\treturn (pixelWidth % 2 === 0) ? 0 : 0.5;\n\t};\n\thelpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {\n\t\t// Props to Rob Spencer at scaled innovation for his post on splining between points\n\t\t// http://scaledinnovation.com/analytics/splines/aboutSplines.html\n\n\t\t// This function must also respect \"skipped\" points\n\n\t\tvar previous = firstPoint.skip ? middlePoint : firstPoint;\n\t\tvar current = middlePoint;\n\t\tvar next = afterPoint.skip ? middlePoint : afterPoint;\n\n\t\tvar d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));\n\t\tvar d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));\n\n\t\tvar s01 = d01 / (d01 + d12);\n\t\tvar s12 = d12 / (d01 + d12);\n\n\t\t// If all points are the same, s01 & s02 will be inf\n\t\ts01 = isNaN(s01) ? 0 : s01;\n\t\ts12 = isNaN(s12) ? 0 : s12;\n\n\t\tvar fa = t * s01; // scaling factor for triangle Ta\n\t\tvar fb = t * s12;\n\n\t\treturn {\n\t\t\tprevious: {\n\t\t\t\tx: current.x - fa * (next.x - previous.x),\n\t\t\t\ty: current.y - fa * (next.y - previous.y)\n\t\t\t},\n\t\t\tnext: {\n\t\t\t\tx: current.x + fb * (next.x - previous.x),\n\t\t\t\ty: current.y + fb * (next.y - previous.y)\n\t\t\t}\n\t\t};\n\t};\n\thelpers.EPSILON = Number.EPSILON || 1e-14;\n\thelpers.splineCurveMonotone = function(points) {\n\t\t// This function calculates Bzier control points in a similar way than |splineCurve|,\n\t\t// but preserves monotonicity of the provided data and ensures no local extremums are added\n\t\t// between the dataset discrete points due to the interpolation.\n\t\t// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n\n\t\tvar pointsWithTangents = (points || []).map(function(point) {\n\t\t\treturn {\n\t\t\t\tmodel: point._model,\n\t\t\t\tdeltaK: 0,\n\t\t\t\tmK: 0\n\t\t\t};\n\t\t});\n\n\t\t// Calculate slopes (deltaK) and initialize tangents (mK)\n\t\tvar pointsLen = pointsWithTangents.length;\n\t\tvar i, pointBefore, pointCurrent, pointAfter;\n\t\tfor (i = 0; i < pointsLen; ++i) {\n\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\tif (pointCurrent.model.skip) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n\t\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\t\t\tif (pointAfter && !pointAfter.model.skip) {\n\t\t\t\tvar slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);\n\n\t\t\t\t// In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n\t\t\t\tpointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;\n\t\t\t}\n\n\t\t\tif (!pointBefore || pointBefore.model.skip) {\n\t\t\t\tpointCurrent.mK = pointCurrent.deltaK;\n\t\t\t} else if (!pointAfter || pointAfter.model.skip) {\n\t\t\t\tpointCurrent.mK = pointBefore.deltaK;\n\t\t\t} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {\n\t\t\t\tpointCurrent.mK = 0;\n\t\t\t} else {\n\t\t\t\tpointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;\n\t\t\t}\n\t\t}\n\n\t\t// Adjust tangents to ensure monotonic properties\n\t\tvar alphaK, betaK, tauK, squaredMagnitude;\n\t\tfor (i = 0; i < pointsLen - 1; ++i) {\n\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\tpointAfter = pointsWithTangents[i + 1];\n\t\t\tif (pointCurrent.model.skip || pointAfter.model.skip) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {\n\t\t\t\tpointCurrent.mK = pointAfter.mK = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\talphaK = pointCurrent.mK / pointCurrent.deltaK;\n\t\t\tbetaK = pointAfter.mK / pointCurrent.deltaK;\n\t\t\tsquaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n\t\t\tif (squaredMagnitude <= 9) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttauK = 3 / Math.sqrt(squaredMagnitude);\n\t\t\tpointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;\n\t\t\tpointAfter.mK = betaK * tauK * pointCurrent.deltaK;\n\t\t}\n\n\t\t// Compute control points\n\t\tvar deltaX;\n\t\tfor (i = 0; i < pointsLen; ++i) {\n\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\tif (pointCurrent.model.skip) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n\t\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\t\t\tif (pointBefore && !pointBefore.model.skip) {\n\t\t\t\tdeltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;\n\t\t\t\tpointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;\n\t\t\t\tpointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;\n\t\t\t}\n\t\t\tif (pointAfter && !pointAfter.model.skip) {\n\t\t\t\tdeltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;\n\t\t\t\tpointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;\n\t\t\t\tpointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;\n\t\t\t}\n\t\t}\n\t};\n\thelpers.nextItem = function(collection, index, loop) {\n\t\tif (loop) {\n\t\t\treturn index >= collection.length - 1 ? collection[0] : collection[index + 1];\n\t\t}\n\t\treturn index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];\n\t};\n\thelpers.previousItem = function(collection, index, loop) {\n\t\tif (loop) {\n\t\t\treturn index <= 0 ? collection[collection.length - 1] : collection[index - 1];\n\t\t}\n\t\treturn index <= 0 ? collection[0] : collection[index - 1];\n\t};\n\t// Implementation of the nice number algorithm used in determining where axis labels will go\n\thelpers.niceNum = function(range, round) {\n\t\tvar exponent = Math.floor(helpers.log10(range));\n\t\tvar fraction = range / Math.pow(10, exponent);\n\t\tvar niceFraction;\n\n\t\tif (round) {\n\t\t\tif (fraction < 1.5) {\n\t\t\t\tniceFraction = 1;\n\t\t\t} else if (fraction < 3) {\n\t\t\t\tniceFraction = 2;\n\t\t\t} else if (fraction < 7) {\n\t\t\t\tniceFraction = 5;\n\t\t\t} else {\n\t\t\t\tniceFraction = 10;\n\t\t\t}\n\t\t} else if (fraction <= 1.0) {\n\t\t\tniceFraction = 1;\n\t\t} else if (fraction <= 2) {\n\t\t\tniceFraction = 2;\n\t\t} else if (fraction <= 5) {\n\t\t\tniceFraction = 5;\n\t\t} else {\n\t\t\tniceFraction = 10;\n\t\t}\n\n\t\treturn niceFraction * Math.pow(10, exponent);\n\t};\n\t// Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\n\thelpers.requestAnimFrame = (function() {\n\t\tif (typeof window === 'undefined') {\n\t\t\treturn function(callback) {\n\t\t\t\tcallback();\n\t\t\t};\n\t\t}\n\t\treturn window.requestAnimationFrame ||\n\t\t\twindow.webkitRequestAnimationFrame ||\n\t\t\twindow.mozRequestAnimationFrame ||\n\t\t\twindow.oRequestAnimationFrame ||\n\t\t\twindow.msRequestAnimationFrame ||\n\t\t\tfunction(callback) {\n\t\t\t\treturn window.setTimeout(callback, 1000 / 60);\n\t\t\t};\n\t}());\n\t// -- DOM methods\n\thelpers.getRelativePosition = function(evt, chart) {\n\t\tvar mouseX, mouseY;\n\t\tvar e = evt.originalEvent || evt;\n\t\tvar canvas = evt.currentTarget || evt.srcElement;\n\t\tvar boundingRect = canvas.getBoundingClientRect();\n\n\t\tvar touches = e.touches;\n\t\tif (touches && touches.length > 0) {\n\t\t\tmouseX = touches[0].clientX;\n\t\t\tmouseY = touches[0].clientY;\n\n\t\t} else {\n\t\t\tmouseX = e.clientX;\n\t\t\tmouseY = e.clientY;\n\t\t}\n\n\t\t// Scale mouse coordinates into canvas coordinates\n\t\t// by following the pattern laid out by 'jerryj' in the comments of\n\t\t// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/\n\t\tvar paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));\n\t\tvar paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));\n\t\tvar paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));\n\t\tvar paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));\n\t\tvar width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;\n\t\tvar height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;\n\n\t\t// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However\n\t\t// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here\n\t\tmouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);\n\t\tmouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);\n\n\t\treturn {\n\t\t\tx: mouseX,\n\t\t\ty: mouseY\n\t\t};\n\n\t};\n\n\t// Private helper function to convert max-width/max-height values that may be percentages into a number\n\tfunction parseMaxStyle(styleValue, node, parentProperty) {\n\t\tvar valueInPixels;\n\t\tif (typeof styleValue === 'string') {\n\t\t\tvalueInPixels = parseInt(styleValue, 10);\n\n\t\t\tif (styleValue.indexOf('%') !== -1) {\n\t\t\t\t// percentage * size in dimension\n\t\t\t\tvalueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n\t\t\t}\n\t\t} else {\n\t\t\tvalueInPixels = styleValue;\n\t\t}\n\n\t\treturn valueInPixels;\n\t}\n\n\t/**\n\t * Returns if the given value contains an effective constraint.\n\t * @private\n\t */\n\tfunction isConstrainedValue(value) {\n\t\treturn value !== undefined && value !== null && value !== 'none';\n\t}\n\n\t// Private helper to get a constraint dimension\n\t// @param domNode : the node to check the constraint on\n\t// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)\n\t// @param percentageProperty : property of parent to use when calculating width as a percentage\n\t// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser\n\tfunction getConstraintDimension(domNode, maxStyle, percentageProperty) {\n\t\tvar view = document.defaultView;\n\t\tvar parentNode = domNode.parentNode;\n\t\tvar constrainedNode = view.getComputedStyle(domNode)[maxStyle];\n\t\tvar constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];\n\t\tvar hasCNode = isConstrainedValue(constrainedNode);\n\t\tvar hasCContainer = isConstrainedValue(constrainedContainer);\n\t\tvar infinity = Number.POSITIVE_INFINITY;\n\n\t\tif (hasCNode || hasCContainer) {\n\t\t\treturn Math.min(\n\t\t\t\thasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,\n\t\t\t\thasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);\n\t\t}\n\n\t\treturn 'none';\n\t}\n\t// returns Number or undefined if no constraint\n\thelpers.getConstraintWidth = function(domNode) {\n\t\treturn getConstraintDimension(domNode, 'max-width', 'clientWidth');\n\t};\n\t// returns Number or undefined if no constraint\n\thelpers.getConstraintHeight = function(domNode) {\n\t\treturn getConstraintDimension(domNode, 'max-height', 'clientHeight');\n\t};\n\thelpers.getMaximumWidth = function(domNode) {\n\t\tvar container = domNode.parentNode;\n\t\tif (!container) {\n\t\t\treturn domNode.clientWidth;\n\t\t}\n\n\t\tvar paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);\n\t\tvar paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);\n\t\tvar w = container.clientWidth - paddingLeft - paddingRight;\n\t\tvar cw = helpers.getConstraintWidth(domNode);\n\t\treturn isNaN(cw) ? w : Math.min(w, cw);\n\t};\n\thelpers.getMaximumHeight = function(domNode) {\n\t\tvar container = domNode.parentNode;\n\t\tif (!container) {\n\t\t\treturn domNode.clientHeight;\n\t\t}\n\n\t\tvar paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);\n\t\tvar paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);\n\t\tvar h = container.clientHeight - paddingTop - paddingBottom;\n\t\tvar ch = helpers.getConstraintHeight(domNode);\n\t\treturn isNaN(ch) ? h : Math.min(h, ch);\n\t};\n\thelpers.getStyle = function(el, property) {\n\t\treturn el.currentStyle ?\n\t\t\tel.currentStyle[property] :\n\t\t\tdocument.defaultView.getComputedStyle(el, null).getPropertyValue(property);\n\t};\n\thelpers.retinaScale = function(chart, forceRatio) {\n\t\tvar pixelRatio = chart.currentDevicePixelRatio = forceRatio || window.devicePixelRatio || 1;\n\t\tif (pixelRatio === 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar canvas = chart.canvas;\n\t\tvar height = chart.height;\n\t\tvar width = chart.width;\n\n\t\tcanvas.height = height * pixelRatio;\n\t\tcanvas.width = width * pixelRatio;\n\t\tchart.ctx.scale(pixelRatio, pixelRatio);\n\n\t\t// If no style has been set on the canvas, the render size is used as display size,\n\t\t// making the chart visually bigger, so let's enforce it to the \"correct\" values.\n\t\t// See https://github.com/chartjs/Chart.js/issues/3575\n\t\tif (!canvas.style.height && !canvas.style.width) {\n\t\t\tcanvas.style.height = height + 'px';\n\t\t\tcanvas.style.width = width + 'px';\n\t\t}\n\t};\n\t// -- Canvas methods\n\thelpers.fontString = function(pixelSize, fontStyle, fontFamily) {\n\t\treturn fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n\t};\n\thelpers.longestText = function(ctx, font, arrayOfThings, cache) {\n\t\tcache = cache || {};\n\t\tvar data = cache.data = cache.data || {};\n\t\tvar gc = cache.garbageCollect = cache.garbageCollect || [];\n\n\t\tif (cache.font !== font) {\n\t\t\tdata = cache.data = {};\n\t\t\tgc = cache.garbageCollect = [];\n\t\t\tcache.font = font;\n\t\t}\n\n\t\tctx.font = font;\n\t\tvar longest = 0;\n\t\thelpers.each(arrayOfThings, function(thing) {\n\t\t\t// Undefined strings and arrays should not be measured\n\t\t\tif (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {\n\t\t\t\tlongest = helpers.measureText(ctx, data, gc, longest, thing);\n\t\t\t} else if (helpers.isArray(thing)) {\n\t\t\t\t// if it is an array lets measure each element\n\t\t\t\t// to do maybe simplify this function a bit so we can do this more recursively?\n\t\t\t\thelpers.each(thing, function(nestedThing) {\n\t\t\t\t\t// Undefined strings and arrays should not be measured\n\t\t\t\t\tif (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {\n\t\t\t\t\t\tlongest = helpers.measureText(ctx, data, gc, longest, nestedThing);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tvar gcLen = gc.length / 2;\n\t\tif (gcLen > arrayOfThings.length) {\n\t\t\tfor (var i = 0; i < gcLen; i++) {\n\t\t\t\tdelete data[gc[i]];\n\t\t\t}\n\t\t\tgc.splice(0, gcLen);\n\t\t}\n\t\treturn longest;\n\t};\n\thelpers.measureText = function(ctx, data, gc, longest, string) {\n\t\tvar textWidth = data[string];\n\t\tif (!textWidth) {\n\t\t\ttextWidth = data[string] = ctx.measureText(string).width;\n\t\t\tgc.push(string);\n\t\t}\n\t\tif (textWidth > longest) {\n\t\t\tlongest = textWidth;\n\t\t}\n\t\treturn longest;\n\t};\n\thelpers.numberOfLabelLines = function(arrayOfThings) {\n\t\tvar numberOfLines = 1;\n\t\thelpers.each(arrayOfThings, function(thing) {\n\t\t\tif (helpers.isArray(thing)) {\n\t\t\t\tif (thing.length > numberOfLines) {\n\t\t\t\t\tnumberOfLines = thing.length;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn numberOfLines;\n\t};\n\n\thelpers.color = !color ?\n\t\tfunction(value) {\n\t\t\tconsole.error('Color.js not found!');\n\t\t\treturn value;\n\t\t} :\n\t\tfunction(value) {\n\t\t\t/* global CanvasGradient */\n\t\t\tif (value instanceof CanvasGradient) {\n\t\t\t\tvalue = defaults.global.defaultColor;\n\t\t\t}\n\n\t\t\treturn color(value);\n\t\t};\n\n\thelpers.getHoverColor = function(colorValue) {\n\t\t/* global CanvasPattern */\n\t\treturn (colorValue instanceof CanvasPattern) ?\n\t\t\tcolorValue :\n\t\t\thelpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();\n\t};\n};\n","'use strict';\n\nvar helpers = require('../helpers/index');\n\n/**\n * Helper function to get relative position for an event\n * @param {Event|IEvent} event - The event to get the position for\n * @param {Chart} chart - The chart\n * @returns {Point} the event position\n */\nfunction getRelativePosition(e, chart) {\n\tif (e.native) {\n\t\treturn {\n\t\t\tx: e.x,\n\t\t\ty: e.y\n\t\t};\n\t}\n\n\treturn helpers.getRelativePosition(e, chart);\n}\n\n/**\n * Helper function to traverse all of the visible elements in the chart\n * @param chart {chart} the chart\n * @param handler {Function} the callback to execute for each visible item\n */\nfunction parseVisibleItems(chart, handler) {\n\tvar datasets = chart.data.datasets;\n\tvar meta, i, j, ilen, jlen;\n\n\tfor (i = 0, ilen = datasets.length; i < ilen; ++i) {\n\t\tif (!chart.isDatasetVisible(i)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tmeta = chart.getDatasetMeta(i);\n\t\tfor (j = 0, jlen = meta.data.length; j < jlen; ++j) {\n\t\t\tvar element = meta.data[j];\n\t\t\tif (!element._view.skip) {\n\t\t\t\thandler(element);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Helper function to get the items that intersect the event position\n * @param items {ChartElement[]} elements to filter\n * @param position {Point} the point to be nearest to\n * @return {ChartElement[]} the nearest items\n */\nfunction getIntersectItems(chart, position) {\n\tvar elements = [];\n\n\tparseVisibleItems(chart, function(element) {\n\t\tif (element.inRange(position.x, position.y)) {\n\t\t\telements.push(element);\n\t\t}\n\t});\n\n\treturn elements;\n}\n\n/**\n * Helper function to get the items nearest to the event position considering all visible items in teh chart\n * @param chart {Chart} the chart to look at elements from\n * @param position {Point} the point to be nearest to\n * @param intersect {Boolean} if true, only consider items that intersect the position\n * @param distanceMetric {Function} function to provide the distance between points\n * @return {ChartElement[]} the nearest items\n */\nfunction getNearestItems(chart, position, intersect, distanceMetric) {\n\tvar minDistance = Number.POSITIVE_INFINITY;\n\tvar nearestItems = [];\n\n\tparseVisibleItems(chart, function(element) {\n\t\tif (intersect && !element.inRange(position.x, position.y)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar center = element.getCenterPoint();\n\t\tvar distance = distanceMetric(position, center);\n\n\t\tif (distance < minDistance) {\n\t\t\tnearestItems = [element];\n\t\t\tminDistance = distance;\n\t\t} else if (distance === minDistance) {\n\t\t\t// Can have multiple items at the same distance in which case we sort by size\n\t\t\tnearestItems.push(element);\n\t\t}\n\t});\n\n\treturn nearestItems;\n}\n\n/**\n * Get a distance metric function for two points based on the\n * axis mode setting\n * @param {String} axis the axis mode. x|y|xy\n */\nfunction getDistanceMetricForAxis(axis) {\n\tvar useX = axis.indexOf('x') !== -1;\n\tvar useY = axis.indexOf('y') !== -1;\n\n\treturn function(pt1, pt2) {\n\t\tvar deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n\t\tvar deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n\t\treturn Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n\t};\n}\n\nfunction indexMode(chart, e, options) {\n\tvar position = getRelativePosition(e, chart);\n\t// Default axis for index mode is 'x' to match old behaviour\n\toptions.axis = options.axis || 'x';\n\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\n\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n\tvar elements = [];\n\n\tif (!items.length) {\n\t\treturn [];\n\t}\n\n\tchart.data.datasets.forEach(function(dataset, datasetIndex) {\n\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\tvar element = meta.data[items[0]._index];\n\n\t\t\t// don't count items that are skipped (null data)\n\t\t\tif (element && !element._view.skip) {\n\t\t\t\telements.push(element);\n\t\t\t}\n\t\t}\n\t});\n\n\treturn elements;\n}\n\n/**\n * @interface IInteractionOptions\n */\n/**\n * If true, only consider items that intersect the point\n * @name IInterfaceOptions#boolean\n * @type Boolean\n */\n\n/**\n * Contains interaction related functions\n * @namespace Chart.Interaction\n */\nmodule.exports = {\n\t// Helper function for different modes\n\tmodes: {\n\t\tsingle: function(chart, e) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\tvar elements = [];\n\n\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\telements.push(element);\n\t\t\t\t\treturn elements;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn elements.slice(0, 1);\n\t\t},\n\n\t\t/**\n\t\t * @function Chart.Interaction.modes.label\n\t\t * @deprecated since version 2.4.0\n\t\t * @todo remove at version 3\n\t\t * @private\n\t\t */\n\t\tlabel: indexMode,\n\n\t\t/**\n\t\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n\t\t * @function Chart.Interaction.modes.index\n\t\t * @since v2.4.0\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use during interaction\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tindex: indexMode,\n\n\t\t/**\n\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\n\t\t * @function Chart.Interaction.modes.dataset\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use during interaction\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tdataset: function(chart, e, options) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\toptions.axis = options.axis || 'xy';\n\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\n\t\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n\n\t\t\tif (items.length > 0) {\n\t\t\t\titems = chart.getDatasetMeta(items[0]._datasetIndex).data;\n\t\t\t}\n\n\t\t\treturn items;\n\t\t},\n\n\t\t/**\n\t\t * @function Chart.Interaction.modes.x-axis\n\t\t * @deprecated since version 2.4.0. Use index mode and intersect == true\n\t\t * @todo remove at version 3\n\t\t * @private\n\t\t */\n\t\t'x-axis': function(chart, e) {\n\t\t\treturn indexMode(chart, e, {intersect: false});\n\t\t},\n\n\t\t/**\n\t\t * Point mode returns all elements that hit test based on the event position\n\t\t * of the event\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tpoint: function(chart, e) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\treturn getIntersectItems(chart, position);\n\t\t},\n\n\t\t/**\n\t\t * nearest mode returns the element closest to the point\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tnearest: function(chart, e, options) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\toptions.axis = options.axis || 'xy';\n\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\n\t\t\tvar nearestItems = getNearestItems(chart, position, options.intersect, distanceMetric);\n\n\t\t\t// We have multiple items at the same distance from the event. Now sort by smallest\n\t\t\tif (nearestItems.length > 1) {\n\t\t\t\tnearestItems.sort(function(a, b) {\n\t\t\t\t\tvar sizeA = a.getArea();\n\t\t\t\t\tvar sizeB = b.getArea();\n\t\t\t\t\tvar ret = sizeA - sizeB;\n\n\t\t\t\t\tif (ret === 0) {\n\t\t\t\t\t\t// if equal sort by dataset index\n\t\t\t\t\t\tret = a._datasetIndex - b._datasetIndex;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn ret;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Return only 1 item\n\t\t\treturn nearestItems.slice(0, 1);\n\t\t},\n\n\t\t/**\n\t\t * x mode returns the elements that hit-test at the current x coordinate\n\t\t * @function Chart.Interaction.modes.x\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tx: function(chart, e, options) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\tvar items = [];\n\t\t\tvar intersectsItem = false;\n\n\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\tif (element.inXRange(position.x)) {\n\t\t\t\t\titems.push(element);\n\t\t\t\t}\n\n\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\tintersectsItem = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// If we want to trigger on an intersect and we don't have any items\n\t\t\t// that intersect the position, return nothing\n\t\t\tif (options.intersect && !intersectsItem) {\n\t\t\t\titems = [];\n\t\t\t}\n\t\t\treturn items;\n\t\t},\n\n\t\t/**\n\t\t * y mode returns the elements that hit-test at the current y coordinate\n\t\t * @function Chart.Interaction.modes.y\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\ty: function(chart, e, options) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\tvar items = [];\n\t\t\tvar intersectsItem = false;\n\n\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\tif (element.inYRange(position.y)) {\n\t\t\t\t\titems.push(element);\n\t\t\t\t}\n\n\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\tintersectsItem = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// If we want to trigger on an intersect and we don't have any items\n\t\t\t// that intersect the position, return nothing\n\t\t\tif (options.intersect && !intersectsItem) {\n\t\t\t\titems = [];\n\t\t\t}\n\t\t\treturn items;\n\t\t}\n\t}\n};\n","'use strict';\n\nvar defaults = require('./core.defaults');\n\ndefaults._set('global', {\n\tresponsive: true,\n\tresponsiveAnimationDuration: 0,\n\tmaintainAspectRatio: true,\n\tevents: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],\n\thover: {\n\t\tonHover: null,\n\t\tmode: 'nearest',\n\t\tintersect: true,\n\t\tanimationDuration: 400\n\t},\n\tonClick: null,\n\tdefaultColor: 'rgba(0,0,0,0.1)',\n\tdefaultFontColor: '#666',\n\tdefaultFontFamily: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n\tdefaultFontSize: 12,\n\tdefaultFontStyle: 'normal',\n\tshowLines: true,\n\n\t// Element defaults defined in element extensions\n\telements: {},\n\n\t// Layout options such as padding\n\tlayout: {\n\t\tpadding: {\n\t\t\ttop: 0,\n\t\t\tright: 0,\n\t\t\tbottom: 0,\n\t\t\tleft: 0\n\t\t}\n\t}\n});\n\nmodule.exports = function() {\n\n\t// Occupy the global variable of Chart, and create a simple base class\n\tvar Chart = function(item, config) {\n\t\tthis.construct(item, config);\n\t\treturn this;\n\t};\n\n\tChart.Chart = Chart;\n\n\treturn Chart;\n};\n","'use strict';\n\nvar helpers = require('../helpers/index');\n\nfunction filterByPosition(array, position) {\n\treturn helpers.where(array, function(v) {\n\t\treturn v.position === position;\n\t});\n}\n\nfunction sortByWeight(array, reverse) {\n\tarray.forEach(function(v, i) {\n\t\tv._tmpIndex_ = i;\n\t\treturn v;\n\t});\n\tarray.sort(function(a, b) {\n\t\tvar v0 = reverse ? b : a;\n\t\tvar v1 = reverse ? a : b;\n\t\treturn v0.weight === v1.weight ?\n\t\t\tv0._tmpIndex_ - v1._tmpIndex_ :\n\t\t\tv0.weight - v1.weight;\n\t});\n\tarray.forEach(function(v) {\n\t\tdelete v._tmpIndex_;\n\t});\n}\n\n/**\n * @interface ILayoutItem\n * @prop {String} position - The position of the item in the chart layout. Possible values are\n * 'left', 'top', 'right', 'bottom', and 'chartArea'\n * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area\n * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down\n * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\n * @prop {Function} update - Takes two parameters: width and height. Returns size of item\n * @prop {Function} getPadding -  Returns an object with padding on the edges\n * @prop {Number} width - Width of item. Must be valid after update()\n * @prop {Number} height - Height of item. Must be valid after update()\n * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update\n * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update\n * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update\n * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\n */\n\n// The layout service is very self explanatory.  It's responsible for the layout within a chart.\n// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n// It is this service's responsibility of carrying out that layout.\nmodule.exports = {\n\tdefaults: {},\n\n\t/**\n\t * Register a box to a chart.\n\t * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\n\t * @param {Chart} chart - the chart to use\n\t * @param {ILayoutItem} item - the item to add to be layed out\n\t */\n\taddBox: function(chart, item) {\n\t\tif (!chart.boxes) {\n\t\t\tchart.boxes = [];\n\t\t}\n\n\t\t// initialize item with default values\n\t\titem.fullWidth = item.fullWidth || false;\n\t\titem.position = item.position || 'top';\n\t\titem.weight = item.weight || 0;\n\n\t\tchart.boxes.push(item);\n\t},\n\n\t/**\n\t * Remove a layoutItem from a chart\n\t * @param {Chart} chart - the chart to remove the box from\n\t * @param {Object} layoutItem - the item to remove from the layout\n\t */\n\tremoveBox: function(chart, layoutItem) {\n\t\tvar index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n\t\tif (index !== -1) {\n\t\t\tchart.boxes.splice(index, 1);\n\t\t}\n\t},\n\n\t/**\n\t * Sets (or updates) options on the given `item`.\n\t * @param {Chart} chart - the chart in which the item lives (or will be added to)\n\t * @param {Object} item - the item to configure with the given options\n\t * @param {Object} options - the new item options.\n\t */\n\tconfigure: function(chart, item, options) {\n\t\tvar props = ['fullWidth', 'position', 'weight'];\n\t\tvar ilen = props.length;\n\t\tvar i = 0;\n\t\tvar prop;\n\n\t\tfor (; i < ilen; ++i) {\n\t\t\tprop = props[i];\n\t\t\tif (options.hasOwnProperty(prop)) {\n\t\t\t\titem[prop] = options[prop];\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Fits boxes of the given chart into the given size by having each box measure itself\n\t * then running a fitting algorithm\n\t * @param {Chart} chart - the chart\n\t * @param {Number} width - the width to fit into\n\t * @param {Number} height - the height to fit into\n\t */\n\tupdate: function(chart, width, height) {\n\t\tif (!chart) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar layoutOptions = chart.options.layout || {};\n\t\tvar padding = helpers.options.toPadding(layoutOptions.padding);\n\t\tvar leftPadding = padding.left;\n\t\tvar rightPadding = padding.right;\n\t\tvar topPadding = padding.top;\n\t\tvar bottomPadding = padding.bottom;\n\n\t\tvar leftBoxes = filterByPosition(chart.boxes, 'left');\n\t\tvar rightBoxes = filterByPosition(chart.boxes, 'right');\n\t\tvar topBoxes = filterByPosition(chart.boxes, 'top');\n\t\tvar bottomBoxes = filterByPosition(chart.boxes, 'bottom');\n\t\tvar chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');\n\n\t\t// Sort boxes by weight. A higher weight is further away from the chart area\n\t\tsortByWeight(leftBoxes, true);\n\t\tsortByWeight(rightBoxes, false);\n\t\tsortByWeight(topBoxes, true);\n\t\tsortByWeight(bottomBoxes, false);\n\n\t\t// Essentially we now have any number of boxes on each of the 4 sides.\n\t\t// Our canvas looks like the following.\n\t\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n\t\t// B1 is the bottom axis\n\t\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n\t\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n\t\t// an error will be thrown.\n\t\t//\n\t\t// |----------------------------------------------------|\n\t\t// |                  T1 (Full Width)                   |\n\t\t// |----------------------------------------------------|\n\t\t// |    |    |                 T2                  |    |\n\t\t// |    |----|-------------------------------------|----|\n\t\t// |    |    | C1 |                           | C2 |    |\n\t\t// |    |    |----|                           |----|    |\n\t\t// |    |    |                                     |    |\n\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\n\t\t// |    |    |                                     |    |\n\t\t// |    |    |----|                           |----|    |\n\t\t// |    |    | C3 |                           | C4 |    |\n\t\t// |    |----|-------------------------------------|----|\n\t\t// |    |    |                 B1                  |    |\n\t\t// |----------------------------------------------------|\n\t\t// |                  B2 (Full Width)                   |\n\t\t// |----------------------------------------------------|\n\t\t//\n\t\t// What we do to find the best sizing, we do the following\n\t\t// 1. Determine the minimum size of the chart area.\n\t\t// 2. Split the remaining width equally between each vertical axis\n\t\t// 3. Split the remaining height equally between each horizontal axis\n\t\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size\n\t\t// 5. Adjust the sizes of each axis based on it's minimum reported size.\n\t\t// 6. Refit each axis\n\t\t// 7. Position each axis in the final location\n\t\t// 8. Tell the chart the final location of the chart area\n\t\t// 9. Tell any axes that overlay the chart area the positions of the chart area\n\n\t\t// Step 1\n\t\tvar chartWidth = width - leftPadding - rightPadding;\n\t\tvar chartHeight = height - topPadding - bottomPadding;\n\t\tvar chartAreaWidth = chartWidth / 2; // min 50%\n\t\tvar chartAreaHeight = chartHeight / 2; // min 50%\n\n\t\t// Step 2\n\t\tvar verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);\n\n\t\t// Step 3\n\t\tvar horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);\n\n\t\t// Step 4\n\t\tvar maxChartAreaWidth = chartWidth;\n\t\tvar maxChartAreaHeight = chartHeight;\n\t\tvar minBoxSizes = [];\n\n\t\tfunction getMinimumBoxSize(box) {\n\t\t\tvar minSize;\n\t\t\tvar isHorizontal = box.isHorizontal();\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tminSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\n\t\t\t\tmaxChartAreaHeight -= minSize.height;\n\t\t\t} else {\n\t\t\t\tminSize = box.update(verticalBoxWidth, maxChartAreaHeight);\n\t\t\t\tmaxChartAreaWidth -= minSize.width;\n\t\t\t}\n\n\t\t\tminBoxSizes.push({\n\t\t\t\thorizontal: isHorizontal,\n\t\t\t\tminSize: minSize,\n\t\t\t\tbox: box,\n\t\t\t});\n\t\t}\n\n\t\thelpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);\n\n\t\t// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\n\t\tvar maxHorizontalLeftPadding = 0;\n\t\tvar maxHorizontalRightPadding = 0;\n\t\tvar maxVerticalTopPadding = 0;\n\t\tvar maxVerticalBottomPadding = 0;\n\n\t\thelpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {\n\t\t\tif (horizontalBox.getPadding) {\n\t\t\t\tvar boxPadding = horizontalBox.getPadding();\n\t\t\t\tmaxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\n\t\t\t\tmaxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\n\t\t\t}\n\t\t});\n\n\t\thelpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {\n\t\t\tif (verticalBox.getPadding) {\n\t\t\t\tvar boxPadding = verticalBox.getPadding();\n\t\t\t\tmaxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\n\t\t\t\tmaxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\n\t\t\t}\n\t\t});\n\n\t\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\n\t\t// be if the axes are drawn at their minimum sizes.\n\t\t// Steps 5 & 6\n\t\tvar totalLeftBoxesWidth = leftPadding;\n\t\tvar totalRightBoxesWidth = rightPadding;\n\t\tvar totalTopBoxesHeight = topPadding;\n\t\tvar totalBottomBoxesHeight = bottomPadding;\n\n\t\t// Function to fit a box\n\t\tfunction fitBox(box) {\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {\n\t\t\t\treturn minBox.box === box;\n\t\t\t});\n\n\t\t\tif (minBoxSize) {\n\t\t\t\tif (box.isHorizontal()) {\n\t\t\t\t\tvar scaleMargin = {\n\t\t\t\t\t\tleft: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\n\t\t\t\t\t\tright: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\tbottom: 0\n\t\t\t\t\t};\n\n\t\t\t\t\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\n\t\t\t\t\t// on the margin. Sometimes they need to increase in size slightly\n\t\t\t\t\tbox.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\n\t\t\t\t} else {\n\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Update, and calculate the left and right margins for the horizontal boxes\n\t\thelpers.each(leftBoxes.concat(rightBoxes), fitBox);\n\n\t\thelpers.each(leftBoxes, function(box) {\n\t\t\ttotalLeftBoxesWidth += box.width;\n\t\t});\n\n\t\thelpers.each(rightBoxes, function(box) {\n\t\t\ttotalRightBoxesWidth += box.width;\n\t\t});\n\n\t\t// Set the Left and Right margins for the horizontal boxes\n\t\thelpers.each(topBoxes.concat(bottomBoxes), fitBox);\n\n\t\t// Figure out how much margin is on the top and bottom of the vertical boxes\n\t\thelpers.each(topBoxes, function(box) {\n\t\t\ttotalTopBoxesHeight += box.height;\n\t\t});\n\n\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\ttotalBottomBoxesHeight += box.height;\n\t\t});\n\n\t\tfunction finalFitVerticalBox(box) {\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {\n\t\t\t\treturn minSize.box === box;\n\t\t\t});\n\n\t\t\tvar scaleMargin = {\n\t\t\t\tleft: 0,\n\t\t\t\tright: 0,\n\t\t\t\ttop: totalTopBoxesHeight,\n\t\t\t\tbottom: totalBottomBoxesHeight\n\t\t\t};\n\n\t\t\tif (minBoxSize) {\n\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\n\t\t\t}\n\t\t}\n\n\t\t// Let the left layout know the final margin\n\t\thelpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);\n\n\t\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\n\t\ttotalLeftBoxesWidth = leftPadding;\n\t\ttotalRightBoxesWidth = rightPadding;\n\t\ttotalTopBoxesHeight = topPadding;\n\t\ttotalBottomBoxesHeight = bottomPadding;\n\n\t\thelpers.each(leftBoxes, function(box) {\n\t\t\ttotalLeftBoxesWidth += box.width;\n\t\t});\n\n\t\thelpers.each(rightBoxes, function(box) {\n\t\t\ttotalRightBoxesWidth += box.width;\n\t\t});\n\n\t\thelpers.each(topBoxes, function(box) {\n\t\t\ttotalTopBoxesHeight += box.height;\n\t\t});\n\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\ttotalBottomBoxesHeight += box.height;\n\t\t});\n\n\t\t// We may be adding some padding to account for rotated x axis labels\n\t\tvar leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\n\t\ttotalLeftBoxesWidth += leftPaddingAddition;\n\t\ttotalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\n\n\t\tvar topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\n\t\ttotalTopBoxesHeight += topPaddingAddition;\n\t\ttotalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);\n\n\t\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation\n\t\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\n\t\t// without calling `fit` again\n\t\tvar newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\n\t\tvar newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\n\n\t\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\n\t\t\thelpers.each(leftBoxes, function(box) {\n\t\t\t\tbox.height = newMaxChartAreaHeight;\n\t\t\t});\n\n\t\t\thelpers.each(rightBoxes, function(box) {\n\t\t\t\tbox.height = newMaxChartAreaHeight;\n\t\t\t});\n\n\t\t\thelpers.each(topBoxes, function(box) {\n\t\t\t\tif (!box.fullWidth) {\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\t\tif (!box.fullWidth) {\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tmaxChartAreaHeight = newMaxChartAreaHeight;\n\t\t\tmaxChartAreaWidth = newMaxChartAreaWidth;\n\t\t}\n\n\t\t// Step 7 - Position the boxes\n\t\tvar left = leftPadding + leftPaddingAddition;\n\t\tvar top = topPadding + topPaddingAddition;\n\n\t\tfunction placeBox(box) {\n\t\t\tif (box.isHorizontal()) {\n\t\t\t\tbox.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;\n\t\t\t\tbox.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\n\t\t\t\tbox.top = top;\n\t\t\t\tbox.bottom = top + box.height;\n\n\t\t\t\t// Move to next point\n\t\t\t\ttop = box.bottom;\n\n\t\t\t} else {\n\n\t\t\t\tbox.left = left;\n\t\t\t\tbox.right = left + box.width;\n\t\t\t\tbox.top = totalTopBoxesHeight;\n\t\t\t\tbox.bottom = totalTopBoxesHeight + maxChartAreaHeight;\n\n\t\t\t\t// Move to next point\n\t\t\t\tleft = box.right;\n\t\t\t}\n\t\t}\n\n\t\thelpers.each(leftBoxes.concat(topBoxes), placeBox);\n\n\t\t// Account for chart width and height\n\t\tleft += maxChartAreaWidth;\n\t\ttop += maxChartAreaHeight;\n\n\t\thelpers.each(rightBoxes, placeBox);\n\t\thelpers.each(bottomBoxes, placeBox);\n\n\t\t// Step 8\n\t\tchart.chartArea = {\n\t\t\tleft: totalLeftBoxesWidth,\n\t\t\ttop: totalTopBoxesHeight,\n\t\t\tright: totalLeftBoxesWidth + maxChartAreaWidth,\n\t\t\tbottom: totalTopBoxesHeight + maxChartAreaHeight\n\t\t};\n\n\t\t// Step 9\n\t\thelpers.each(chartAreaBoxes, function(box) {\n\t\t\tbox.left = chart.chartArea.left;\n\t\t\tbox.top = chart.chartArea.top;\n\t\t\tbox.right = chart.chartArea.right;\n\t\t\tbox.bottom = chart.chartArea.bottom;\n\n\t\t\tbox.update(maxChartAreaWidth, maxChartAreaHeight);\n\t\t});\n\t}\n};\n","'use strict';\n\nvar defaults = require('./core.defaults');\nvar helpers = require('../helpers/index');\n\ndefaults._set('global', {\n\tplugins: {}\n});\n\n/**\n * The plugin service singleton\n * @namespace Chart.plugins\n * @since 2.1.0\n */\nmodule.exports = {\n\t/**\n\t * Globally registered plugins.\n\t * @private\n\t */\n\t_plugins: [],\n\n\t/**\n\t * This identifier is used to invalidate the descriptors cache attached to each chart\n\t * when a global plugin is registered or unregistered. In this case, the cache ID is\n\t * incremented and descriptors are regenerated during following API calls.\n\t * @private\n\t */\n\t_cacheId: 0,\n\n\t/**\n\t * Registers the given plugin(s) if not already registered.\n\t * @param {Array|Object} plugins plugin instance(s).\n\t */\n\tregister: function(plugins) {\n\t\tvar p = this._plugins;\n\t\t([]).concat(plugins).forEach(function(plugin) {\n\t\t\tif (p.indexOf(plugin) === -1) {\n\t\t\t\tp.push(plugin);\n\t\t\t}\n\t\t});\n\n\t\tthis._cacheId++;\n\t},\n\n\t/**\n\t * Unregisters the given plugin(s) only if registered.\n\t * @param {Array|Object} plugins plugin instance(s).\n\t */\n\tunregister: function(plugins) {\n\t\tvar p = this._plugins;\n\t\t([]).concat(plugins).forEach(function(plugin) {\n\t\t\tvar idx = p.indexOf(plugin);\n\t\t\tif (idx !== -1) {\n\t\t\t\tp.splice(idx, 1);\n\t\t\t}\n\t\t});\n\n\t\tthis._cacheId++;\n\t},\n\n\t/**\n\t * Remove all registered plugins.\n\t * @since 2.1.5\n\t */\n\tclear: function() {\n\t\tthis._plugins = [];\n\t\tthis._cacheId++;\n\t},\n\n\t/**\n\t * Returns the number of registered plugins?\n\t * @returns {Number}\n\t * @since 2.1.5\n\t */\n\tcount: function() {\n\t\treturn this._plugins.length;\n\t},\n\n\t/**\n\t * Returns all registered plugin instances.\n\t * @returns {Array} array of plugin objects.\n\t * @since 2.1.5\n\t */\n\tgetAll: function() {\n\t\treturn this._plugins;\n\t},\n\n\t/**\n\t * Calls enabled plugins for `chart` on the specified hook and with the given args.\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t * returned value can be used, for instance, to interrupt the current action.\n\t * @param {Object} chart - The chart instance for which plugins should be called.\n\t * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t * @param {Array} [args] - Extra arguments to apply to the hook call.\n\t * @returns {Boolean} false if any of the plugins return false, else returns true.\n\t */\n\tnotify: function(chart, hook, args) {\n\t\tvar descriptors = this.descriptors(chart);\n\t\tvar ilen = descriptors.length;\n\t\tvar i, descriptor, plugin, params, method;\n\n\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\tdescriptor = descriptors[i];\n\t\t\tplugin = descriptor.plugin;\n\t\t\tmethod = plugin[hook];\n\t\t\tif (typeof method === 'function') {\n\t\t\t\tparams = [chart].concat(args || []);\n\t\t\t\tparams.push(descriptor.options);\n\t\t\t\tif (method.apply(plugin, params) === false) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/**\n\t * Returns descriptors of enabled plugins for the given chart.\n\t * @returns {Array} [{ plugin, options }]\n\t * @private\n\t */\n\tdescriptors: function(chart) {\n\t\tvar cache = chart.$plugins || (chart.$plugins = {});\n\t\tif (cache.id === this._cacheId) {\n\t\t\treturn cache.descriptors;\n\t\t}\n\n\t\tvar plugins = [];\n\t\tvar descriptors = [];\n\t\tvar config = (chart && chart.config) || {};\n\t\tvar options = (config.options && config.options.plugins) || {};\n\n\t\tthis._plugins.concat(config.plugins || []).forEach(function(plugin) {\n\t\t\tvar idx = plugins.indexOf(plugin);\n\t\t\tif (idx !== -1) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar id = plugin.id;\n\t\t\tvar opts = options[id];\n\t\t\tif (opts === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (opts === true) {\n\t\t\t\topts = helpers.clone(defaults.global.plugins[id]);\n\t\t\t}\n\n\t\t\tplugins.push(plugin);\n\t\t\tdescriptors.push({\n\t\t\t\tplugin: plugin,\n\t\t\t\toptions: opts || {}\n\t\t\t});\n\t\t});\n\n\t\tcache.descriptors = descriptors;\n\t\tcache.id = this._cacheId;\n\t\treturn descriptors;\n\t},\n\n\t/**\n\t * Invalidates cache for the given chart: descriptors hold a reference on plugin option,\n\t * but in some cases, this reference can be changed by the user when updating options.\n\t * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\n\t * @private\n\t */\n\t_invalidate: function(chart) {\n\t\tdelete chart.$plugins;\n\t}\n};\n\n/**\n * Plugin extension hooks.\n * @interface IPlugin\n * @since 2.1.0\n */\n/**\n * @method IPlugin#beforeInit\n * @desc Called before initializing `chart`.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#afterInit\n * @desc Called after `chart` has been initialized and before the first update.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeUpdate\n * @desc Called before updating `chart`. If any plugin returns `false`, the update\n * is cancelled (and thus subsequent render(s)) until another `update` is triggered.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart update.\n */\n/**\n * @method IPlugin#afterUpdate\n * @desc Called after `chart` has been updated and before rendering. Note that this\n * hook will not be called if the chart update has been previously cancelled.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeDatasetsUpdate\n * @desc Called before updating the `chart` datasets. If any plugin returns `false`,\n * the datasets update is cancelled until another `update` is triggered.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} false to cancel the datasets update.\n * @since version 2.1.5\n*/\n/**\n * @method IPlugin#afterDatasetsUpdate\n * @desc Called after the `chart` datasets have been updated. Note that this hook\n * will not be called if the datasets update has been previously cancelled.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n * @since version 2.1.5\n */\n/**\n * @method IPlugin#beforeDatasetUpdate\n * @desc Called before updating the `chart` dataset at the given `args.index`. If any plugin\n * returns `false`, the datasets update is cancelled until another `update` is triggered.\n * @param {Chart} chart - The chart instance.\n * @param {Object} args - The call arguments.\n * @param {Number} args.index - The dataset index.\n * @param {Object} args.meta - The dataset metadata.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart datasets drawing.\n */\n/**\n * @method IPlugin#afterDatasetUpdate\n * @desc Called after the `chart` datasets at the given `args.index` has been updated. Note\n * that this hook will not be called if the datasets update has been previously cancelled.\n * @param {Chart} chart - The chart instance.\n * @param {Object} args - The call arguments.\n * @param {Number} args.index - The dataset index.\n * @param {Object} args.meta - The dataset metadata.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeLayout\n * @desc Called before laying out `chart`. If any plugin returns `false`,\n * the layout update is cancelled until another `update` is triggered.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart layout.\n */\n/**\n * @method IPlugin#afterLayout\n * @desc Called after the `chart` has been layed out. Note that this hook will not\n * be called if the layout update has been previously cancelled.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeRender\n * @desc Called before rendering `chart`. If any plugin returns `false`,\n * the rendering is cancelled until another `render` is triggered.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart rendering.\n */\n/**\n * @method IPlugin#afterRender\n * @desc Called after the `chart` has been fully rendered (and animation completed). Note\n * that this hook will not be called if the rendering has been previously cancelled.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeDraw\n * @desc Called before drawing `chart` at every animation frame specified by the given\n * easing value. If any plugin returns `false`, the frame drawing is cancelled until\n * another `render` is triggered.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart drawing.\n */\n/**\n * @method IPlugin#afterDraw\n * @desc Called after the `chart` has been drawn for the specific easing value. Note\n * that this hook will not be called if the drawing has been previously cancelled.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeDatasetsDraw\n * @desc Called before drawing the `chart` datasets. If any plugin returns `false`,\n * the datasets drawing is cancelled until another `render` is triggered.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart datasets drawing.\n */\n/**\n * @method IPlugin#afterDatasetsDraw\n * @desc Called after the `chart` datasets have been drawn. Note that this hook\n * will not be called if the datasets drawing has been previously cancelled.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeDatasetDraw\n * @desc Called before drawing the `chart` dataset at the given `args.index` (datasets\n * are drawn in the reverse order). If any plugin returns `false`, the datasets drawing\n * is cancelled until another `render` is triggered.\n * @param {Chart} chart - The chart instance.\n * @param {Object} args - The call arguments.\n * @param {Number} args.index - The dataset index.\n * @param {Object} args.meta - The dataset metadata.\n * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart datasets drawing.\n */\n/**\n * @method IPlugin#afterDatasetDraw\n * @desc Called after the `chart` datasets at the given `args.index` have been drawn\n * (datasets are drawn in the reverse order). Note that this hook will not be called\n * if the datasets drawing has been previously cancelled.\n * @param {Chart} chart - The chart instance.\n * @param {Object} args - The call arguments.\n * @param {Number} args.index - The dataset index.\n * @param {Object} args.meta - The dataset metadata.\n * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeTooltipDraw\n * @desc Called before drawing the `tooltip`. If any plugin returns `false`,\n * the tooltip drawing is cancelled until another `render` is triggered.\n * @param {Chart} chart - The chart instance.\n * @param {Object} args - The call arguments.\n * @param {Object} args.tooltip - The tooltip.\n * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart tooltip drawing.\n */\n/**\n * @method IPlugin#afterTooltipDraw\n * @desc Called after drawing the `tooltip`. Note that this hook will not\n * be called if the tooltip drawing has been previously cancelled.\n * @param {Chart} chart - The chart instance.\n * @param {Object} args - The call arguments.\n * @param {Object} args.tooltip - The tooltip.\n * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeEvent\n * @desc Called before processing the specified `event`. If any plugin returns `false`,\n * the event will be discarded.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {IEvent} event - The event object.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#afterEvent\n * @desc Called after the `event` has been consumed. Note that this hook\n * will not be called if the `event` has been previously discarded.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {IEvent} event - The event object.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#resize\n * @desc Called after the chart as been resized.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Number} size - The new canvas display size (eq. canvas.style width & height).\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#destroy\n * @desc Called after the chart as been destroyed.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n */\n","'use strict';\n\nvar defaults = require('./core.defaults');\nvar Element = require('./core.element');\nvar helpers = require('../helpers/index');\nvar Ticks = require('./core.ticks');\n\ndefaults._set('scale', {\n\tdisplay: true,\n\tposition: 'left',\n\toffset: false,\n\n\t// grid line settings\n\tgridLines: {\n\t\tdisplay: true,\n\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\tlineWidth: 1,\n\t\tdrawBorder: true,\n\t\tdrawOnChartArea: true,\n\t\tdrawTicks: true,\n\t\ttickMarkLength: 10,\n\t\tzeroLineWidth: 1,\n\t\tzeroLineColor: 'rgba(0,0,0,0.25)',\n\t\tzeroLineBorderDash: [],\n\t\tzeroLineBorderDashOffset: 0.0,\n\t\toffsetGridLines: false,\n\t\tborderDash: [],\n\t\tborderDashOffset: 0.0\n\t},\n\n\t// scale label\n\tscaleLabel: {\n\t\t// display property\n\t\tdisplay: false,\n\n\t\t// actual label\n\t\tlabelString: '',\n\n\t\t// line height\n\t\tlineHeight: 1.2,\n\n\t\t// top/bottom padding\n\t\tpadding: {\n\t\t\ttop: 4,\n\t\t\tbottom: 4\n\t\t}\n\t},\n\n\t// label settings\n\tticks: {\n\t\tbeginAtZero: false,\n\t\tminRotation: 0,\n\t\tmaxRotation: 50,\n\t\tmirror: false,\n\t\tpadding: 0,\n\t\treverse: false,\n\t\tdisplay: true,\n\t\tautoSkip: true,\n\t\tautoSkipPadding: 0,\n\t\tlabelOffset: 0,\n\t\t// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n\t\tcallback: Ticks.formatters.values,\n\t\tminor: {},\n\t\tmajor: {}\n\t}\n});\n\nfunction labelsFromTicks(ticks) {\n\tvar labels = [];\n\tvar i, ilen;\n\n\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\tlabels.push(ticks[i].label);\n\t}\n\n\treturn labels;\n}\n\nfunction getLineValue(scale, index, offsetGridLines) {\n\tvar lineValue = scale.getPixelForTick(index);\n\n\tif (offsetGridLines) {\n\t\tif (index === 0) {\n\t\t\tlineValue -= (scale.getPixelForTick(1) - lineValue) / 2;\n\t\t} else {\n\t\t\tlineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;\n\t\t}\n\t}\n\treturn lineValue;\n}\n\nmodule.exports = function(Chart) {\n\n\tfunction computeTextSize(context, tick, font) {\n\t\treturn helpers.isArray(tick) ?\n\t\t\thelpers.longestText(context, font, tick) :\n\t\t\tcontext.measureText(tick).width;\n\t}\n\n\tfunction parseFontOptions(options) {\n\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\tvar globalDefaults = defaults.global;\n\t\tvar size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\n\t\tvar style = valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);\n\t\tvar family = valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);\n\n\t\treturn {\n\t\t\tsize: size,\n\t\t\tstyle: style,\n\t\t\tfamily: family,\n\t\t\tfont: helpers.fontString(size, style, family)\n\t\t};\n\t}\n\n\tfunction parseLineHeight(options) {\n\t\treturn helpers.options.toLineHeight(\n\t\t\thelpers.valueOrDefault(options.lineHeight, 1.2),\n\t\t\thelpers.valueOrDefault(options.fontSize, defaults.global.defaultFontSize));\n\t}\n\n\tChart.Scale = Element.extend({\n\t\t/**\n\t\t * Get the padding needed for the scale\n\t\t * @method getPadding\n\t\t * @private\n\t\t * @returns {Padding} the necessary padding\n\t\t */\n\t\tgetPadding: function() {\n\t\t\tvar me = this;\n\t\t\treturn {\n\t\t\t\tleft: me.paddingLeft || 0,\n\t\t\t\ttop: me.paddingTop || 0,\n\t\t\t\tright: me.paddingRight || 0,\n\t\t\t\tbottom: me.paddingBottom || 0\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Returns the scale tick objects ({label, major})\n\t\t * @since 2.7\n\t\t */\n\t\tgetTicks: function() {\n\t\t\treturn this._ticks;\n\t\t},\n\n\t\t// These methods are ordered by lifecyle. Utilities then follow.\n\t\t// Any function defined here is inherited by all scale types.\n\t\t// Any function can be extended by the scale type\n\n\t\tmergeTicksOptions: function() {\n\t\t\tvar ticks = this.options.ticks;\n\t\t\tif (ticks.minor === false) {\n\t\t\t\tticks.minor = {\n\t\t\t\t\tdisplay: false\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (ticks.major === false) {\n\t\t\t\tticks.major = {\n\t\t\t\t\tdisplay: false\n\t\t\t\t};\n\t\t\t}\n\t\t\tfor (var key in ticks) {\n\t\t\t\tif (key !== 'major' && key !== 'minor') {\n\t\t\t\t\tif (typeof ticks.minor[key] === 'undefined') {\n\t\t\t\t\t\tticks.minor[key] = ticks[key];\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof ticks.major[key] === 'undefined') {\n\t\t\t\t\t\tticks.major[key] = ticks[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tbeforeUpdate: function() {\n\t\t\thelpers.callback(this.options.beforeUpdate, [this]);\n\t\t},\n\t\tupdate: function(maxWidth, maxHeight, margins) {\n\t\t\tvar me = this;\n\t\t\tvar i, ilen, labels, label, ticks, tick;\n\n\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\tme.beforeUpdate();\n\n\t\t\t// Absorb the master measurements\n\t\t\tme.maxWidth = maxWidth;\n\t\t\tme.maxHeight = maxHeight;\n\t\t\tme.margins = helpers.extend({\n\t\t\t\tleft: 0,\n\t\t\t\tright: 0,\n\t\t\t\ttop: 0,\n\t\t\t\tbottom: 0\n\t\t\t}, margins);\n\t\t\tme.longestTextCache = me.longestTextCache || {};\n\n\t\t\t// Dimensions\n\t\t\tme.beforeSetDimensions();\n\t\t\tme.setDimensions();\n\t\t\tme.afterSetDimensions();\n\n\t\t\t// Data min/max\n\t\t\tme.beforeDataLimits();\n\t\t\tme.determineDataLimits();\n\t\t\tme.afterDataLimits();\n\n\t\t\t// Ticks - `this.ticks` is now DEPRECATED!\n\t\t\t// Internal ticks are now stored as objects in the PRIVATE `this._ticks` member\n\t\t\t// and must not be accessed directly from outside this class. `this.ticks` being\n\t\t\t// around for long time and not marked as private, we can't change its structure\n\t\t\t// without unexpected breaking changes. If you need to access the scale ticks,\n\t\t\t// use scale.getTicks() instead.\n\n\t\t\tme.beforeBuildTicks();\n\n\t\t\t// New implementations should return an array of objects but for BACKWARD COMPAT,\n\t\t\t// we still support no return (`this.ticks` internally set by calling this method).\n\t\t\tticks = me.buildTicks() || [];\n\n\t\t\tme.afterBuildTicks();\n\n\t\t\tme.beforeTickToLabelConversion();\n\n\t\t\t// New implementations should return the formatted tick labels but for BACKWARD\n\t\t\t// COMPAT, we still support no return (`this.ticks` internally changed by calling\n\t\t\t// this method and supposed to contain only string values).\n\t\t\tlabels = me.convertTicksToLabels(ticks) || me.ticks;\n\n\t\t\tme.afterTickToLabelConversion();\n\n\t\t\tme.ticks = labels;   // BACKWARD COMPATIBILITY\n\n\t\t\t// IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!\n\n\t\t\t// BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)\n\t\t\tfor (i = 0, ilen = labels.length; i < ilen; ++i) {\n\t\t\t\tlabel = labels[i];\n\t\t\t\ttick = ticks[i];\n\t\t\t\tif (!tick) {\n\t\t\t\t\tticks.push(tick = {\n\t\t\t\t\t\tlabel: label,\n\t\t\t\t\t\tmajor: false\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\ttick.label = label;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme._ticks = ticks;\n\n\t\t\t// Tick Rotation\n\t\t\tme.beforeCalculateTickRotation();\n\t\t\tme.calculateTickRotation();\n\t\t\tme.afterCalculateTickRotation();\n\t\t\t// Fit\n\t\t\tme.beforeFit();\n\t\t\tme.fit();\n\t\t\tme.afterFit();\n\t\t\t//\n\t\t\tme.afterUpdate();\n\n\t\t\treturn me.minSize;\n\n\t\t},\n\t\tafterUpdate: function() {\n\t\t\thelpers.callback(this.options.afterUpdate, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeSetDimensions: function() {\n\t\t\thelpers.callback(this.options.beforeSetDimensions, [this]);\n\t\t},\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.width = me.maxWidth;\n\t\t\t\tme.left = 0;\n\t\t\t\tme.right = me.width;\n\t\t\t} else {\n\t\t\t\tme.height = me.maxHeight;\n\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.top = 0;\n\t\t\t\tme.bottom = me.height;\n\t\t\t}\n\n\t\t\t// Reset padding\n\t\t\tme.paddingLeft = 0;\n\t\t\tme.paddingTop = 0;\n\t\t\tme.paddingRight = 0;\n\t\t\tme.paddingBottom = 0;\n\t\t},\n\t\tafterSetDimensions: function() {\n\t\t\thelpers.callback(this.options.afterSetDimensions, [this]);\n\t\t},\n\n\t\t// Data limits\n\t\tbeforeDataLimits: function() {\n\t\t\thelpers.callback(this.options.beforeDataLimits, [this]);\n\t\t},\n\t\tdetermineDataLimits: helpers.noop,\n\t\tafterDataLimits: function() {\n\t\t\thelpers.callback(this.options.afterDataLimits, [this]);\n\t\t},\n\n\t\t//\n\t\tbeforeBuildTicks: function() {\n\t\t\thelpers.callback(this.options.beforeBuildTicks, [this]);\n\t\t},\n\t\tbuildTicks: helpers.noop,\n\t\tafterBuildTicks: function() {\n\t\t\thelpers.callback(this.options.afterBuildTicks, [this]);\n\t\t},\n\n\t\tbeforeTickToLabelConversion: function() {\n\t\t\thelpers.callback(this.options.beforeTickToLabelConversion, [this]);\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\t// Convert ticks to strings\n\t\t\tvar tickOpts = me.options.ticks;\n\t\t\tme.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);\n\t\t},\n\t\tafterTickToLabelConversion: function() {\n\t\t\thelpers.callback(this.options.afterTickToLabelConversion, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeCalculateTickRotation: function() {\n\t\t\thelpers.callback(this.options.beforeCalculateTickRotation, [this]);\n\t\t},\n\t\tcalculateTickRotation: function() {\n\t\t\tvar me = this;\n\t\t\tvar context = me.ctx;\n\t\t\tvar tickOpts = me.options.ticks;\n\t\t\tvar labels = labelsFromTicks(me._ticks);\n\n\t\t\t// Get the width of each grid by calculating the difference\n\t\t\t// between x offsets between 0 and 1.\n\t\t\tvar tickFont = parseFontOptions(tickOpts);\n\t\t\tcontext.font = tickFont.font;\n\n\t\t\tvar labelRotation = tickOpts.minRotation || 0;\n\n\t\t\tif (labels.length && me.options.display && me.isHorizontal()) {\n\t\t\t\tvar originalLabelWidth = helpers.longestText(context, tickFont.font, labels, me.longestTextCache);\n\t\t\t\tvar labelWidth = originalLabelWidth;\n\t\t\t\tvar cosRotation, sinRotation;\n\n\t\t\t\t// Allow 3 pixels x2 padding either side for label readability\n\t\t\t\tvar tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;\n\n\t\t\t\t// Max label rotation can be set or default to 90 - also act as a loop counter\n\t\t\t\twhile (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {\n\t\t\t\t\tvar angleRadians = helpers.toRadians(labelRotation);\n\t\t\t\t\tcosRotation = Math.cos(angleRadians);\n\t\t\t\t\tsinRotation = Math.sin(angleRadians);\n\n\t\t\t\t\tif (sinRotation * originalLabelWidth > me.maxHeight) {\n\t\t\t\t\t\t// go back one step\n\t\t\t\t\t\tlabelRotation--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tlabelRotation++;\n\t\t\t\t\tlabelWidth = cosRotation * originalLabelWidth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.labelRotation = labelRotation;\n\t\t},\n\t\tafterCalculateTickRotation: function() {\n\t\t\thelpers.callback(this.options.afterCalculateTickRotation, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeFit: function() {\n\t\t\thelpers.callback(this.options.beforeFit, [this]);\n\t\t},\n\t\tfit: function() {\n\t\t\tvar me = this;\n\t\t\t// Reset\n\t\t\tvar minSize = me.minSize = {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\n\t\t\tvar labels = labelsFromTicks(me._ticks);\n\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar scaleLabelOpts = opts.scaleLabel;\n\t\t\tvar gridLineOpts = opts.gridLines;\n\t\t\tvar display = opts.display;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tvar tickFont = parseFontOptions(tickOpts);\n\t\t\tvar tickMarkLength = opts.gridLines.tickMarkLength;\n\n\t\t\t// Width\n\t\t\tif (isHorizontal) {\n\t\t\t\t// subtract the margins to line up with the chartArea if we are a full width scale\n\t\t\t\tminSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\n\t\t\t} else {\n\t\t\t\tminSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t\t}\n\n\t\t\t// height\n\t\t\tif (isHorizontal) {\n\t\t\t\tminSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t\t} else {\n\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t}\n\n\t\t\t// Are we showing a title for the scale?\n\t\t\tif (scaleLabelOpts.display && display) {\n\t\t\t\tvar scaleLabelLineHeight = parseLineHeight(scaleLabelOpts);\n\t\t\t\tvar scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);\n\t\t\t\tvar deltaHeight = scaleLabelLineHeight + scaleLabelPadding.height;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tminSize.height += deltaHeight;\n\t\t\t\t} else {\n\t\t\t\t\tminSize.width += deltaHeight;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Don't bother fitting the ticks if we are not showing them\n\t\t\tif (tickOpts.display && display) {\n\t\t\t\tvar largestTextWidth = helpers.longestText(me.ctx, tickFont.font, labels, me.longestTextCache);\n\t\t\t\tvar tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);\n\t\t\t\tvar lineSpace = tickFont.size * 0.5;\n\t\t\t\tvar tickPadding = me.options.ticks.padding;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t// A horizontal axis is more constrained by the height.\n\t\t\t\t\tme.longestLabelWidth = largestTextWidth;\n\n\t\t\t\t\tvar angleRadians = helpers.toRadians(me.labelRotation);\n\t\t\t\t\tvar cosRotation = Math.cos(angleRadians);\n\t\t\t\t\tvar sinRotation = Math.sin(angleRadians);\n\n\t\t\t\t\t// TODO - improve this calculation\n\t\t\t\t\tvar labelHeight = (sinRotation * largestTextWidth)\n\t\t\t\t\t\t+ (tickFont.size * tallestLabelHeightInLines)\n\t\t\t\t\t\t+ (lineSpace * (tallestLabelHeightInLines - 1))\n\t\t\t\t\t\t+ lineSpace; // padding\n\n\t\t\t\t\tminSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);\n\n\t\t\t\t\tme.ctx.font = tickFont.font;\n\t\t\t\t\tvar firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.font);\n\t\t\t\t\tvar lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.font);\n\n\t\t\t\t\t// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\n\t\t\t\t\t// which means that the right padding is dominated by the font height\n\t\t\t\t\tif (me.labelRotation !== 0) {\n\t\t\t\t\t\tme.paddingLeft = opts.position === 'bottom' ? (cosRotation * firstLabelWidth) + 3 : (cosRotation * lineSpace) + 3; // add 3 px to move away from canvas edges\n\t\t\t\t\t\tme.paddingRight = opts.position === 'bottom' ? (cosRotation * lineSpace) + 3 : (cosRotation * lastLabelWidth) + 3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tme.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges\n\t\t\t\t\t\tme.paddingRight = lastLabelWidth / 2 + 3;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// A vertical axis is more constrained by the width. Labels are the\n\t\t\t\t\t// dominant factor here, so get that length first and account for padding\n\t\t\t\t\tif (tickOpts.mirror) {\n\t\t\t\t\t\tlargestTextWidth = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// use lineSpace for consistency with horizontal axis\n\t\t\t\t\t\t// tickPadding is not implemented for horizontal\n\t\t\t\t\t\tlargestTextWidth += tickPadding + lineSpace;\n\t\t\t\t\t}\n\n\t\t\t\t\tminSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);\n\n\t\t\t\t\tme.paddingTop = tickFont.size / 2;\n\t\t\t\t\tme.paddingBottom = tickFont.size / 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.handleMargins();\n\n\t\t\tme.width = minSize.width;\n\t\t\tme.height = minSize.height;\n\t\t},\n\n\t\t/**\n\t\t * Handle margins and padding interactions\n\t\t * @private\n\t\t */\n\t\thandleMargins: function() {\n\t\t\tvar me = this;\n\t\t\tif (me.margins) {\n\t\t\t\tme.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\n\t\t\t\tme.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);\n\t\t\t\tme.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\n\t\t\t\tme.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);\n\t\t\t}\n\t\t},\n\n\t\tafterFit: function() {\n\t\t\thelpers.callback(this.options.afterFit, [this]);\n\t\t},\n\n\t\t// Shared Methods\n\t\tisHorizontal: function() {\n\t\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t\t},\n\t\tisFullWidth: function() {\n\t\t\treturn (this.options.fullWidth);\n\t\t},\n\n\t\t// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not\n\t\tgetRightValue: function(rawValue) {\n\t\t\t// Null and undefined values first\n\t\t\tif (helpers.isNullOrUndef(rawValue)) {\n\t\t\t\treturn NaN;\n\t\t\t}\n\t\t\t// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values\n\t\t\tif (typeof rawValue === 'number' && !isFinite(rawValue)) {\n\t\t\t\treturn NaN;\n\t\t\t}\n\t\t\t// If it is in fact an object, dive in one more level\n\t\t\tif (rawValue) {\n\t\t\t\tif (this.isHorizontal()) {\n\t\t\t\t\tif (rawValue.x !== undefined) {\n\t\t\t\t\t\treturn this.getRightValue(rawValue.x);\n\t\t\t\t\t}\n\t\t\t\t} else if (rawValue.y !== undefined) {\n\t\t\t\t\treturn this.getRightValue(rawValue.y);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Value is good, return it\n\t\t\treturn rawValue;\n\t\t},\n\n\t\t/**\n\t\t * Used to get the value to display in the tooltip for the data at the given index\n\t\t * @param index\n\t\t * @param datasetIndex\n\t\t */\n\t\tgetLabelForIndex: helpers.noop,\n\n\t\t/**\n\t\t * Returns the location of the given data point. Value can either be an index or a numerical value\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t * @param value\n\t\t * @param index\n\t\t * @param datasetIndex\n\t\t */\n\t\tgetPixelForValue: helpers.noop,\n\n\t\t/**\n\t\t * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t * @param pixel\n\t\t */\n\t\tgetValueForPixel: helpers.noop,\n\n\t\t/**\n\t\t * Returns the location of the tick at the given index\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t */\n\t\tgetPixelForTick: function(index) {\n\t\t\tvar me = this;\n\t\t\tvar offset = me.options.offset;\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\tvar tickWidth = innerWidth / Math.max((me._ticks.length - (offset ? 0 : 1)), 1);\n\t\t\t\tvar pixel = (tickWidth * index) + me.paddingLeft;\n\n\t\t\t\tif (offset) {\n\t\t\t\t\tpixel += tickWidth / 2;\n\t\t\t\t}\n\n\t\t\t\tvar finalVal = me.left + Math.round(pixel);\n\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\t\treturn finalVal;\n\t\t\t}\n\t\t\tvar innerHeight = me.height - (me.paddingTop + me.paddingBottom);\n\t\t\treturn me.top + (index * (innerHeight / (me._ticks.length - 1)));\n\t\t},\n\n\t\t/**\n\t\t * Utility for getting the pixel location of a percentage of scale\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t */\n\t\tgetPixelForDecimal: function(decimal) {\n\t\t\tvar me = this;\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\tvar valueOffset = (innerWidth * decimal) + me.paddingLeft;\n\n\t\t\t\tvar finalVal = me.left + Math.round(valueOffset);\n\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\t\treturn finalVal;\n\t\t\t}\n\t\t\treturn me.top + (decimal * me.height);\n\t\t},\n\n\t\t/**\n\t\t * Returns the pixel for the minimum chart value\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t */\n\t\tgetBasePixel: function() {\n\t\t\treturn this.getPixelForValue(this.getBaseValue());\n\t\t},\n\n\t\tgetBaseValue: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\n\t\t\treturn me.beginAtZero ? 0 :\n\t\t\t\tmin < 0 && max < 0 ? max :\n\t\t\t\tmin > 0 && max > 0 ? min :\n\t\t\t\t0;\n\t\t},\n\n\t\t/**\n\t\t * Returns a subset of ticks to be plotted to avoid overlapping labels.\n\t\t * @private\n\t\t */\n\t\t_autoSkip: function(ticks) {\n\t\t\tvar skipRatio;\n\t\t\tvar me = this;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar optionTicks = me.options.ticks.minor;\n\t\t\tvar tickCount = ticks.length;\n\t\t\tvar labelRotationRadians = helpers.toRadians(me.labelRotation);\n\t\t\tvar cosRotation = Math.cos(labelRotationRadians);\n\t\t\tvar longestRotatedLabel = me.longestLabelWidth * cosRotation;\n\t\t\tvar result = [];\n\t\t\tvar i, tick, shouldSkip;\n\n\t\t\t// figure out the maximum number of gridlines to show\n\t\t\tvar maxTicks;\n\t\t\tif (optionTicks.maxTicksLimit) {\n\t\t\t\tmaxTicks = optionTicks.maxTicksLimit;\n\t\t\t}\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tskipRatio = false;\n\n\t\t\t\tif ((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount > (me.width - (me.paddingLeft + me.paddingRight))) {\n\t\t\t\t\tskipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount) / (me.width - (me.paddingLeft + me.paddingRight)));\n\t\t\t\t}\n\n\t\t\t\t// if they defined a max number of optionTicks,\n\t\t\t\t// increase skipRatio until that number is met\n\t\t\t\tif (maxTicks && tickCount > maxTicks) {\n\t\t\t\t\tskipRatio = Math.max(skipRatio, Math.floor(tickCount / maxTicks));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < tickCount; i++) {\n\t\t\t\ttick = ticks[i];\n\n\t\t\t\t// Since we always show the last tick,we need may need to hide the last shown one before\n\t\t\t\tshouldSkip = (skipRatio > 1 && i % skipRatio > 0) || (i % skipRatio === 0 && i + skipRatio >= tickCount);\n\t\t\t\tif (shouldSkip && i !== tickCount - 1) {\n\t\t\t\t\t// leave tick in place but make sure it's not displayed (#4635)\n\t\t\t\t\tdelete tick.label;\n\t\t\t\t}\n\t\t\t\tresult.push(tick);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\n\t\t// Actually draw the scale on the canvas\n\t\t// @param {rectangle} chartArea : the area of the chart to draw full grid lines on\n\t\tdraw: function(chartArea) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tif (!options.display) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar context = me.ctx;\n\t\t\tvar globalDefaults = defaults.global;\n\t\t\tvar optionTicks = options.ticks.minor;\n\t\t\tvar optionMajorTicks = options.ticks.major || optionTicks;\n\t\t\tvar gridLines = options.gridLines;\n\t\t\tvar scaleLabel = options.scaleLabel;\n\n\t\t\tvar isRotated = me.labelRotation !== 0;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tvar ticks = optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();\n\t\t\tvar tickFontColor = helpers.valueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);\n\t\t\tvar tickFont = parseFontOptions(optionTicks);\n\t\t\tvar majorTickFontColor = helpers.valueOrDefault(optionMajorTicks.fontColor, globalDefaults.defaultFontColor);\n\t\t\tvar majorTickFont = parseFontOptions(optionMajorTicks);\n\n\t\t\tvar tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;\n\n\t\t\tvar scaleLabelFontColor = helpers.valueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);\n\t\t\tvar scaleLabelFont = parseFontOptions(scaleLabel);\n\t\t\tvar scaleLabelPadding = helpers.options.toPadding(scaleLabel.padding);\n\t\t\tvar labelRotationRadians = helpers.toRadians(me.labelRotation);\n\n\t\t\tvar itemsToDraw = [];\n\n\t\t\tvar axisWidth = me.options.gridLines.lineWidth;\n\t\t\tvar xTickStart = options.position === 'right' ? me.right : me.right - axisWidth - tl;\n\t\t\tvar xTickEnd = options.position === 'right' ? me.right + tl : me.right;\n\t\t\tvar yTickStart = options.position === 'bottom' ? me.top + axisWidth : me.bottom - tl - axisWidth;\n\t\t\tvar yTickEnd = options.position === 'bottom' ? me.top + axisWidth + tl : me.bottom + axisWidth;\n\n\t\t\thelpers.each(ticks, function(tick, index) {\n\t\t\t\t// autoskipper skipped this tick (#4635)\n\t\t\t\tif (helpers.isNullOrUndef(tick.label)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar label = tick.label;\n\t\t\t\tvar lineWidth, lineColor, borderDash, borderDashOffset;\n\t\t\t\tif (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {\n\t\t\t\t\t// Draw the first index specially\n\t\t\t\t\tlineWidth = gridLines.zeroLineWidth;\n\t\t\t\t\tlineColor = gridLines.zeroLineColor;\n\t\t\t\t\tborderDash = gridLines.zeroLineBorderDash;\n\t\t\t\t\tborderDashOffset = gridLines.zeroLineBorderDashOffset;\n\t\t\t\t} else {\n\t\t\t\t\tlineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, index);\n\t\t\t\t\tlineColor = helpers.valueAtIndexOrDefault(gridLines.color, index);\n\t\t\t\t\tborderDash = helpers.valueOrDefault(gridLines.borderDash, globalDefaults.borderDash);\n\t\t\t\t\tborderDashOffset = helpers.valueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);\n\t\t\t\t}\n\n\t\t\t\t// Common properties\n\t\t\t\tvar tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;\n\t\t\t\tvar textAlign = 'middle';\n\t\t\t\tvar textBaseline = 'middle';\n\t\t\t\tvar tickPadding = optionTicks.padding;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tvar labelYOffset = tl + tickPadding;\n\n\t\t\t\t\tif (options.position === 'bottom') {\n\t\t\t\t\t\t// bottom\n\t\t\t\t\t\ttextBaseline = !isRotated ? 'top' : 'middle';\n\t\t\t\t\t\ttextAlign = !isRotated ? 'center' : 'right';\n\t\t\t\t\t\tlabelY = me.top + labelYOffset;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// top\n\t\t\t\t\t\ttextBaseline = !isRotated ? 'bottom' : 'middle';\n\t\t\t\t\t\ttextAlign = !isRotated ? 'center' : 'left';\n\t\t\t\t\t\tlabelY = me.bottom - labelYOffset;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar xLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);\n\t\t\t\t\tif (xLineValue < me.left) {\n\t\t\t\t\t\tlineColor = 'rgba(0,0,0,0)';\n\t\t\t\t\t}\n\t\t\t\t\txLineValue += helpers.aliasPixel(lineWidth);\n\n\t\t\t\t\tlabelX = me.getPixelForTick(index) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)\n\n\t\t\t\t\ttx1 = tx2 = x1 = x2 = xLineValue;\n\t\t\t\t\tty1 = yTickStart;\n\t\t\t\t\tty2 = yTickEnd;\n\t\t\t\t\ty1 = chartArea.top;\n\t\t\t\t\ty2 = chartArea.bottom + axisWidth;\n\t\t\t\t} else {\n\t\t\t\t\tvar isLeft = options.position === 'left';\n\t\t\t\t\tvar labelXOffset;\n\n\t\t\t\t\tif (optionTicks.mirror) {\n\t\t\t\t\t\ttextAlign = isLeft ? 'left' : 'right';\n\t\t\t\t\t\tlabelXOffset = tickPadding;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttextAlign = isLeft ? 'right' : 'left';\n\t\t\t\t\t\tlabelXOffset = tl + tickPadding;\n\t\t\t\t\t}\n\n\t\t\t\t\tlabelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;\n\n\t\t\t\t\tvar yLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);\n\t\t\t\t\tif (yLineValue < me.top) {\n\t\t\t\t\t\tlineColor = 'rgba(0,0,0,0)';\n\t\t\t\t\t}\n\t\t\t\t\tyLineValue += helpers.aliasPixel(lineWidth);\n\n\t\t\t\t\tlabelY = me.getPixelForTick(index) + optionTicks.labelOffset;\n\n\t\t\t\t\ttx1 = xTickStart;\n\t\t\t\t\ttx2 = xTickEnd;\n\t\t\t\t\tx1 = chartArea.left;\n\t\t\t\t\tx2 = chartArea.right + axisWidth;\n\t\t\t\t\tty1 = ty2 = y1 = y2 = yLineValue;\n\t\t\t\t}\n\n\t\t\t\titemsToDraw.push({\n\t\t\t\t\ttx1: tx1,\n\t\t\t\t\tty1: ty1,\n\t\t\t\t\ttx2: tx2,\n\t\t\t\t\tty2: ty2,\n\t\t\t\t\tx1: x1,\n\t\t\t\t\ty1: y1,\n\t\t\t\t\tx2: x2,\n\t\t\t\t\ty2: y2,\n\t\t\t\t\tlabelX: labelX,\n\t\t\t\t\tlabelY: labelY,\n\t\t\t\t\tglWidth: lineWidth,\n\t\t\t\t\tglColor: lineColor,\n\t\t\t\t\tglBorderDash: borderDash,\n\t\t\t\t\tglBorderDashOffset: borderDashOffset,\n\t\t\t\t\trotation: -1 * labelRotationRadians,\n\t\t\t\t\tlabel: label,\n\t\t\t\t\tmajor: tick.major,\n\t\t\t\t\ttextBaseline: textBaseline,\n\t\t\t\t\ttextAlign: textAlign\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// Draw all of the tick labels, tick marks, and grid lines at the correct places\n\t\t\thelpers.each(itemsToDraw, function(itemToDraw) {\n\t\t\t\tif (gridLines.display) {\n\t\t\t\t\tcontext.save();\n\t\t\t\t\tcontext.lineWidth = itemToDraw.glWidth;\n\t\t\t\t\tcontext.strokeStyle = itemToDraw.glColor;\n\t\t\t\t\tif (context.setLineDash) {\n\t\t\t\t\t\tcontext.setLineDash(itemToDraw.glBorderDash);\n\t\t\t\t\t\tcontext.lineDashOffset = itemToDraw.glBorderDashOffset;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.beginPath();\n\n\t\t\t\t\tif (gridLines.drawTicks) {\n\t\t\t\t\t\tcontext.moveTo(itemToDraw.tx1, itemToDraw.ty1);\n\t\t\t\t\t\tcontext.lineTo(itemToDraw.tx2, itemToDraw.ty2);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gridLines.drawOnChartArea) {\n\t\t\t\t\t\tcontext.moveTo(itemToDraw.x1, itemToDraw.y1);\n\t\t\t\t\t\tcontext.lineTo(itemToDraw.x2, itemToDraw.y2);\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.stroke();\n\t\t\t\t\tcontext.restore();\n\t\t\t\t}\n\n\t\t\t\tif (optionTicks.display) {\n\t\t\t\t\t// Make sure we draw text in the correct color and font\n\t\t\t\t\tcontext.save();\n\t\t\t\t\tcontext.translate(itemToDraw.labelX, itemToDraw.labelY);\n\t\t\t\t\tcontext.rotate(itemToDraw.rotation);\n\t\t\t\t\tcontext.font = itemToDraw.major ? majorTickFont.font : tickFont.font;\n\t\t\t\t\tcontext.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;\n\t\t\t\t\tcontext.textBaseline = itemToDraw.textBaseline;\n\t\t\t\t\tcontext.textAlign = itemToDraw.textAlign;\n\n\t\t\t\t\tvar label = itemToDraw.label;\n\t\t\t\t\tif (helpers.isArray(label)) {\n\t\t\t\t\t\tvar lineCount = label.length;\n\t\t\t\t\t\tvar lineHeight = tickFont.size * 1.5;\n\t\t\t\t\t\tvar y = me.isHorizontal() ? 0 : -lineHeight * (lineCount - 1) / 2;\n\n\t\t\t\t\t\tfor (var i = 0; i < lineCount; ++i) {\n\t\t\t\t\t\t\t// We just make sure the multiline element is a string here..\n\t\t\t\t\t\t\tcontext.fillText('' + label[i], 0, y);\n\t\t\t\t\t\t\t// apply same lineSpacing as calculated @ L#320\n\t\t\t\t\t\t\ty += lineHeight;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.fillText(label, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\tcontext.restore();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (scaleLabel.display) {\n\t\t\t\t// Draw the scale label\n\t\t\t\tvar scaleLabelX;\n\t\t\t\tvar scaleLabelY;\n\t\t\t\tvar rotation = 0;\n\t\t\t\tvar halfLineHeight = parseLineHeight(scaleLabel) / 2;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tscaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width\n\t\t\t\t\tscaleLabelY = options.position === 'bottom'\n\t\t\t\t\t\t? me.bottom - halfLineHeight - scaleLabelPadding.bottom\n\t\t\t\t\t\t: me.top + halfLineHeight + scaleLabelPadding.top;\n\t\t\t\t} else {\n\t\t\t\t\tvar isLeft = options.position === 'left';\n\t\t\t\t\tscaleLabelX = isLeft\n\t\t\t\t\t\t? me.left + halfLineHeight + scaleLabelPadding.top\n\t\t\t\t\t\t: me.right - halfLineHeight - scaleLabelPadding.top;\n\t\t\t\t\tscaleLabelY = me.top + ((me.bottom - me.top) / 2);\n\t\t\t\t\trotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\n\t\t\t\t}\n\n\t\t\t\tcontext.save();\n\t\t\t\tcontext.translate(scaleLabelX, scaleLabelY);\n\t\t\t\tcontext.rotate(rotation);\n\t\t\t\tcontext.textAlign = 'center';\n\t\t\t\tcontext.textBaseline = 'middle';\n\t\t\t\tcontext.fillStyle = scaleLabelFontColor; // render in correct colour\n\t\t\t\tcontext.font = scaleLabelFont.font;\n\t\t\t\tcontext.fillText(scaleLabel.labelString, 0, 0);\n\t\t\t\tcontext.restore();\n\t\t\t}\n\n\t\t\tif (gridLines.drawBorder) {\n\t\t\t\t// Draw the line at the edge of the axis\n\t\t\t\tcontext.lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, 0);\n\t\t\t\tcontext.strokeStyle = helpers.valueAtIndexOrDefault(gridLines.color, 0);\n\t\t\t\tvar x1 = me.left;\n\t\t\t\tvar x2 = me.right + axisWidth;\n\t\t\t\tvar y1 = me.top;\n\t\t\t\tvar y2 = me.bottom + axisWidth;\n\n\t\t\t\tvar aliasPixel = helpers.aliasPixel(context.lineWidth);\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\ty1 = y2 = options.position === 'top' ? me.bottom : me.top;\n\t\t\t\t\ty1 += aliasPixel;\n\t\t\t\t\ty2 += aliasPixel;\n\t\t\t\t} else {\n\t\t\t\t\tx1 = x2 = options.position === 'left' ? me.right : me.left;\n\t\t\t\t\tx1 += aliasPixel;\n\t\t\t\t\tx2 += aliasPixel;\n\t\t\t\t}\n\n\t\t\t\tcontext.beginPath();\n\t\t\t\tcontext.moveTo(x1, y1);\n\t\t\t\tcontext.lineTo(x2, y2);\n\t\t\t\tcontext.stroke();\n\t\t\t}\n\t\t}\n\t});\n};\n","'use strict';\n\nvar defaults = require('./core.defaults');\nvar helpers = require('../helpers/index');\nvar layouts = require('./core.layouts');\n\nmodule.exports = function(Chart) {\n\n\tChart.scaleService = {\n\t\t// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then\n\t\t// use the new chart options to grab the correct scale\n\t\tconstructors: {},\n\t\t// Use a registration function so that we can move to an ES6 map when we no longer need to support\n\t\t// old browsers\n\n\t\t// Scale config defaults\n\t\tdefaults: {},\n\t\tregisterScaleType: function(type, scaleConstructor, scaleDefaults) {\n\t\t\tthis.constructors[type] = scaleConstructor;\n\t\t\tthis.defaults[type] = helpers.clone(scaleDefaults);\n\t\t},\n\t\tgetScaleConstructor: function(type) {\n\t\t\treturn this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;\n\t\t},\n\t\tgetScaleDefaults: function(type) {\n\t\t\t// Return the scale defaults merged with the global settings so that we always use the latest ones\n\t\t\treturn this.defaults.hasOwnProperty(type) ? helpers.merge({}, [defaults.scale, this.defaults[type]]) : {};\n\t\t},\n\t\tupdateScaleDefaults: function(type, additions) {\n\t\t\tvar me = this;\n\t\t\tif (me.defaults.hasOwnProperty(type)) {\n\t\t\t\tme.defaults[type] = helpers.extend(me.defaults[type], additions);\n\t\t\t}\n\t\t},\n\t\taddScalesToLayout: function(chart) {\n\t\t\t// Adds each scale to the chart.boxes array to be sized accordingly\n\t\t\thelpers.each(chart.scales, function(scale) {\n\t\t\t\t// Set ILayoutItem parameters for backwards compatibility\n\t\t\t\tscale.fullWidth = scale.options.fullWidth;\n\t\t\t\tscale.position = scale.options.position;\n\t\t\t\tscale.weight = scale.options.weight;\n\t\t\t\tlayouts.addBox(chart, scale);\n\t\t\t});\n\t\t}\n\t};\n};\n","'use strict';\n\nvar helpers = require('../helpers/index');\n\n/**\n * Namespace to hold static tick generation functions\n * @namespace Chart.Ticks\n */\nmodule.exports = {\n\t/**\n\t * Namespace to hold formatters for different types of ticks\n\t * @namespace Chart.Ticks.formatters\n\t */\n\tformatters: {\n\t\t/**\n\t\t * Formatter for value labels\n\t\t * @method Chart.Ticks.formatters.values\n\t\t * @param value the value to display\n\t\t * @return {String|Array} the label to display\n\t\t */\n\t\tvalues: function(value) {\n\t\t\treturn helpers.isArray(value) ? value : '' + value;\n\t\t},\n\n\t\t/**\n\t\t * Formatter for linear numeric ticks\n\t\t * @method Chart.Ticks.formatters.linear\n\t\t * @param tickValue {Number} the value to be formatted\n\t\t * @param index {Number} the position of the tickValue parameter in the ticks array\n\t\t * @param ticks {Array<Number>} the list of ticks being converted\n\t\t * @return {String} string representation of the tickValue parameter\n\t\t */\n\t\tlinear: function(tickValue, index, ticks) {\n\t\t\t// If we have lots of ticks, don't use the ones\n\t\t\tvar delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];\n\n\t\t\t// If we have a number like 2.5 as the delta, figure out how many decimal places we need\n\t\t\tif (Math.abs(delta) > 1) {\n\t\t\t\tif (tickValue !== Math.floor(tickValue)) {\n\t\t\t\t\t// not an integer\n\t\t\t\t\tdelta = tickValue - Math.floor(tickValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar logDelta = helpers.log10(Math.abs(delta));\n\t\t\tvar tickString = '';\n\n\t\t\tif (tickValue !== 0) {\n\t\t\t\tvar numDecimal = -1 * Math.floor(logDelta);\n\t\t\t\tnumDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\n\t\t\t\ttickString = tickValue.toFixed(numDecimal);\n\t\t\t} else {\n\t\t\t\ttickString = '0'; // never show decimal places for 0\n\t\t\t}\n\n\t\t\treturn tickString;\n\t\t},\n\n\t\tlogarithmic: function(tickValue, index, ticks) {\n\t\t\tvar remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));\n\n\t\t\tif (tickValue === 0) {\n\t\t\t\treturn '0';\n\t\t\t} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\n\t\t\t\treturn tickValue.toExponential();\n\t\t\t}\n\t\t\treturn '';\n\t\t}\n\t}\n};\n","'use strict';\n\nvar defaults = require('./core.defaults');\nvar Element = require('./core.element');\nvar helpers = require('../helpers/index');\n\ndefaults._set('global', {\n\ttooltips: {\n\t\tenabled: true,\n\t\tcustom: null,\n\t\tmode: 'nearest',\n\t\tposition: 'average',\n\t\tintersect: true,\n\t\tbackgroundColor: 'rgba(0,0,0,0.8)',\n\t\ttitleFontStyle: 'bold',\n\t\ttitleSpacing: 2,\n\t\ttitleMarginBottom: 6,\n\t\ttitleFontColor: '#fff',\n\t\ttitleAlign: 'left',\n\t\tbodySpacing: 2,\n\t\tbodyFontColor: '#fff',\n\t\tbodyAlign: 'left',\n\t\tfooterFontStyle: 'bold',\n\t\tfooterSpacing: 2,\n\t\tfooterMarginTop: 6,\n\t\tfooterFontColor: '#fff',\n\t\tfooterAlign: 'left',\n\t\tyPadding: 6,\n\t\txPadding: 6,\n\t\tcaretPadding: 2,\n\t\tcaretSize: 5,\n\t\tcornerRadius: 6,\n\t\tmultiKeyBackground: '#fff',\n\t\tdisplayColors: true,\n\t\tborderColor: 'rgba(0,0,0,0)',\n\t\tborderWidth: 0,\n\t\tcallbacks: {\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tbeforeTitle: helpers.noop,\n\t\t\ttitle: function(tooltipItems, data) {\n\t\t\t\t// Pick first xLabel for now\n\t\t\t\tvar title = '';\n\t\t\t\tvar labels = data.labels;\n\t\t\t\tvar labelCount = labels ? labels.length : 0;\n\n\t\t\t\tif (tooltipItems.length > 0) {\n\t\t\t\t\tvar item = tooltipItems[0];\n\n\t\t\t\t\tif (item.xLabel) {\n\t\t\t\t\t\ttitle = item.xLabel;\n\t\t\t\t\t} else if (labelCount > 0 && item.index < labelCount) {\n\t\t\t\t\t\ttitle = labels[item.index];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn title;\n\t\t\t},\n\t\t\tafterTitle: helpers.noop,\n\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tbeforeBody: helpers.noop,\n\n\t\t\t// Args are: (tooltipItem, data)\n\t\t\tbeforeLabel: helpers.noop,\n\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\tvar label = data.datasets[tooltipItem.datasetIndex].label || '';\n\n\t\t\t\tif (label) {\n\t\t\t\t\tlabel += ': ';\n\t\t\t\t}\n\t\t\t\tlabel += tooltipItem.yLabel;\n\t\t\t\treturn label;\n\t\t\t},\n\t\t\tlabelColor: function(tooltipItem, chart) {\n\t\t\t\tvar meta = chart.getDatasetMeta(tooltipItem.datasetIndex);\n\t\t\t\tvar activeElement = meta.data[tooltipItem.index];\n\t\t\t\tvar view = activeElement._view;\n\t\t\t\treturn {\n\t\t\t\t\tborderColor: view.borderColor,\n\t\t\t\t\tbackgroundColor: view.backgroundColor\n\t\t\t\t};\n\t\t\t},\n\t\t\tlabelTextColor: function() {\n\t\t\t\treturn this._options.bodyFontColor;\n\t\t\t},\n\t\t\tafterLabel: helpers.noop,\n\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tafterBody: helpers.noop,\n\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tbeforeFooter: helpers.noop,\n\t\t\tfooter: helpers.noop,\n\t\t\tafterFooter: helpers.noop\n\t\t}\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\t/**\n \t * Helper method to merge the opacity into a color\n \t */\n\tfunction mergeOpacity(colorString, opacity) {\n\t\tvar color = helpers.color(colorString);\n\t\treturn color.alpha(opacity * color.alpha()).rgbaString();\n\t}\n\n\t// Helper to push or concat based on if the 2nd parameter is an array or not\n\tfunction pushOrConcat(base, toPush) {\n\t\tif (toPush) {\n\t\t\tif (helpers.isArray(toPush)) {\n\t\t\t\t// base = base.concat(toPush);\n\t\t\t\tArray.prototype.push.apply(base, toPush);\n\t\t\t} else {\n\t\t\t\tbase.push(toPush);\n\t\t\t}\n\t\t}\n\n\t\treturn base;\n\t}\n\n\t// Private helper to create a tooltip item model\n\t// @param element : the chart element (point, arc, bar) to create the tooltip item for\n\t// @return : new tooltip item\n\tfunction createTooltipItem(element) {\n\t\tvar xScale = element._xScale;\n\t\tvar yScale = element._yScale || element._scale; // handle radar || polarArea charts\n\t\tvar index = element._index;\n\t\tvar datasetIndex = element._datasetIndex;\n\n\t\treturn {\n\t\t\txLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',\n\t\t\tyLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',\n\t\t\tindex: index,\n\t\t\tdatasetIndex: datasetIndex,\n\t\t\tx: element._model.x,\n\t\t\ty: element._model.y\n\t\t};\n\t}\n\n\t/**\n\t * Helper to get the reset model for the tooltip\n\t * @param tooltipOpts {Object} the tooltip options\n\t */\n\tfunction getBaseModel(tooltipOpts) {\n\t\tvar globalDefaults = defaults.global;\n\t\tvar valueOrDefault = helpers.valueOrDefault;\n\n\t\treturn {\n\t\t\t// Positioning\n\t\t\txPadding: tooltipOpts.xPadding,\n\t\t\tyPadding: tooltipOpts.yPadding,\n\t\t\txAlign: tooltipOpts.xAlign,\n\t\t\tyAlign: tooltipOpts.yAlign,\n\n\t\t\t// Body\n\t\t\tbodyFontColor: tooltipOpts.bodyFontColor,\n\t\t\t_bodyFontFamily: valueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t_bodyFontStyle: valueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),\n\t\t\t_bodyAlign: tooltipOpts.bodyAlign,\n\t\t\tbodyFontSize: valueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),\n\t\t\tbodySpacing: tooltipOpts.bodySpacing,\n\n\t\t\t// Title\n\t\t\ttitleFontColor: tooltipOpts.titleFontColor,\n\t\t\t_titleFontFamily: valueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t_titleFontStyle: valueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),\n\t\t\ttitleFontSize: valueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),\n\t\t\t_titleAlign: tooltipOpts.titleAlign,\n\t\t\ttitleSpacing: tooltipOpts.titleSpacing,\n\t\t\ttitleMarginBottom: tooltipOpts.titleMarginBottom,\n\n\t\t\t// Footer\n\t\t\tfooterFontColor: tooltipOpts.footerFontColor,\n\t\t\t_footerFontFamily: valueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t_footerFontStyle: valueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),\n\t\t\tfooterFontSize: valueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),\n\t\t\t_footerAlign: tooltipOpts.footerAlign,\n\t\t\tfooterSpacing: tooltipOpts.footerSpacing,\n\t\t\tfooterMarginTop: tooltipOpts.footerMarginTop,\n\n\t\t\t// Appearance\n\t\t\tcaretSize: tooltipOpts.caretSize,\n\t\t\tcornerRadius: tooltipOpts.cornerRadius,\n\t\t\tbackgroundColor: tooltipOpts.backgroundColor,\n\t\t\topacity: 0,\n\t\t\tlegendColorBackground: tooltipOpts.multiKeyBackground,\n\t\t\tdisplayColors: tooltipOpts.displayColors,\n\t\t\tborderColor: tooltipOpts.borderColor,\n\t\t\tborderWidth: tooltipOpts.borderWidth\n\t\t};\n\t}\n\n\t/**\n\t * Get the size of the tooltip\n\t */\n\tfunction getTooltipSize(tooltip, model) {\n\t\tvar ctx = tooltip._chart.ctx;\n\n\t\tvar height = model.yPadding * 2; // Tooltip Padding\n\t\tvar width = 0;\n\n\t\t// Count of all lines in the body\n\t\tvar body = model.body;\n\t\tvar combinedBodyLength = body.reduce(function(count, bodyItem) {\n\t\t\treturn count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;\n\t\t}, 0);\n\t\tcombinedBodyLength += model.beforeBody.length + model.afterBody.length;\n\n\t\tvar titleLineCount = model.title.length;\n\t\tvar footerLineCount = model.footer.length;\n\t\tvar titleFontSize = model.titleFontSize;\n\t\tvar bodyFontSize = model.bodyFontSize;\n\t\tvar footerFontSize = model.footerFontSize;\n\n\t\theight += titleLineCount * titleFontSize; // Title Lines\n\t\theight += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing\n\t\theight += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin\n\t\theight += combinedBodyLength * bodyFontSize; // Body Lines\n\t\theight += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing\n\t\theight += footerLineCount ? model.footerMarginTop : 0; // Footer Margin\n\t\theight += footerLineCount * (footerFontSize); // Footer Lines\n\t\theight += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing\n\n\t\t// Title width\n\t\tvar widthPadding = 0;\n\t\tvar maxLineWidth = function(line) {\n\t\t\twidth = Math.max(width, ctx.measureText(line).width + widthPadding);\n\t\t};\n\n\t\tctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);\n\t\thelpers.each(model.title, maxLineWidth);\n\n\t\t// Body width\n\t\tctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);\n\t\thelpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);\n\n\t\t// Body lines may include some extra width due to the color box\n\t\twidthPadding = model.displayColors ? (bodyFontSize + 2) : 0;\n\t\thelpers.each(body, function(bodyItem) {\n\t\t\thelpers.each(bodyItem.before, maxLineWidth);\n\t\t\thelpers.each(bodyItem.lines, maxLineWidth);\n\t\t\thelpers.each(bodyItem.after, maxLineWidth);\n\t\t});\n\n\t\t// Reset back to 0\n\t\twidthPadding = 0;\n\n\t\t// Footer width\n\t\tctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);\n\t\thelpers.each(model.footer, maxLineWidth);\n\n\t\t// Add padding\n\t\twidth += 2 * model.xPadding;\n\n\t\treturn {\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\t}\n\n\t/**\n\t * Helper to get the alignment of a tooltip given the size\n\t */\n\tfunction determineAlignment(tooltip, size) {\n\t\tvar model = tooltip._model;\n\t\tvar chart = tooltip._chart;\n\t\tvar chartArea = tooltip._chart.chartArea;\n\t\tvar xAlign = 'center';\n\t\tvar yAlign = 'center';\n\n\t\tif (model.y < size.height) {\n\t\t\tyAlign = 'top';\n\t\t} else if (model.y > (chart.height - size.height)) {\n\t\t\tyAlign = 'bottom';\n\t\t}\n\n\t\tvar lf, rf; // functions to determine left, right alignment\n\t\tvar olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart\n\t\tvar yf; // function to get the y alignment if the tooltip goes outside of the left or right edges\n\t\tvar midX = (chartArea.left + chartArea.right) / 2;\n\t\tvar midY = (chartArea.top + chartArea.bottom) / 2;\n\n\t\tif (yAlign === 'center') {\n\t\t\tlf = function(x) {\n\t\t\t\treturn x <= midX;\n\t\t\t};\n\t\t\trf = function(x) {\n\t\t\t\treturn x > midX;\n\t\t\t};\n\t\t} else {\n\t\t\tlf = function(x) {\n\t\t\t\treturn x <= (size.width / 2);\n\t\t\t};\n\t\t\trf = function(x) {\n\t\t\t\treturn x >= (chart.width - (size.width / 2));\n\t\t\t};\n\t\t}\n\n\t\tolf = function(x) {\n\t\t\treturn x + size.width + model.caretSize + model.caretPadding > chart.width;\n\t\t};\n\t\torf = function(x) {\n\t\t\treturn x - size.width - model.caretSize - model.caretPadding < 0;\n\t\t};\n\t\tyf = function(y) {\n\t\t\treturn y <= midY ? 'top' : 'bottom';\n\t\t};\n\n\t\tif (lf(model.x)) {\n\t\t\txAlign = 'left';\n\n\t\t\t// Is tooltip too wide and goes over the right side of the chart.?\n\t\t\tif (olf(model.x)) {\n\t\t\t\txAlign = 'center';\n\t\t\t\tyAlign = yf(model.y);\n\t\t\t}\n\t\t} else if (rf(model.x)) {\n\t\t\txAlign = 'right';\n\n\t\t\t// Is tooltip too wide and goes outside left edge of canvas?\n\t\t\tif (orf(model.x)) {\n\t\t\t\txAlign = 'center';\n\t\t\t\tyAlign = yf(model.y);\n\t\t\t}\n\t\t}\n\n\t\tvar opts = tooltip._options;\n\t\treturn {\n\t\t\txAlign: opts.xAlign ? opts.xAlign : xAlign,\n\t\t\tyAlign: opts.yAlign ? opts.yAlign : yAlign\n\t\t};\n\t}\n\n\t/**\n\t * @Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\n\t */\n\tfunction getBackgroundPoint(vm, size, alignment, chart) {\n\t\t// Background Position\n\t\tvar x = vm.x;\n\t\tvar y = vm.y;\n\n\t\tvar caretSize = vm.caretSize;\n\t\tvar caretPadding = vm.caretPadding;\n\t\tvar cornerRadius = vm.cornerRadius;\n\t\tvar xAlign = alignment.xAlign;\n\t\tvar yAlign = alignment.yAlign;\n\t\tvar paddingAndSize = caretSize + caretPadding;\n\t\tvar radiusAndPadding = cornerRadius + caretPadding;\n\n\t\tif (xAlign === 'right') {\n\t\t\tx -= size.width;\n\t\t} else if (xAlign === 'center') {\n\t\t\tx -= (size.width / 2);\n\t\t\tif (x + size.width > chart.width) {\n\t\t\t\tx = chart.width - size.width;\n\t\t\t}\n\t\t\tif (x < 0) {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (yAlign === 'top') {\n\t\t\ty += paddingAndSize;\n\t\t} else if (yAlign === 'bottom') {\n\t\t\ty -= size.height + paddingAndSize;\n\t\t} else {\n\t\t\ty -= (size.height / 2);\n\t\t}\n\n\t\tif (yAlign === 'center') {\n\t\t\tif (xAlign === 'left') {\n\t\t\t\tx += paddingAndSize;\n\t\t\t} else if (xAlign === 'right') {\n\t\t\t\tx -= paddingAndSize;\n\t\t\t}\n\t\t} else if (xAlign === 'left') {\n\t\t\tx -= radiusAndPadding;\n\t\t} else if (xAlign === 'right') {\n\t\t\tx += radiusAndPadding;\n\t\t}\n\n\t\treturn {\n\t\t\tx: x,\n\t\t\ty: y\n\t\t};\n\t}\n\n\tChart.Tooltip = Element.extend({\n\t\tinitialize: function() {\n\t\t\tthis._model = getBaseModel(this._options);\n\t\t\tthis._lastActive = [];\n\t\t},\n\n\t\t// Get the title\n\t\t// Args are: (tooltipItem, data)\n\t\tgetTitle: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me._options;\n\t\t\tvar callbacks = opts.callbacks;\n\n\t\t\tvar beforeTitle = callbacks.beforeTitle.apply(me, arguments);\n\t\t\tvar title = callbacks.title.apply(me, arguments);\n\t\t\tvar afterTitle = callbacks.afterTitle.apply(me, arguments);\n\n\t\t\tvar lines = [];\n\t\t\tlines = pushOrConcat(lines, beforeTitle);\n\t\t\tlines = pushOrConcat(lines, title);\n\t\t\tlines = pushOrConcat(lines, afterTitle);\n\n\t\t\treturn lines;\n\t\t},\n\n\t\t// Args are: (tooltipItem, data)\n\t\tgetBeforeBody: function() {\n\t\t\tvar lines = this._options.callbacks.beforeBody.apply(this, arguments);\n\t\t\treturn helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\n\t\t},\n\n\t\t// Args are: (tooltipItem, data)\n\t\tgetBody: function(tooltipItems, data) {\n\t\t\tvar me = this;\n\t\t\tvar callbacks = me._options.callbacks;\n\t\t\tvar bodyItems = [];\n\n\t\t\thelpers.each(tooltipItems, function(tooltipItem) {\n\t\t\t\tvar bodyItem = {\n\t\t\t\t\tbefore: [],\n\t\t\t\t\tlines: [],\n\t\t\t\t\tafter: []\n\t\t\t\t};\n\t\t\t\tpushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));\n\t\t\t\tpushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));\n\t\t\t\tpushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));\n\n\t\t\t\tbodyItems.push(bodyItem);\n\t\t\t});\n\n\t\t\treturn bodyItems;\n\t\t},\n\n\t\t// Args are: (tooltipItem, data)\n\t\tgetAfterBody: function() {\n\t\t\tvar lines = this._options.callbacks.afterBody.apply(this, arguments);\n\t\t\treturn helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\n\t\t},\n\n\t\t// Get the footer and beforeFooter and afterFooter lines\n\t\t// Args are: (tooltipItem, data)\n\t\tgetFooter: function() {\n\t\t\tvar me = this;\n\t\t\tvar callbacks = me._options.callbacks;\n\n\t\t\tvar beforeFooter = callbacks.beforeFooter.apply(me, arguments);\n\t\t\tvar footer = callbacks.footer.apply(me, arguments);\n\t\t\tvar afterFooter = callbacks.afterFooter.apply(me, arguments);\n\n\t\t\tvar lines = [];\n\t\t\tlines = pushOrConcat(lines, beforeFooter);\n\t\t\tlines = pushOrConcat(lines, footer);\n\t\t\tlines = pushOrConcat(lines, afterFooter);\n\n\t\t\treturn lines;\n\t\t},\n\n\t\tupdate: function(changed) {\n\t\t\tvar me = this;\n\t\t\tvar opts = me._options;\n\n\t\t\t// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition\n\t\t\t// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time\n\t\t\t// which breaks any animations.\n\t\t\tvar existingModel = me._model;\n\t\t\tvar model = me._model = getBaseModel(opts);\n\t\t\tvar active = me._active;\n\n\t\t\tvar data = me._data;\n\n\t\t\t// In the case where active.length === 0 we need to keep these at existing values for good animations\n\t\t\tvar alignment = {\n\t\t\t\txAlign: existingModel.xAlign,\n\t\t\t\tyAlign: existingModel.yAlign\n\t\t\t};\n\t\t\tvar backgroundPoint = {\n\t\t\t\tx: existingModel.x,\n\t\t\t\ty: existingModel.y\n\t\t\t};\n\t\t\tvar tooltipSize = {\n\t\t\t\twidth: existingModel.width,\n\t\t\t\theight: existingModel.height\n\t\t\t};\n\t\t\tvar tooltipPosition = {\n\t\t\t\tx: existingModel.caretX,\n\t\t\t\ty: existingModel.caretY\n\t\t\t};\n\n\t\t\tvar i, len;\n\n\t\t\tif (active.length) {\n\t\t\t\tmodel.opacity = 1;\n\n\t\t\t\tvar labelColors = [];\n\t\t\t\tvar labelTextColors = [];\n\t\t\t\ttooltipPosition = Chart.Tooltip.positioners[opts.position].call(me, active, me._eventPosition);\n\n\t\t\t\tvar tooltipItems = [];\n\t\t\t\tfor (i = 0, len = active.length; i < len; ++i) {\n\t\t\t\t\ttooltipItems.push(createTooltipItem(active[i]));\n\t\t\t\t}\n\n\t\t\t\t// If the user provided a filter function, use it to modify the tooltip items\n\t\t\t\tif (opts.filter) {\n\t\t\t\t\ttooltipItems = tooltipItems.filter(function(a) {\n\t\t\t\t\t\treturn opts.filter(a, data);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// If the user provided a sorting function, use it to modify the tooltip items\n\t\t\t\tif (opts.itemSort) {\n\t\t\t\t\ttooltipItems = tooltipItems.sort(function(a, b) {\n\t\t\t\t\t\treturn opts.itemSort(a, b, data);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Determine colors for boxes\n\t\t\t\thelpers.each(tooltipItems, function(tooltipItem) {\n\t\t\t\t\tlabelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));\n\t\t\t\t\tlabelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));\n\t\t\t\t});\n\n\n\t\t\t\t// Build the Text Lines\n\t\t\t\tmodel.title = me.getTitle(tooltipItems, data);\n\t\t\t\tmodel.beforeBody = me.getBeforeBody(tooltipItems, data);\n\t\t\t\tmodel.body = me.getBody(tooltipItems, data);\n\t\t\t\tmodel.afterBody = me.getAfterBody(tooltipItems, data);\n\t\t\t\tmodel.footer = me.getFooter(tooltipItems, data);\n\n\t\t\t\t// Initial positioning and colors\n\t\t\t\tmodel.x = Math.round(tooltipPosition.x);\n\t\t\t\tmodel.y = Math.round(tooltipPosition.y);\n\t\t\t\tmodel.caretPadding = opts.caretPadding;\n\t\t\t\tmodel.labelColors = labelColors;\n\t\t\t\tmodel.labelTextColors = labelTextColors;\n\n\t\t\t\t// data points\n\t\t\t\tmodel.dataPoints = tooltipItems;\n\n\t\t\t\t// We need to determine alignment of the tooltip\n\t\t\t\ttooltipSize = getTooltipSize(this, model);\n\t\t\t\talignment = determineAlignment(this, tooltipSize);\n\t\t\t\t// Final Size and Position\n\t\t\t\tbackgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);\n\t\t\t} else {\n\t\t\t\tmodel.opacity = 0;\n\t\t\t}\n\n\t\t\tmodel.xAlign = alignment.xAlign;\n\t\t\tmodel.yAlign = alignment.yAlign;\n\t\t\tmodel.x = backgroundPoint.x;\n\t\t\tmodel.y = backgroundPoint.y;\n\t\t\tmodel.width = tooltipSize.width;\n\t\t\tmodel.height = tooltipSize.height;\n\n\t\t\t// Point where the caret on the tooltip points to\n\t\t\tmodel.caretX = tooltipPosition.x;\n\t\t\tmodel.caretY = tooltipPosition.y;\n\n\t\t\tme._model = model;\n\n\t\t\tif (changed && opts.custom) {\n\t\t\t\topts.custom.call(me, model);\n\t\t\t}\n\n\t\t\treturn me;\n\t\t},\n\t\tdrawCaret: function(tooltipPoint, size) {\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar vm = this._view;\n\t\t\tvar caretPosition = this.getCaretPosition(tooltipPoint, size, vm);\n\n\t\t\tctx.lineTo(caretPosition.x1, caretPosition.y1);\n\t\t\tctx.lineTo(caretPosition.x2, caretPosition.y2);\n\t\t\tctx.lineTo(caretPosition.x3, caretPosition.y3);\n\t\t},\n\t\tgetCaretPosition: function(tooltipPoint, size, vm) {\n\t\t\tvar x1, x2, x3, y1, y2, y3;\n\t\t\tvar caretSize = vm.caretSize;\n\t\t\tvar cornerRadius = vm.cornerRadius;\n\t\t\tvar xAlign = vm.xAlign;\n\t\t\tvar yAlign = vm.yAlign;\n\t\t\tvar ptX = tooltipPoint.x;\n\t\t\tvar ptY = tooltipPoint.y;\n\t\t\tvar width = size.width;\n\t\t\tvar height = size.height;\n\n\t\t\tif (yAlign === 'center') {\n\t\t\t\ty2 = ptY + (height / 2);\n\n\t\t\t\tif (xAlign === 'left') {\n\t\t\t\t\tx1 = ptX;\n\t\t\t\t\tx2 = x1 - caretSize;\n\t\t\t\t\tx3 = x1;\n\n\t\t\t\t\ty1 = y2 + caretSize;\n\t\t\t\t\ty3 = y2 - caretSize;\n\t\t\t\t} else {\n\t\t\t\t\tx1 = ptX + width;\n\t\t\t\t\tx2 = x1 + caretSize;\n\t\t\t\t\tx3 = x1;\n\n\t\t\t\t\ty1 = y2 - caretSize;\n\t\t\t\t\ty3 = y2 + caretSize;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (xAlign === 'left') {\n\t\t\t\t\tx2 = ptX + cornerRadius + (caretSize);\n\t\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t} else if (xAlign === 'right') {\n\t\t\t\t\tx2 = ptX + width - cornerRadius - caretSize;\n\t\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t} else {\n\t\t\t\t\tx2 = vm.caretX;\n\t\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t}\n\t\t\t\tif (yAlign === 'top') {\n\t\t\t\t\ty1 = ptY;\n\t\t\t\t\ty2 = y1 - caretSize;\n\t\t\t\t\ty3 = y1;\n\t\t\t\t} else {\n\t\t\t\t\ty1 = ptY + height;\n\t\t\t\t\ty2 = y1 + caretSize;\n\t\t\t\t\ty3 = y1;\n\t\t\t\t\t// invert drawing order\n\t\t\t\t\tvar tmp = x3;\n\t\t\t\t\tx3 = x1;\n\t\t\t\t\tx1 = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3};\n\t\t},\n\t\tdrawTitle: function(pt, vm, ctx, opacity) {\n\t\t\tvar title = vm.title;\n\n\t\t\tif (title.length) {\n\t\t\t\tctx.textAlign = vm._titleAlign;\n\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\tvar titleFontSize = vm.titleFontSize;\n\t\t\t\tvar titleSpacing = vm.titleSpacing;\n\n\t\t\t\tctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);\n\t\t\t\tctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);\n\n\t\t\t\tvar i, len;\n\t\t\t\tfor (i = 0, len = title.length; i < len; ++i) {\n\t\t\t\t\tctx.fillText(title[i], pt.x, pt.y);\n\t\t\t\t\tpt.y += titleFontSize + titleSpacing; // Line Height and spacing\n\n\t\t\t\t\tif (i + 1 === title.length) {\n\t\t\t\t\t\tpt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tdrawBody: function(pt, vm, ctx, opacity) {\n\t\t\tvar bodyFontSize = vm.bodyFontSize;\n\t\t\tvar bodySpacing = vm.bodySpacing;\n\t\t\tvar body = vm.body;\n\n\t\t\tctx.textAlign = vm._bodyAlign;\n\t\t\tctx.textBaseline = 'top';\n\t\t\tctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);\n\n\t\t\t// Before Body\n\t\t\tvar xLinePadding = 0;\n\t\t\tvar fillLineOfText = function(line) {\n\t\t\t\tctx.fillText(line, pt.x + xLinePadding, pt.y);\n\t\t\t\tpt.y += bodyFontSize + bodySpacing;\n\t\t\t};\n\n\t\t\t// Before body lines\n\t\t\tctx.fillStyle = mergeOpacity(vm.bodyFontColor, opacity);\n\t\t\thelpers.each(vm.beforeBody, fillLineOfText);\n\n\t\t\tvar drawColorBoxes = vm.displayColors;\n\t\t\txLinePadding = drawColorBoxes ? (bodyFontSize + 2) : 0;\n\n\t\t\t// Draw body lines now\n\t\t\thelpers.each(body, function(bodyItem, i) {\n\t\t\t\tvar textColor = mergeOpacity(vm.labelTextColors[i], opacity);\n\t\t\t\tctx.fillStyle = textColor;\n\t\t\t\thelpers.each(bodyItem.before, fillLineOfText);\n\n\t\t\t\thelpers.each(bodyItem.lines, function(line) {\n\t\t\t\t\t// Draw Legend-like boxes if needed\n\t\t\t\t\tif (drawColorBoxes) {\n\t\t\t\t\t\t// Fill a white rect so that colours merge nicely if the opacity is < 1\n\t\t\t\t\t\tctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);\n\t\t\t\t\t\tctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\n\n\t\t\t\t\t\t// Border\n\t\t\t\t\t\tctx.lineWidth = 1;\n\t\t\t\t\t\tctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);\n\t\t\t\t\t\tctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\n\n\t\t\t\t\t\t// Inner square\n\t\t\t\t\t\tctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);\n\t\t\t\t\t\tctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\n\t\t\t\t\t\tctx.fillStyle = textColor;\n\t\t\t\t\t}\n\n\t\t\t\t\tfillLineOfText(line);\n\t\t\t\t});\n\n\t\t\t\thelpers.each(bodyItem.after, fillLineOfText);\n\t\t\t});\n\n\t\t\t// Reset back to 0 for after body\n\t\t\txLinePadding = 0;\n\n\t\t\t// After body lines\n\t\t\thelpers.each(vm.afterBody, fillLineOfText);\n\t\t\tpt.y -= bodySpacing; // Remove last body spacing\n\t\t},\n\t\tdrawFooter: function(pt, vm, ctx, opacity) {\n\t\t\tvar footer = vm.footer;\n\n\t\t\tif (footer.length) {\n\t\t\t\tpt.y += vm.footerMarginTop;\n\n\t\t\t\tctx.textAlign = vm._footerAlign;\n\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\tctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);\n\t\t\t\tctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);\n\n\t\t\t\thelpers.each(footer, function(line) {\n\t\t\t\t\tctx.fillText(line, pt.x, pt.y);\n\t\t\t\t\tpt.y += vm.footerFontSize + vm.footerSpacing;\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\tdrawBackground: function(pt, vm, ctx, tooltipSize, opacity) {\n\t\t\tctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);\n\t\t\tctx.strokeStyle = mergeOpacity(vm.borderColor, opacity);\n\t\t\tctx.lineWidth = vm.borderWidth;\n\t\t\tvar xAlign = vm.xAlign;\n\t\t\tvar yAlign = vm.yAlign;\n\t\t\tvar x = pt.x;\n\t\t\tvar y = pt.y;\n\t\t\tvar width = tooltipSize.width;\n\t\t\tvar height = tooltipSize.height;\n\t\t\tvar radius = vm.cornerRadius;\n\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x + radius, y);\n\t\t\tif (yAlign === 'top') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x + width - radius, y);\n\t\t\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n\t\t\tif (yAlign === 'center' && xAlign === 'right') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x + width, y + height - radius);\n\t\t\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n\t\t\tif (yAlign === 'bottom') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x + radius, y + height);\n\t\t\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n\t\t\tif (yAlign === 'center' && xAlign === 'left') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x, y + radius);\n\t\t\tctx.quadraticCurveTo(x, y, x + radius, y);\n\t\t\tctx.closePath();\n\n\t\t\tctx.fill();\n\n\t\t\tif (vm.borderWidth > 0) {\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t},\n\t\tdraw: function() {\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar vm = this._view;\n\n\t\t\tif (vm.opacity === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar tooltipSize = {\n\t\t\t\twidth: vm.width,\n\t\t\t\theight: vm.height\n\t\t\t};\n\t\t\tvar pt = {\n\t\t\t\tx: vm.x,\n\t\t\t\ty: vm.y\n\t\t\t};\n\n\t\t\t// IE11/Edge does not like very small opacities, so snap to 0\n\t\t\tvar opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;\n\n\t\t\t// Truthy/falsey value for empty tooltip\n\t\t\tvar hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;\n\n\t\t\tif (this._options.enabled && hasTooltipContent) {\n\t\t\t\t// Draw Background\n\t\t\t\tthis.drawBackground(pt, vm, ctx, tooltipSize, opacity);\n\n\t\t\t\t// Draw Title, Body, and Footer\n\t\t\t\tpt.x += vm.xPadding;\n\t\t\t\tpt.y += vm.yPadding;\n\n\t\t\t\t// Titles\n\t\t\t\tthis.drawTitle(pt, vm, ctx, opacity);\n\n\t\t\t\t// Body\n\t\t\t\tthis.drawBody(pt, vm, ctx, opacity);\n\n\t\t\t\t// Footer\n\t\t\t\tthis.drawFooter(pt, vm, ctx, opacity);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Handle an event\n\t\t * @private\n\t\t * @param {IEvent} event - The event to handle\n\t\t * @returns {Boolean} true if the tooltip changed\n\t\t */\n\t\thandleEvent: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar options = me._options;\n\t\t\tvar changed = false;\n\n\t\t\tme._lastActive = me._lastActive || [];\n\n\t\t\t// Find Active Elements for tooltips\n\t\t\tif (e.type === 'mouseout') {\n\t\t\t\tme._active = [];\n\t\t\t} else {\n\t\t\t\tme._active = me._chart.getElementsAtEventForMode(e, options.mode, options);\n\t\t\t}\n\n\t\t\t// Remember Last Actives\n\t\t\tchanged = !helpers.arrayEquals(me._active, me._lastActive);\n\n\t\t\t// Only handle target event on tooltip change\n\t\t\tif (changed) {\n\t\t\t\tme._lastActive = me._active;\n\n\t\t\t\tif (options.enabled || options.custom) {\n\t\t\t\t\tme._eventPosition = {\n\t\t\t\t\t\tx: e.x,\n\t\t\t\t\t\ty: e.y\n\t\t\t\t\t};\n\n\t\t\t\t\tme.update(true);\n\t\t\t\t\tme.pivot();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn changed;\n\t\t}\n\t});\n\n\t/**\n\t * @namespace Chart.Tooltip.positioners\n\t */\n\tChart.Tooltip.positioners = {\n\t\t/**\n\t\t * Average mode places the tooltip at the average position of the elements shown\n\t\t * @function Chart.Tooltip.positioners.average\n\t\t * @param elements {ChartElement[]} the elements being displayed in the tooltip\n\t\t * @returns {Point} tooltip position\n\t\t */\n\t\taverage: function(elements) {\n\t\t\tif (!elements.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar i, len;\n\t\t\tvar x = 0;\n\t\t\tvar y = 0;\n\t\t\tvar count = 0;\n\n\t\t\tfor (i = 0, len = elements.length; i < len; ++i) {\n\t\t\t\tvar el = elements[i];\n\t\t\t\tif (el && el.hasValue()) {\n\t\t\t\t\tvar pos = el.tooltipPosition();\n\t\t\t\t\tx += pos.x;\n\t\t\t\t\ty += pos.y;\n\t\t\t\t\t++count;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: Math.round(x / count),\n\t\t\t\ty: Math.round(y / count)\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Gets the tooltip position nearest of the item nearest to the event position\n\t\t * @function Chart.Tooltip.positioners.nearest\n\t\t * @param elements {Chart.Element[]} the tooltip elements\n\t\t * @param eventPosition {Point} the position of the event in canvas coordinates\n\t\t * @returns {Point} the tooltip position\n\t\t */\n\t\tnearest: function(elements, eventPosition) {\n\t\t\tvar x = eventPosition.x;\n\t\t\tvar y = eventPosition.y;\n\t\t\tvar minDistance = Number.POSITIVE_INFINITY;\n\t\t\tvar i, len, nearestElement;\n\n\t\t\tfor (i = 0, len = elements.length; i < len; ++i) {\n\t\t\t\tvar el = elements[i];\n\t\t\t\tif (el && el.hasValue()) {\n\t\t\t\t\tvar center = el.getCenterPoint();\n\t\t\t\t\tvar d = helpers.distanceBetweenPoints(eventPosition, center);\n\n\t\t\t\t\tif (d < minDistance) {\n\t\t\t\t\t\tminDistance = d;\n\t\t\t\t\t\tnearestElement = el;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nearestElement) {\n\t\t\t\tvar tp = nearestElement.tooltipPosition();\n\t\t\t\tx = tp.x;\n\t\t\t\ty = tp.y;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: x,\n\t\t\t\ty: y\n\t\t\t};\n\t\t}\n\t};\n};\n","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar Element = require('../core/core.element');\nvar helpers = require('../helpers/index');\n\ndefaults._set('global', {\n\telements: {\n\t\tarc: {\n\t\t\tbackgroundColor: defaults.global.defaultColor,\n\t\t\tborderColor: '#fff',\n\t\t\tborderWidth: 2\n\t\t}\n\t}\n});\n\nmodule.exports = Element.extend({\n\tinLabelRange: function(mouseX) {\n\t\tvar vm = this._view;\n\n\t\tif (vm) {\n\t\t\treturn (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));\n\t\t}\n\t\treturn false;\n\t},\n\n\tinRange: function(chartX, chartY) {\n\t\tvar vm = this._view;\n\n\t\tif (vm) {\n\t\t\tvar pointRelativePosition = helpers.getAngleFromPoint(vm, {x: chartX, y: chartY});\n\t\t\tvar\tangle = pointRelativePosition.angle;\n\t\t\tvar distance = pointRelativePosition.distance;\n\n\t\t\t// Sanitise angle range\n\t\t\tvar startAngle = vm.startAngle;\n\t\t\tvar endAngle = vm.endAngle;\n\t\t\twhile (endAngle < startAngle) {\n\t\t\t\tendAngle += 2.0 * Math.PI;\n\t\t\t}\n\t\t\twhile (angle > endAngle) {\n\t\t\t\tangle -= 2.0 * Math.PI;\n\t\t\t}\n\t\t\twhile (angle < startAngle) {\n\t\t\t\tangle += 2.0 * Math.PI;\n\t\t\t}\n\n\t\t\t// Check if within the range of the open/close angle\n\t\t\tvar betweenAngles = (angle >= startAngle && angle <= endAngle);\n\t\t\tvar withinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);\n\n\t\t\treturn (betweenAngles && withinRadius);\n\t\t}\n\t\treturn false;\n\t},\n\n\tgetCenterPoint: function() {\n\t\tvar vm = this._view;\n\t\tvar halfAngle = (vm.startAngle + vm.endAngle) / 2;\n\t\tvar halfRadius = (vm.innerRadius + vm.outerRadius) / 2;\n\t\treturn {\n\t\t\tx: vm.x + Math.cos(halfAngle) * halfRadius,\n\t\t\ty: vm.y + Math.sin(halfAngle) * halfRadius\n\t\t};\n\t},\n\n\tgetArea: function() {\n\t\tvar vm = this._view;\n\t\treturn Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));\n\t},\n\n\ttooltipPosition: function() {\n\t\tvar vm = this._view;\n\t\tvar centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2);\n\t\tvar rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;\n\n\t\treturn {\n\t\t\tx: vm.x + (Math.cos(centreAngle) * rangeFromCentre),\n\t\t\ty: vm.y + (Math.sin(centreAngle) * rangeFromCentre)\n\t\t};\n\t},\n\n\tdraw: function() {\n\t\tvar ctx = this._chart.ctx;\n\t\tvar vm = this._view;\n\t\tvar sA = vm.startAngle;\n\t\tvar eA = vm.endAngle;\n\n\t\tctx.beginPath();\n\n\t\tctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);\n\t\tctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);\n\n\t\tctx.closePath();\n\t\tctx.strokeStyle = vm.borderColor;\n\t\tctx.lineWidth = vm.borderWidth;\n\n\t\tctx.fillStyle = vm.backgroundColor;\n\n\t\tctx.fill();\n\t\tctx.lineJoin = 'bevel';\n\n\t\tif (vm.borderWidth) {\n\t\t\tctx.stroke();\n\t\t}\n\t}\n});\n","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar Element = require('../core/core.element');\nvar helpers = require('../helpers/index');\n\nvar globalDefaults = defaults.global;\n\ndefaults._set('global', {\n\telements: {\n\t\tline: {\n\t\t\ttension: 0.4,\n\t\t\tbackgroundColor: globalDefaults.defaultColor,\n\t\t\tborderWidth: 3,\n\t\t\tborderColor: globalDefaults.defaultColor,\n\t\t\tborderCapStyle: 'butt',\n\t\t\tborderDash: [],\n\t\t\tborderDashOffset: 0.0,\n\t\t\tborderJoinStyle: 'miter',\n\t\t\tcapBezierPoints: true,\n\t\t\tfill: true, // do we fill in the area between the line and its base axis\n\t\t}\n\t}\n});\n\nmodule.exports = Element.extend({\n\tdraw: function() {\n\t\tvar me = this;\n\t\tvar vm = me._view;\n\t\tvar ctx = me._chart.ctx;\n\t\tvar spanGaps = vm.spanGaps;\n\t\tvar points = me._children.slice(); // clone array\n\t\tvar globalOptionLineElements = globalDefaults.elements.line;\n\t\tvar lastDrawnIndex = -1;\n\t\tvar index, current, previous, currentVM;\n\n\t\t// If we are looping, adding the first point again\n\t\tif (me._loop && points.length) {\n\t\t\tpoints.push(points[0]);\n\t\t}\n\n\t\tctx.save();\n\n\t\t// Stroke Line Options\n\t\tctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;\n\n\t\t// IE 9 and 10 do not support line dash\n\t\tif (ctx.setLineDash) {\n\t\t\tctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\n\t\t}\n\n\t\tctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;\n\t\tctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\n\t\tctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;\n\t\tctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;\n\n\t\t// Stroke Line\n\t\tctx.beginPath();\n\t\tlastDrawnIndex = -1;\n\n\t\tfor (index = 0; index < points.length; ++index) {\n\t\t\tcurrent = points[index];\n\t\t\tprevious = helpers.previousItem(points, index);\n\t\t\tcurrentVM = current._view;\n\n\t\t\t// First point moves to it's starting position no matter what\n\t\t\tif (index === 0) {\n\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprevious = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n\n\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\tif ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {\n\t\t\t\t\t\t// There was a gap and this is the first point after the gap\n\t\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Line to next point\n\t\t\t\t\t\thelpers.canvas.lineTo(ctx, previous._view, current._view);\n\t\t\t\t\t}\n\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tctx.stroke();\n\t\tctx.restore();\n\t}\n});\n","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar Element = require('../core/core.element');\nvar helpers = require('../helpers/index');\n\nvar defaultColor = defaults.global.defaultColor;\n\ndefaults._set('global', {\n\telements: {\n\t\tpoint: {\n\t\t\tradius: 3,\n\t\t\tpointStyle: 'circle',\n\t\t\tbackgroundColor: defaultColor,\n\t\t\tborderColor: defaultColor,\n\t\t\tborderWidth: 1,\n\t\t\t// Hover\n\t\t\thitRadius: 1,\n\t\t\thoverRadius: 4,\n\t\t\thoverBorderWidth: 1\n\t\t}\n\t}\n});\n\nfunction xRange(mouseX) {\n\tvar vm = this._view;\n\treturn vm ? (Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius) : false;\n}\n\nfunction yRange(mouseY) {\n\tvar vm = this._view;\n\treturn vm ? (Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius) : false;\n}\n\nmodule.exports = Element.extend({\n\tinRange: function(mouseX, mouseY) {\n\t\tvar vm = this._view;\n\t\treturn vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;\n\t},\n\n\tinLabelRange: xRange,\n\tinXRange: xRange,\n\tinYRange: yRange,\n\n\tgetCenterPoint: function() {\n\t\tvar vm = this._view;\n\t\treturn {\n\t\t\tx: vm.x,\n\t\t\ty: vm.y\n\t\t};\n\t},\n\n\tgetArea: function() {\n\t\treturn Math.PI * Math.pow(this._view.radius, 2);\n\t},\n\n\ttooltipPosition: function() {\n\t\tvar vm = this._view;\n\t\treturn {\n\t\t\tx: vm.x,\n\t\t\ty: vm.y,\n\t\t\tpadding: vm.radius + vm.borderWidth\n\t\t};\n\t},\n\n\tdraw: function(chartArea) {\n\t\tvar vm = this._view;\n\t\tvar model = this._model;\n\t\tvar ctx = this._chart.ctx;\n\t\tvar pointStyle = vm.pointStyle;\n\t\tvar radius = vm.radius;\n\t\tvar x = vm.x;\n\t\tvar y = vm.y;\n\t\tvar color = helpers.color;\n\t\tvar errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)\n\t\tvar ratio = 0;\n\n\t\tif (vm.skip) {\n\t\t\treturn;\n\t\t}\n\n\t\tctx.strokeStyle = vm.borderColor || defaultColor;\n\t\tctx.lineWidth = helpers.valueOrDefault(vm.borderWidth, defaults.global.elements.point.borderWidth);\n\t\tctx.fillStyle = vm.backgroundColor || defaultColor;\n\n\t\t// Cliping for Points.\n\t\t// going out from inner charArea?\n\t\tif ((chartArea !== undefined) && ((model.x < chartArea.left) || (chartArea.right * errMargin < model.x) || (model.y < chartArea.top) || (chartArea.bottom * errMargin < model.y))) {\n\t\t\t// Point fade out\n\t\t\tif (model.x < chartArea.left) {\n\t\t\t\tratio = (x - model.x) / (chartArea.left - model.x);\n\t\t\t} else if (chartArea.right * errMargin < model.x) {\n\t\t\t\tratio = (model.x - x) / (model.x - chartArea.right);\n\t\t\t} else if (model.y < chartArea.top) {\n\t\t\t\tratio = (y - model.y) / (chartArea.top - model.y);\n\t\t\t} else if (chartArea.bottom * errMargin < model.y) {\n\t\t\t\tratio = (model.y - y) / (model.y - chartArea.bottom);\n\t\t\t}\n\t\t\tratio = Math.round(ratio * 100) / 100;\n\t\t\tctx.strokeStyle = color(ctx.strokeStyle).alpha(ratio).rgbString();\n\t\t\tctx.fillStyle = color(ctx.fillStyle).alpha(ratio).rgbString();\n\t\t}\n\n\t\thelpers.canvas.drawPoint(ctx, pointStyle, radius, x, y);\n\t}\n});\n","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar Element = require('../core/core.element');\n\ndefaults._set('global', {\n\telements: {\n\t\trectangle: {\n\t\t\tbackgroundColor: defaults.global.defaultColor,\n\t\t\tborderColor: defaults.global.defaultColor,\n\t\t\tborderSkipped: 'bottom',\n\t\t\tborderWidth: 0\n\t\t}\n\t}\n});\n\nfunction isVertical(bar) {\n\treturn bar._view.width !== undefined;\n}\n\n/**\n * Helper function to get the bounds of the bar regardless of the orientation\n * @param bar {Chart.Element.Rectangle} the bar\n * @return {Bounds} bounds of the bar\n * @private\n */\nfunction getBarBounds(bar) {\n\tvar vm = bar._view;\n\tvar x1, x2, y1, y2;\n\n\tif (isVertical(bar)) {\n\t\t// vertical\n\t\tvar halfWidth = vm.width / 2;\n\t\tx1 = vm.x - halfWidth;\n\t\tx2 = vm.x + halfWidth;\n\t\ty1 = Math.min(vm.y, vm.base);\n\t\ty2 = Math.max(vm.y, vm.base);\n\t} else {\n\t\t// horizontal bar\n\t\tvar halfHeight = vm.height / 2;\n\t\tx1 = Math.min(vm.x, vm.base);\n\t\tx2 = Math.max(vm.x, vm.base);\n\t\ty1 = vm.y - halfHeight;\n\t\ty2 = vm.y + halfHeight;\n\t}\n\n\treturn {\n\t\tleft: x1,\n\t\ttop: y1,\n\t\tright: x2,\n\t\tbottom: y2\n\t};\n}\n\nmodule.exports = Element.extend({\n\tdraw: function() {\n\t\tvar ctx = this._chart.ctx;\n\t\tvar vm = this._view;\n\t\tvar left, right, top, bottom, signX, signY, borderSkipped;\n\t\tvar borderWidth = vm.borderWidth;\n\n\t\tif (!vm.horizontal) {\n\t\t\t// bar\n\t\t\tleft = vm.x - vm.width / 2;\n\t\t\tright = vm.x + vm.width / 2;\n\t\t\ttop = vm.y;\n\t\t\tbottom = vm.base;\n\t\t\tsignX = 1;\n\t\t\tsignY = bottom > top ? 1 : -1;\n\t\t\tborderSkipped = vm.borderSkipped || 'bottom';\n\t\t} else {\n\t\t\t// horizontal bar\n\t\t\tleft = vm.base;\n\t\t\tright = vm.x;\n\t\t\ttop = vm.y - vm.height / 2;\n\t\t\tbottom = vm.y + vm.height / 2;\n\t\t\tsignX = right > left ? 1 : -1;\n\t\t\tsignY = 1;\n\t\t\tborderSkipped = vm.borderSkipped || 'left';\n\t\t}\n\n\t\t// Canvas doesn't allow us to stroke inside the width so we can\n\t\t// adjust the sizes to fit if we're setting a stroke on the line\n\t\tif (borderWidth) {\n\t\t\t// borderWidth shold be less than bar width and bar height.\n\t\t\tvar barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));\n\t\t\tborderWidth = borderWidth > barSize ? barSize : borderWidth;\n\t\t\tvar halfStroke = borderWidth / 2;\n\t\t\t// Adjust borderWidth when bar top position is near vm.base(zero).\n\t\t\tvar borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);\n\t\t\tvar borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);\n\t\t\tvar borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);\n\t\t\tvar borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0);\n\t\t\t// not become a vertical line?\n\t\t\tif (borderLeft !== borderRight) {\n\t\t\t\ttop = borderTop;\n\t\t\t\tbottom = borderBottom;\n\t\t\t}\n\t\t\t// not become a horizontal line?\n\t\t\tif (borderTop !== borderBottom) {\n\t\t\t\tleft = borderLeft;\n\t\t\t\tright = borderRight;\n\t\t\t}\n\t\t}\n\n\t\tctx.beginPath();\n\t\tctx.fillStyle = vm.backgroundColor;\n\t\tctx.strokeStyle = vm.borderColor;\n\t\tctx.lineWidth = borderWidth;\n\n\t\t// Corner points, from bottom-left to bottom-right clockwise\n\t\t// | 1 2 |\n\t\t// | 0 3 |\n\t\tvar corners = [\n\t\t\t[left, bottom],\n\t\t\t[left, top],\n\t\t\t[right, top],\n\t\t\t[right, bottom]\n\t\t];\n\n\t\t// Find first (starting) corner with fallback to 'bottom'\n\t\tvar borders = ['bottom', 'left', 'top', 'right'];\n\t\tvar startCorner = borders.indexOf(borderSkipped, 0);\n\t\tif (startCorner === -1) {\n\t\t\tstartCorner = 0;\n\t\t}\n\n\t\tfunction cornerAt(index) {\n\t\t\treturn corners[(startCorner + index) % 4];\n\t\t}\n\n\t\t// Draw rectangle from 'startCorner'\n\t\tvar corner = cornerAt(0);\n\t\tctx.moveTo(corner[0], corner[1]);\n\n\t\tfor (var i = 1; i < 4; i++) {\n\t\t\tcorner = cornerAt(i);\n\t\t\tctx.lineTo(corner[0], corner[1]);\n\t\t}\n\n\t\tctx.fill();\n\t\tif (borderWidth) {\n\t\t\tctx.stroke();\n\t\t}\n\t},\n\n\theight: function() {\n\t\tvar vm = this._view;\n\t\treturn vm.base - vm.y;\n\t},\n\n\tinRange: function(mouseX, mouseY) {\n\t\tvar inRange = false;\n\n\t\tif (this._view) {\n\t\t\tvar bounds = getBarBounds(this);\n\t\t\tinRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t}\n\n\t\treturn inRange;\n\t},\n\n\tinLabelRange: function(mouseX, mouseY) {\n\t\tvar me = this;\n\t\tif (!me._view) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar inRange = false;\n\t\tvar bounds = getBarBounds(me);\n\n\t\tif (isVertical(me)) {\n\t\t\tinRange = mouseX >= bounds.left && mouseX <= bounds.right;\n\t\t} else {\n\t\t\tinRange = mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t}\n\n\t\treturn inRange;\n\t},\n\n\tinXRange: function(mouseX) {\n\t\tvar bounds = getBarBounds(this);\n\t\treturn mouseX >= bounds.left && mouseX <= bounds.right;\n\t},\n\n\tinYRange: function(mouseY) {\n\t\tvar bounds = getBarBounds(this);\n\t\treturn mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t},\n\n\tgetCenterPoint: function() {\n\t\tvar vm = this._view;\n\t\tvar x, y;\n\t\tif (isVertical(this)) {\n\t\t\tx = vm.x;\n\t\t\ty = (vm.y + vm.base) / 2;\n\t\t} else {\n\t\t\tx = (vm.x + vm.base) / 2;\n\t\t\ty = vm.y;\n\t\t}\n\n\t\treturn {x: x, y: y};\n\t},\n\n\tgetArea: function() {\n\t\tvar vm = this._view;\n\t\treturn vm.width * Math.abs(vm.y - vm.base);\n\t},\n\n\ttooltipPosition: function() {\n\t\tvar vm = this._view;\n\t\treturn {\n\t\t\tx: vm.x,\n\t\t\ty: vm.y\n\t\t};\n\t}\n});\n","'use strict';\n\nmodule.exports = {};\nmodule.exports.Arc = require('./element.arc');\nmodule.exports.Line = require('./element.line');\nmodule.exports.Point = require('./element.point');\nmodule.exports.Rectangle = require('./element.rectangle');\n","'use strict';\n\nvar helpers = require('./helpers.core');\n\n/**\n * @namespace Chart.helpers.canvas\n */\nvar exports = module.exports = {\n\t/**\n\t * Clears the entire canvas associated to the given `chart`.\n\t * @param {Chart} chart - The chart for which to clear the canvas.\n\t */\n\tclear: function(chart) {\n\t\tchart.ctx.clearRect(0, 0, chart.width, chart.height);\n\t},\n\n\t/**\n\t * Creates a \"path\" for a rectangle with rounded corners at position (x, y) with a\n\t * given size (width, height) and the same `radius` for all corners.\n\t * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.\n\t * @param {Number} x - The x axis of the coordinate for the rectangle starting point.\n\t * @param {Number} y - The y axis of the coordinate for the rectangle starting point.\n\t * @param {Number} width - The rectangle's width.\n\t * @param {Number} height - The rectangle's height.\n\t * @param {Number} radius - The rounded amount (in pixels) for the four corners.\n\t * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?\n\t */\n\troundedRect: function(ctx, x, y, width, height, radius) {\n\t\tif (radius) {\n\t\t\tvar rx = Math.min(radius, width / 2);\n\t\t\tvar ry = Math.min(radius, height / 2);\n\n\t\t\tctx.moveTo(x + rx, y);\n\t\t\tctx.lineTo(x + width - rx, y);\n\t\t\tctx.quadraticCurveTo(x + width, y, x + width, y + ry);\n\t\t\tctx.lineTo(x + width, y + height - ry);\n\t\t\tctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height);\n\t\t\tctx.lineTo(x + rx, y + height);\n\t\t\tctx.quadraticCurveTo(x, y + height, x, y + height - ry);\n\t\t\tctx.lineTo(x, y + ry);\n\t\t\tctx.quadraticCurveTo(x, y, x + rx, y);\n\t\t} else {\n\t\t\tctx.rect(x, y, width, height);\n\t\t}\n\t},\n\n\tdrawPoint: function(ctx, style, radius, x, y) {\n\t\tvar type, edgeLength, xOffset, yOffset, height, size;\n\n\t\tif (style && typeof style === 'object') {\n\t\t\ttype = style.toString();\n\t\t\tif (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n\t\t\t\tctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (isNaN(radius) || radius <= 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (style) {\n\t\t// Default includes circle\n\t\tdefault:\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(x, y, radius, 0, Math.PI * 2);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'triangle':\n\t\t\tctx.beginPath();\n\t\t\tedgeLength = 3 * radius / Math.sqrt(3);\n\t\t\theight = edgeLength * Math.sqrt(3) / 2;\n\t\t\tctx.moveTo(x - edgeLength / 2, y + height / 3);\n\t\t\tctx.lineTo(x + edgeLength / 2, y + height / 3);\n\t\t\tctx.lineTo(x, y - 2 * height / 3);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'rect':\n\t\t\tsize = 1 / Math.SQRT2 * radius;\n\t\t\tctx.beginPath();\n\t\t\tctx.fillRect(x - size, y - size, 2 * size, 2 * size);\n\t\t\tctx.strokeRect(x - size, y - size, 2 * size, 2 * size);\n\t\t\tbreak;\n\t\tcase 'rectRounded':\n\t\t\tvar offset = radius / Math.SQRT2;\n\t\t\tvar leftX = x - offset;\n\t\t\tvar topY = y - offset;\n\t\t\tvar sideSize = Math.SQRT2 * radius;\n\t\t\tctx.beginPath();\n\t\t\tthis.roundedRect(ctx, leftX, topY, sideSize, sideSize, radius / 2);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'rectRot':\n\t\t\tsize = 1 / Math.SQRT2 * radius;\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x - size, y);\n\t\t\tctx.lineTo(x, y + size);\n\t\t\tctx.lineTo(x + size, y);\n\t\t\tctx.lineTo(x, y - size);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'cross':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, y + radius);\n\t\t\tctx.lineTo(x, y - radius);\n\t\t\tctx.moveTo(x - radius, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'crossRot':\n\t\t\tctx.beginPath();\n\t\t\txOffset = Math.cos(Math.PI / 4) * radius;\n\t\t\tyOffset = Math.sin(Math.PI / 4) * radius;\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\tctx.moveTo(x - xOffset, y + yOffset);\n\t\t\tctx.lineTo(x + xOffset, y - yOffset);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'star':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, y + radius);\n\t\t\tctx.lineTo(x, y - radius);\n\t\t\tctx.moveTo(x - radius, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\txOffset = Math.cos(Math.PI / 4) * radius;\n\t\t\tyOffset = Math.sin(Math.PI / 4) * radius;\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\tctx.moveTo(x - xOffset, y + yOffset);\n\t\t\tctx.lineTo(x + xOffset, y - yOffset);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'line':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x - radius, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'dash':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\t}\n\n\t\tctx.stroke();\n\t},\n\n\tclipArea: function(ctx, area) {\n\t\tctx.save();\n\t\tctx.beginPath();\n\t\tctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n\t\tctx.clip();\n\t},\n\n\tunclipArea: function(ctx) {\n\t\tctx.restore();\n\t},\n\n\tlineTo: function(ctx, previous, target, flip) {\n\t\tif (target.steppedLine) {\n\t\t\tif ((target.steppedLine === 'after' && !flip) || (target.steppedLine !== 'after' && flip)) {\n\t\t\t\tctx.lineTo(previous.x, target.y);\n\t\t\t} else {\n\t\t\t\tctx.lineTo(target.x, previous.y);\n\t\t\t}\n\t\t\tctx.lineTo(target.x, target.y);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!target.tension) {\n\t\t\tctx.lineTo(target.x, target.y);\n\t\t\treturn;\n\t\t}\n\n\t\tctx.bezierCurveTo(\n\t\t\tflip ? previous.controlPointPreviousX : previous.controlPointNextX,\n\t\t\tflip ? previous.controlPointPreviousY : previous.controlPointNextY,\n\t\t\tflip ? target.controlPointNextX : target.controlPointPreviousX,\n\t\t\tflip ? target.controlPointNextY : target.controlPointPreviousY,\n\t\t\ttarget.x,\n\t\t\ttarget.y);\n\t}\n};\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.\n * @namespace Chart.helpers.clear\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.clear = exports.clear;\n\n/**\n * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.\n * @namespace Chart.helpers.drawRoundedRectangle\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.drawRoundedRectangle = function(ctx) {\n\tctx.beginPath();\n\texports.roundedRect.apply(exports, arguments);\n\tctx.closePath();\n};\n","'use strict';\n\n/**\n * @namespace Chart.helpers\n */\nvar helpers = {\n\t/**\n\t * An empty function that can be used, for example, for optional callback.\n\t */\n\tnoop: function() {},\n\n\t/**\n\t * Returns a unique id, sequentially generated from a global variable.\n\t * @returns {Number}\n\t * @function\n\t */\n\tuid: (function() {\n\t\tvar id = 0;\n\t\treturn function() {\n\t\t\treturn id++;\n\t\t};\n\t}()),\n\n\t/**\n\t * Returns true if `value` is neither null nor undefined, else returns false.\n\t * @param {*} value - The value to test.\n\t * @returns {Boolean}\n\t * @since 2.7.0\n\t */\n\tisNullOrUndef: function(value) {\n\t\treturn value === null || typeof value === 'undefined';\n\t},\n\n\t/**\n\t * Returns true if `value` is an array, else returns false.\n\t * @param {*} value - The value to test.\n\t * @returns {Boolean}\n\t * @function\n\t */\n\tisArray: Array.isArray ? Array.isArray : function(value) {\n\t\treturn Object.prototype.toString.call(value) === '[object Array]';\n\t},\n\n\t/**\n\t * Returns true if `value` is an object (excluding null), else returns false.\n\t * @param {*} value - The value to test.\n\t * @returns {Boolean}\n\t * @since 2.7.0\n\t */\n\tisObject: function(value) {\n\t\treturn value !== null && Object.prototype.toString.call(value) === '[object Object]';\n\t},\n\n\t/**\n\t * Returns `value` if defined, else returns `defaultValue`.\n\t * @param {*} value - The value to return if defined.\n\t * @param {*} defaultValue - The value to return if `value` is undefined.\n\t * @returns {*}\n\t */\n\tvalueOrDefault: function(value, defaultValue) {\n\t\treturn typeof value === 'undefined' ? defaultValue : value;\n\t},\n\n\t/**\n\t * Returns value at the given `index` in array if defined, else returns `defaultValue`.\n\t * @param {Array} value - The array to lookup for value at `index`.\n\t * @param {Number} index - The index in `value` to lookup for value.\n\t * @param {*} defaultValue - The value to return if `value[index]` is undefined.\n\t * @returns {*}\n\t */\n\tvalueAtIndexOrDefault: function(value, index, defaultValue) {\n\t\treturn helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);\n\t},\n\n\t/**\n\t * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n\t * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n\t * @param {Function} fn - The function to call.\n\t * @param {Array|undefined|null} args - The arguments with which `fn` should be called.\n\t * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.\n\t * @returns {*}\n\t */\n\tcallback: function(fn, args, thisArg) {\n\t\tif (fn && typeof fn.call === 'function') {\n\t\t\treturn fn.apply(thisArg, args);\n\t\t}\n\t},\n\n\t/**\n\t * Note(SB) for performance sake, this method should only be used when loopable type\n\t * is unknown or in none intensive code (not called often and small loopable). Else\n\t * it's preferable to use a regular for() loop and save extra function calls.\n\t * @param {Object|Array} loopable - The object or array to be iterated.\n\t * @param {Function} fn - The function to call for each item.\n\t * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.\n\t * @param {Boolean} [reverse] - If true, iterates backward on the loopable.\n\t */\n\teach: function(loopable, fn, thisArg, reverse) {\n\t\tvar i, len, keys;\n\t\tif (helpers.isArray(loopable)) {\n\t\t\tlen = loopable.length;\n\t\t\tif (reverse) {\n\t\t\t\tfor (i = len - 1; i >= 0; i--) {\n\t\t\t\t\tfn.call(thisArg, loopable[i], i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tfn.call(thisArg, loopable[i], i);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (helpers.isObject(loopable)) {\n\t\t\tkeys = Object.keys(loopable);\n\t\t\tlen = keys.length;\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tfn.call(thisArg, loopable[keys[i]], keys[i]);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n\t * @see http://stackoverflow.com/a/14853974\n\t * @param {Array} a0 - The array to compare\n\t * @param {Array} a1 - The array to compare\n\t * @returns {Boolean}\n\t */\n\tarrayEquals: function(a0, a1) {\n\t\tvar i, ilen, v0, v1;\n\n\t\tif (!a0 || !a1 || a0.length !== a1.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (i = 0, ilen = a0.length; i < ilen; ++i) {\n\t\t\tv0 = a0[i];\n\t\t\tv1 = a1[i];\n\n\t\t\tif (v0 instanceof Array && v1 instanceof Array) {\n\t\t\t\tif (!helpers.arrayEquals(v0, v1)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if (v0 !== v1) {\n\t\t\t\t// NOTE: two different object instances will never be equal: {x:20} != {x:20}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/**\n\t * Returns a deep copy of `source` without keeping references on objects and arrays.\n\t * @param {*} source - The value to clone.\n\t * @returns {*}\n\t */\n\tclone: function(source) {\n\t\tif (helpers.isArray(source)) {\n\t\t\treturn source.map(helpers.clone);\n\t\t}\n\n\t\tif (helpers.isObject(source)) {\n\t\t\tvar target = {};\n\t\t\tvar keys = Object.keys(source);\n\t\t\tvar klen = keys.length;\n\t\t\tvar k = 0;\n\n\t\t\tfor (; k < klen; ++k) {\n\t\t\t\ttarget[keys[k]] = helpers.clone(source[keys[k]]);\n\t\t\t}\n\n\t\t\treturn target;\n\t\t}\n\n\t\treturn source;\n\t},\n\n\t/**\n\t * The default merger when Chart.helpers.merge is called without merger option.\n\t * Note(SB): this method is also used by configMerge and scaleMerge as fallback.\n\t * @private\n\t */\n\t_merger: function(key, target, source, options) {\n\t\tvar tval = target[key];\n\t\tvar sval = source[key];\n\n\t\tif (helpers.isObject(tval) && helpers.isObject(sval)) {\n\t\t\thelpers.merge(tval, sval, options);\n\t\t} else {\n\t\t\ttarget[key] = helpers.clone(sval);\n\t\t}\n\t},\n\n\t/**\n\t * Merges source[key] in target[key] only if target[key] is undefined.\n\t * @private\n\t */\n\t_mergerIf: function(key, target, source) {\n\t\tvar tval = target[key];\n\t\tvar sval = source[key];\n\n\t\tif (helpers.isObject(tval) && helpers.isObject(sval)) {\n\t\t\thelpers.mergeIf(tval, sval);\n\t\t} else if (!target.hasOwnProperty(key)) {\n\t\t\ttarget[key] = helpers.clone(sval);\n\t\t}\n\t},\n\n\t/**\n\t * Recursively deep copies `source` properties into `target` with the given `options`.\n\t * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n\t * @param {Object} target - The target object in which all sources are merged into.\n\t * @param {Object|Array(Object)} source - Object(s) to merge into `target`.\n\t * @param {Object} [options] - Merging options:\n\t * @param {Function} [options.merger] - The merge method (key, target, source, options)\n\t * @returns {Object} The `target` object.\n\t */\n\tmerge: function(target, source, options) {\n\t\tvar sources = helpers.isArray(source) ? source : [source];\n\t\tvar ilen = sources.length;\n\t\tvar merge, i, keys, klen, k;\n\n\t\tif (!helpers.isObject(target)) {\n\t\t\treturn target;\n\t\t}\n\n\t\toptions = options || {};\n\t\tmerge = options.merger || helpers._merger;\n\n\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\tsource = sources[i];\n\t\t\tif (!helpers.isObject(source)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tkeys = Object.keys(source);\n\t\t\tfor (k = 0, klen = keys.length; k < klen; ++k) {\n\t\t\t\tmerge(keys[k], target, source, options);\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t},\n\n\t/**\n\t * Recursively deep copies `source` properties into `target` *only* if not defined in target.\n\t * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n\t * @param {Object} target - The target object in which all sources are merged into.\n\t * @param {Object|Array(Object)} source - Object(s) to merge into `target`.\n\t * @returns {Object} The `target` object.\n\t */\n\tmergeIf: function(target, source) {\n\t\treturn helpers.merge(target, source, {merger: helpers._mergerIf});\n\t},\n\n\t/**\n\t * Applies the contents of two or more objects together into the first object.\n\t * @param {Object} target - The target object in which all objects are merged into.\n\t * @param {Object} arg1 - Object containing additional properties to merge in target.\n\t * @param {Object} argN - Additional objects containing properties to merge in target.\n\t * @returns {Object} The `target` object.\n\t */\n\textend: function(target) {\n\t\tvar setFn = function(value, key) {\n\t\t\ttarget[key] = value;\n\t\t};\n\t\tfor (var i = 1, ilen = arguments.length; i < ilen; ++i) {\n\t\t\thelpers.each(arguments[i], setFn);\n\t\t}\n\t\treturn target;\n\t},\n\n\t/**\n\t * Basic javascript inheritance based on the model created in Backbone.js\n\t */\n\tinherits: function(extensions) {\n\t\tvar me = this;\n\t\tvar ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {\n\t\t\treturn me.apply(this, arguments);\n\t\t};\n\n\t\tvar Surrogate = function() {\n\t\t\tthis.constructor = ChartElement;\n\t\t};\n\n\t\tSurrogate.prototype = me.prototype;\n\t\tChartElement.prototype = new Surrogate();\n\t\tChartElement.extend = helpers.inherits;\n\n\t\tif (extensions) {\n\t\t\thelpers.extend(ChartElement.prototype, extensions);\n\t\t}\n\n\t\tChartElement.__super__ = me.prototype;\n\t\treturn ChartElement;\n\t}\n};\n\nmodule.exports = helpers;\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, use Chart.helpers.callback instead.\n * @function Chart.helpers.callCallback\n * @deprecated since version 2.6.0\n * @todo remove at version 3\n * @private\n */\nhelpers.callCallback = helpers.callback;\n\n/**\n * Provided for backward compatibility, use Array.prototype.indexOf instead.\n * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+\n * @function Chart.helpers.indexOf\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.indexOf = function(array, item, fromIndex) {\n\treturn Array.prototype.indexOf.call(array, item, fromIndex);\n};\n\n/**\n * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.\n * @function Chart.helpers.getValueOrDefault\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.getValueOrDefault = helpers.valueOrDefault;\n\n/**\n * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.\n * @function Chart.helpers.getValueAtIndexOrDefault\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n","'use strict';\n\nvar helpers = require('./helpers.core');\n\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easingEffects\n * @see http://www.robertpenner.com/easing/\n */\nvar effects = {\n\tlinear: function(t) {\n\t\treturn t;\n\t},\n\n\teaseInQuad: function(t) {\n\t\treturn t * t;\n\t},\n\n\teaseOutQuad: function(t) {\n\t\treturn -t * (t - 2);\n\t},\n\n\teaseInOutQuad: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * t * t;\n\t\t}\n\t\treturn -0.5 * ((--t) * (t - 2) - 1);\n\t},\n\n\teaseInCubic: function(t) {\n\t\treturn t * t * t;\n\t},\n\n\teaseOutCubic: function(t) {\n\t\treturn (t = t - 1) * t * t + 1;\n\t},\n\n\teaseInOutCubic: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * t * t * t;\n\t\t}\n\t\treturn 0.5 * ((t -= 2) * t * t + 2);\n\t},\n\n\teaseInQuart: function(t) {\n\t\treturn t * t * t * t;\n\t},\n\n\teaseOutQuart: function(t) {\n\t\treturn -((t = t - 1) * t * t * t - 1);\n\t},\n\n\teaseInOutQuart: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * t * t * t * t;\n\t\t}\n\t\treturn -0.5 * ((t -= 2) * t * t * t - 2);\n\t},\n\n\teaseInQuint: function(t) {\n\t\treturn t * t * t * t * t;\n\t},\n\n\teaseOutQuint: function(t) {\n\t\treturn (t = t - 1) * t * t * t * t + 1;\n\t},\n\n\teaseInOutQuint: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * t * t * t * t * t;\n\t\t}\n\t\treturn 0.5 * ((t -= 2) * t * t * t * t + 2);\n\t},\n\n\teaseInSine: function(t) {\n\t\treturn -Math.cos(t * (Math.PI / 2)) + 1;\n\t},\n\n\teaseOutSine: function(t) {\n\t\treturn Math.sin(t * (Math.PI / 2));\n\t},\n\n\teaseInOutSine: function(t) {\n\t\treturn -0.5 * (Math.cos(Math.PI * t) - 1);\n\t},\n\n\teaseInExpo: function(t) {\n\t\treturn (t === 0) ? 0 : Math.pow(2, 10 * (t - 1));\n\t},\n\n\teaseOutExpo: function(t) {\n\t\treturn (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1;\n\t},\n\n\teaseInOutExpo: function(t) {\n\t\tif (t === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (t === 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * Math.pow(2, 10 * (t - 1));\n\t\t}\n\t\treturn 0.5 * (-Math.pow(2, -10 * --t) + 2);\n\t},\n\n\teaseInCirc: function(t) {\n\t\tif (t >= 1) {\n\t\t\treturn t;\n\t\t}\n\t\treturn -(Math.sqrt(1 - t * t) - 1);\n\t},\n\n\teaseOutCirc: function(t) {\n\t\treturn Math.sqrt(1 - (t = t - 1) * t);\n\t},\n\n\teaseInOutCirc: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn -0.5 * (Math.sqrt(1 - t * t) - 1);\n\t\t}\n\t\treturn 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n\t},\n\n\teaseInElastic: function(t) {\n\t\tvar s = 1.70158;\n\t\tvar p = 0;\n\t\tvar a = 1;\n\t\tif (t === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (t === 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (!p) {\n\t\t\tp = 0.3;\n\t\t}\n\t\tif (a < 1) {\n\t\t\ta = 1;\n\t\t\ts = p / 4;\n\t\t} else {\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t}\n\t\treturn -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\n\t},\n\n\teaseOutElastic: function(t) {\n\t\tvar s = 1.70158;\n\t\tvar p = 0;\n\t\tvar a = 1;\n\t\tif (t === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (t === 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (!p) {\n\t\t\tp = 0.3;\n\t\t}\n\t\tif (a < 1) {\n\t\t\ta = 1;\n\t\t\ts = p / 4;\n\t\t} else {\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t}\n\t\treturn a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;\n\t},\n\n\teaseInOutElastic: function(t) {\n\t\tvar s = 1.70158;\n\t\tvar p = 0;\n\t\tvar a = 1;\n\t\tif (t === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif ((t /= 0.5) === 2) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (!p) {\n\t\t\tp = 0.45;\n\t\t}\n\t\tif (a < 1) {\n\t\t\ta = 1;\n\t\t\ts = p / 4;\n\t\t} else {\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t}\n\t\tif (t < 1) {\n\t\t\treturn -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\n\t\t}\n\t\treturn a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t},\n\teaseInBack: function(t) {\n\t\tvar s = 1.70158;\n\t\treturn t * t * ((s + 1) * t - s);\n\t},\n\n\teaseOutBack: function(t) {\n\t\tvar s = 1.70158;\n\t\treturn (t = t - 1) * t * ((s + 1) * t + s) + 1;\n\t},\n\n\teaseInOutBack: function(t) {\n\t\tvar s = 1.70158;\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n\t\t}\n\t\treturn 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n\t},\n\n\teaseInBounce: function(t) {\n\t\treturn 1 - effects.easeOutBounce(1 - t);\n\t},\n\n\teaseOutBounce: function(t) {\n\t\tif (t < (1 / 2.75)) {\n\t\t\treturn 7.5625 * t * t;\n\t\t}\n\t\tif (t < (2 / 2.75)) {\n\t\t\treturn 7.5625 * (t -= (1.5 / 2.75)) * t + 0.75;\n\t\t}\n\t\tif (t < (2.5 / 2.75)) {\n\t\t\treturn 7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375;\n\t\t}\n\t\treturn 7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375;\n\t},\n\n\teaseInOutBounce: function(t) {\n\t\tif (t < 0.5) {\n\t\t\treturn effects.easeInBounce(t * 2) * 0.5;\n\t\t}\n\t\treturn effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;\n\t}\n};\n\nmodule.exports = {\n\teffects: effects\n};\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, use Chart.helpers.easing.effects instead.\n * @function Chart.helpers.easingEffects\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.easingEffects = effects;\n","'use strict';\n\nvar helpers = require('./helpers.core');\n\n/**\n * @alias Chart.helpers.options\n * @namespace\n */\nmodule.exports = {\n\t/**\n\t * Converts the given line height `value` in pixels for a specific font `size`.\n\t * @param {Number|String} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n\t * @param {Number} size - The font size (in pixels) used to resolve relative `value`.\n\t * @returns {Number} The effective line height in pixels (size * 1.2 if value is invalid).\n\t * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n\t * @since 2.7.0\n\t */\n\ttoLineHeight: function(value, size) {\n\t\tvar matches = ('' + value).match(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\n\t\tif (!matches || matches[1] === 'normal') {\n\t\t\treturn size * 1.2;\n\t\t}\n\n\t\tvalue = +matches[2];\n\n\t\tswitch (matches[3]) {\n\t\tcase 'px':\n\t\t\treturn value;\n\t\tcase '%':\n\t\t\tvalue /= 100;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\treturn size * value;\n\t},\n\n\t/**\n\t * Converts the given value into a padding object with pre-computed width/height.\n\t * @param {Number|Object} value - If a number, set the value to all TRBL component,\n\t *  else, if and object, use defined properties and sets undefined ones to 0.\n\t * @returns {Object} The padding values (top, right, bottom, left, width, height)\n\t * @since 2.7.0\n\t */\n\ttoPadding: function(value) {\n\t\tvar t, r, b, l;\n\n\t\tif (helpers.isObject(value)) {\n\t\t\tt = +value.top || 0;\n\t\t\tr = +value.right || 0;\n\t\t\tb = +value.bottom || 0;\n\t\t\tl = +value.left || 0;\n\t\t} else {\n\t\t\tt = r = b = l = +value || 0;\n\t\t}\n\n\t\treturn {\n\t\t\ttop: t,\n\t\t\tright: r,\n\t\t\tbottom: b,\n\t\t\tleft: l,\n\t\t\theight: t + b,\n\t\t\twidth: l + r\n\t\t};\n\t},\n\n\t/**\n\t * Evaluates the given `inputs` sequentially and returns the first defined value.\n\t * @param {Array[]} inputs - An array of values, falling back to the last value.\n\t * @param {Object} [context] - If defined and the current value is a function, the value\n\t * is called with `context` as first argument and the result becomes the new input.\n\t * @param {Number} [index] - If defined and the current value is an array, the value\n\t * at `index` become the new input.\n\t * @since 2.7.0\n\t */\n\tresolve: function(inputs, context, index) {\n\t\tvar i, ilen, value;\n\n\t\tfor (i = 0, ilen = inputs.length; i < ilen; ++i) {\n\t\t\tvalue = inputs[i];\n\t\t\tif (value === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (context !== undefined && typeof value === 'function') {\n\t\t\t\tvalue = value(context);\n\t\t\t}\n\t\t\tif (index !== undefined && helpers.isArray(value)) {\n\t\t\t\tvalue = value[index];\n\t\t\t}\n\t\t\tif (value !== undefined) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t}\n};\n","'use strict';\n\nmodule.exports = require('./helpers.core');\nmodule.exports.easing = require('./helpers.easing');\nmodule.exports.canvas = require('./helpers.canvas');\nmodule.exports.options = require('./helpers.options');\n","/**\n * Platform fallback implementation (minimal).\n * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939\n */\n\nmodule.exports = {\n\tacquireContext: function(item) {\n\t\tif (item && item.canvas) {\n\t\t\t// Support for any object associated to a canvas (including a context2d)\n\t\t\titem = item.canvas;\n\t\t}\n\n\t\treturn item && item.getContext('2d') || null;\n\t}\n};\n","/**\n * Chart.Platform implementation for targeting a web browser\n */\n\n'use strict';\n\nvar helpers = require('../helpers/index');\n\nvar EXPANDO_KEY = '$chartjs';\nvar CSS_PREFIX = 'chartjs-';\nvar CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';\nvar CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';\nvar ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];\n\n/**\n * DOM event types -> Chart.js event types.\n * Note: only events with different types are mapped.\n * @see https://developer.mozilla.org/en-US/docs/Web/Events\n */\nvar EVENT_TYPES = {\n\ttouchstart: 'mousedown',\n\ttouchmove: 'mousemove',\n\ttouchend: 'mouseup',\n\tpointerenter: 'mouseenter',\n\tpointerdown: 'mousedown',\n\tpointermove: 'mousemove',\n\tpointerup: 'mouseup',\n\tpointerleave: 'mouseout',\n\tpointerout: 'mouseout'\n};\n\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns {Number} Size in pixels or undefined if unknown.\n */\nfunction readUsedSize(element, property) {\n\tvar value = helpers.getStyle(element, property);\n\tvar matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n\treturn matches ? Number(matches[1]) : undefined;\n}\n\n/**\n * Initializes the canvas style and render size without modifying the canvas display size,\n * since responsiveness is handled by the controller.resize() method. The config is used\n * to determine the aspect ratio to apply in case no explicit height has been specified.\n */\nfunction initCanvas(canvas, config) {\n\tvar style = canvas.style;\n\n\t// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\n\t// returns null or '' if no explicit value has been set to the canvas attribute.\n\tvar renderHeight = canvas.getAttribute('height');\n\tvar renderWidth = canvas.getAttribute('width');\n\n\t// Chart.js modifies some canvas values that we want to restore on destroy\n\tcanvas[EXPANDO_KEY] = {\n\t\tinitial: {\n\t\t\theight: renderHeight,\n\t\t\twidth: renderWidth,\n\t\t\tstyle: {\n\t\t\t\tdisplay: style.display,\n\t\t\t\theight: style.height,\n\t\t\t\twidth: style.width\n\t\t\t}\n\t\t}\n\t};\n\n\t// Force canvas to display as block to avoid extra space caused by inline\n\t// elements, which would interfere with the responsive resize process.\n\t// https://github.com/chartjs/Chart.js/issues/2538\n\tstyle.display = style.display || 'block';\n\n\tif (renderWidth === null || renderWidth === '') {\n\t\tvar displayWidth = readUsedSize(canvas, 'width');\n\t\tif (displayWidth !== undefined) {\n\t\t\tcanvas.width = displayWidth;\n\t\t}\n\t}\n\n\tif (renderHeight === null || renderHeight === '') {\n\t\tif (canvas.style.height === '') {\n\t\t\t// If no explicit render height and style height, let's apply the aspect ratio,\n\t\t\t// which one can be specified by the user but also by charts as default option\n\t\t\t// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\n\t\t\tcanvas.height = canvas.width / (config.options.aspectRatio || 2);\n\t\t} else {\n\t\t\tvar displayHeight = readUsedSize(canvas, 'height');\n\t\t\tif (displayWidth !== undefined) {\n\t\t\t\tcanvas.height = displayHeight;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn canvas;\n}\n\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */\nvar supportsEventListenerOptions = (function() {\n\tvar supports = false;\n\ttry {\n\t\tvar options = Object.defineProperty({}, 'passive', {\n\t\t\tget: function() {\n\t\t\t\tsupports = true;\n\t\t\t}\n\t\t});\n\t\twindow.addEventListener('e', null, options);\n\t} catch (e) {\n\t\t// continue regardless of error\n\t}\n\treturn supports;\n}());\n\n// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.\n// https://github.com/chartjs/Chart.js/issues/4287\nvar eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\n\nfunction addEventListener(node, type, listener) {\n\tnode.addEventListener(type, listener, eventListenerOptions);\n}\n\nfunction removeEventListener(node, type, listener) {\n\tnode.removeEventListener(type, listener, eventListenerOptions);\n}\n\nfunction createEvent(type, chart, x, y, nativeEvent) {\n\treturn {\n\t\ttype: type,\n\t\tchart: chart,\n\t\tnative: nativeEvent || null,\n\t\tx: x !== undefined ? x : null,\n\t\ty: y !== undefined ? y : null,\n\t};\n}\n\nfunction fromNativeEvent(event, chart) {\n\tvar type = EVENT_TYPES[event.type] || event.type;\n\tvar pos = helpers.getRelativePosition(event, chart);\n\treturn createEvent(type, chart, pos.x, pos.y, event);\n}\n\nfunction throttled(fn, thisArg) {\n\tvar ticking = false;\n\tvar args = [];\n\n\treturn function() {\n\t\targs = Array.prototype.slice.call(arguments);\n\t\tthisArg = thisArg || this;\n\n\t\tif (!ticking) {\n\t\t\tticking = true;\n\t\t\thelpers.requestAnimFrame.call(window, function() {\n\t\t\t\tticking = false;\n\t\t\t\tfn.apply(thisArg, args);\n\t\t\t});\n\t\t}\n\t};\n}\n\n// Implementation based on https://github.com/marcj/css-element-queries\nfunction createResizer(handler) {\n\tvar resizer = document.createElement('div');\n\tvar cls = CSS_PREFIX + 'size-monitor';\n\tvar maxSize = 1000000;\n\tvar style =\n\t\t'position:absolute;' +\n\t\t'left:0;' +\n\t\t'top:0;' +\n\t\t'right:0;' +\n\t\t'bottom:0;' +\n\t\t'overflow:hidden;' +\n\t\t'pointer-events:none;' +\n\t\t'visibility:hidden;' +\n\t\t'z-index:-1;';\n\n\tresizer.style.cssText = style;\n\tresizer.className = cls;\n\tresizer.innerHTML =\n\t\t'<div class=\"' + cls + '-expand\" style=\"' + style + '\">' +\n\t\t\t'<div style=\"' +\n\t\t\t\t'position:absolute;' +\n\t\t\t\t'width:' + maxSize + 'px;' +\n\t\t\t\t'height:' + maxSize + 'px;' +\n\t\t\t\t'left:0;' +\n\t\t\t\t'top:0\">' +\n\t\t\t'</div>' +\n\t\t'</div>' +\n\t\t'<div class=\"' + cls + '-shrink\" style=\"' + style + '\">' +\n\t\t\t'<div style=\"' +\n\t\t\t\t'position:absolute;' +\n\t\t\t\t'width:200%;' +\n\t\t\t\t'height:200%;' +\n\t\t\t\t'left:0; ' +\n\t\t\t\t'top:0\">' +\n\t\t\t'</div>' +\n\t\t'</div>';\n\n\tvar expand = resizer.childNodes[0];\n\tvar shrink = resizer.childNodes[1];\n\n\tresizer._reset = function() {\n\t\texpand.scrollLeft = maxSize;\n\t\texpand.scrollTop = maxSize;\n\t\tshrink.scrollLeft = maxSize;\n\t\tshrink.scrollTop = maxSize;\n\t};\n\tvar onScroll = function() {\n\t\tresizer._reset();\n\t\thandler();\n\t};\n\n\taddEventListener(expand, 'scroll', onScroll.bind(expand, 'expand'));\n\taddEventListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));\n\n\treturn resizer;\n}\n\n// https://davidwalsh.name/detect-node-insertion\nfunction watchForRender(node, handler) {\n\tvar expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});\n\tvar proxy = expando.renderProxy = function(e) {\n\t\tif (e.animationName === CSS_RENDER_ANIMATION) {\n\t\t\thandler();\n\t\t}\n\t};\n\n\thelpers.each(ANIMATION_START_EVENTS, function(type) {\n\t\taddEventListener(node, type, proxy);\n\t});\n\n\t// #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class\n\t// is removed then added back immediately (same animation frame?). Accessing the\n\t// `offsetParent` property will force a reflow and re-evaluate the CSS animation.\n\t// https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics\n\t// https://github.com/chartjs/Chart.js/issues/4737\n\texpando.reflow = !!node.offsetParent;\n\n\tnode.classList.add(CSS_RENDER_MONITOR);\n}\n\nfunction unwatchForRender(node) {\n\tvar expando = node[EXPANDO_KEY] || {};\n\tvar proxy = expando.renderProxy;\n\n\tif (proxy) {\n\t\thelpers.each(ANIMATION_START_EVENTS, function(type) {\n\t\t\tremoveEventListener(node, type, proxy);\n\t\t});\n\n\t\tdelete expando.renderProxy;\n\t}\n\n\tnode.classList.remove(CSS_RENDER_MONITOR);\n}\n\nfunction addResizeListener(node, listener, chart) {\n\tvar expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});\n\n\t// Let's keep track of this added resizer and thus avoid DOM query when removing it.\n\tvar resizer = expando.resizer = createResizer(throttled(function() {\n\t\tif (expando.resizer) {\n\t\t\treturn listener(createEvent('resize', chart));\n\t\t}\n\t}));\n\n\t// The resizer needs to be attached to the node parent, so we first need to be\n\t// sure that `node` is attached to the DOM before injecting the resizer element.\n\twatchForRender(node, function() {\n\t\tif (expando.resizer) {\n\t\t\tvar container = node.parentNode;\n\t\t\tif (container && container !== resizer.parentNode) {\n\t\t\t\tcontainer.insertBefore(resizer, container.firstChild);\n\t\t\t}\n\n\t\t\t// The container size might have changed, let's reset the resizer state.\n\t\t\tresizer._reset();\n\t\t}\n\t});\n}\n\nfunction removeResizeListener(node) {\n\tvar expando = node[EXPANDO_KEY] || {};\n\tvar resizer = expando.resizer;\n\n\tdelete expando.resizer;\n\tunwatchForRender(node);\n\n\tif (resizer && resizer.parentNode) {\n\t\tresizer.parentNode.removeChild(resizer);\n\t}\n}\n\nfunction injectCSS(platform, css) {\n\t// http://stackoverflow.com/q/3922139\n\tvar style = platform._style || document.createElement('style');\n\tif (!platform._style) {\n\t\tplatform._style = style;\n\t\tcss = '/* Chart.js */\\n' + css;\n\t\tstyle.setAttribute('type', 'text/css');\n\t\tdocument.getElementsByTagName('head')[0].appendChild(style);\n\t}\n\n\tstyle.appendChild(document.createTextNode(css));\n}\n\nmodule.exports = {\n\t/**\n\t * This property holds whether this platform is enabled for the current environment.\n\t * Currently used by platform.js to select the proper implementation.\n\t * @private\n\t */\n\t_enabled: typeof window !== 'undefined' && typeof document !== 'undefined',\n\n\tinitialize: function() {\n\t\tvar keyframes = 'from{opacity:0.99}to{opacity:1}';\n\n\t\tinjectCSS(this,\n\t\t\t// DOM rendering detection\n\t\t\t// https://davidwalsh.name/detect-node-insertion\n\t\t\t'@-webkit-keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' +\n\t\t\t'@keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' +\n\t\t\t'.' + CSS_RENDER_MONITOR + '{' +\n\t\t\t\t'-webkit-animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' +\n\t\t\t\t'animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' +\n\t\t\t'}'\n\t\t);\n\t},\n\n\tacquireContext: function(item, config) {\n\t\tif (typeof item === 'string') {\n\t\t\titem = document.getElementById(item);\n\t\t} else if (item.length) {\n\t\t\t// Support for array based queries (such as jQuery)\n\t\t\titem = item[0];\n\t\t}\n\n\t\tif (item && item.canvas) {\n\t\t\t// Support for any object associated to a canvas (including a context2d)\n\t\t\titem = item.canvas;\n\t\t}\n\n\t\t// To prevent canvas fingerprinting, some add-ons undefine the getContext\n\t\t// method, for example: https://github.com/kkapsner/CanvasBlocker\n\t\t// https://github.com/chartjs/Chart.js/issues/2807\n\t\tvar context = item && item.getContext && item.getContext('2d');\n\n\t\t// `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is\n\t\t// inside an iframe or when running in a protected environment. We could guess the\n\t\t// types from their toString() value but let's keep things flexible and assume it's\n\t\t// a sufficient condition if the item has a context2D which has item as `canvas`.\n\t\t// https://github.com/chartjs/Chart.js/issues/3887\n\t\t// https://github.com/chartjs/Chart.js/issues/4102\n\t\t// https://github.com/chartjs/Chart.js/issues/4152\n\t\tif (context && context.canvas === item) {\n\t\t\tinitCanvas(item, config);\n\t\t\treturn context;\n\t\t}\n\n\t\treturn null;\n\t},\n\n\treleaseContext: function(context) {\n\t\tvar canvas = context.canvas;\n\t\tif (!canvas[EXPANDO_KEY]) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar initial = canvas[EXPANDO_KEY].initial;\n\t\t['height', 'width'].forEach(function(prop) {\n\t\t\tvar value = initial[prop];\n\t\t\tif (helpers.isNullOrUndef(value)) {\n\t\t\t\tcanvas.removeAttribute(prop);\n\t\t\t} else {\n\t\t\t\tcanvas.setAttribute(prop, value);\n\t\t\t}\n\t\t});\n\n\t\thelpers.each(initial.style || {}, function(value, key) {\n\t\t\tcanvas.style[key] = value;\n\t\t});\n\n\t\t// The canvas render size might have been changed (and thus the state stack discarded),\n\t\t// we can't use save() and restore() to restore the initial state. So make sure that at\n\t\t// least the canvas context is reset to the default state by setting the canvas width.\n\t\t// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\n\t\tcanvas.width = canvas.width;\n\n\t\tdelete canvas[EXPANDO_KEY];\n\t},\n\n\taddEventListener: function(chart, type, listener) {\n\t\tvar canvas = chart.canvas;\n\t\tif (type === 'resize') {\n\t\t\t// Note: the resize event is not supported on all browsers.\n\t\t\taddResizeListener(canvas, listener, chart);\n\t\t\treturn;\n\t\t}\n\n\t\tvar expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});\n\t\tvar proxies = expando.proxies || (expando.proxies = {});\n\t\tvar proxy = proxies[chart.id + '_' + type] = function(event) {\n\t\t\tlistener(fromNativeEvent(event, chart));\n\t\t};\n\n\t\taddEventListener(canvas, type, proxy);\n\t},\n\n\tremoveEventListener: function(chart, type, listener) {\n\t\tvar canvas = chart.canvas;\n\t\tif (type === 'resize') {\n\t\t\t// Note: the resize event is not supported on all browsers.\n\t\t\tremoveResizeListener(canvas, listener);\n\t\t\treturn;\n\t\t}\n\n\t\tvar expando = listener[EXPANDO_KEY] || {};\n\t\tvar proxies = expando.proxies || {};\n\t\tvar proxy = proxies[chart.id + '_' + type];\n\t\tif (!proxy) {\n\t\t\treturn;\n\t\t}\n\n\t\tremoveEventListener(canvas, type, proxy);\n\t}\n};\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, use EventTarget.addEventListener instead.\n * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n * @function Chart.helpers.addEvent\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.addEvent = addEventListener;\n\n/**\n * Provided for backward compatibility, use EventTarget.removeEventListener instead.\n * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener\n * @function Chart.helpers.removeEvent\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.removeEvent = removeEventListener;\n","'use strict';\n\nvar helpers = require('../helpers/index');\nvar basic = require('./platform.basic');\nvar dom = require('./platform.dom');\n\n// @TODO Make possible to select another platform at build time.\nvar implementation = dom._enabled ? dom : basic;\n\n/**\n * @namespace Chart.platform\n * @see https://chartjs.gitbooks.io/proposals/content/Platform.html\n * @since 2.4.0\n */\nmodule.exports = helpers.extend({\n\t/**\n\t * @since 2.7.0\n\t */\n\tinitialize: function() {},\n\n\t/**\n\t * Called at chart construction time, returns a context2d instance implementing\n\t * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\n\t * @param {*} item - The native item from which to acquire context (platform specific)\n\t * @param {Object} options - The chart options\n\t * @returns {CanvasRenderingContext2D} context2d instance\n\t */\n\tacquireContext: function() {},\n\n\t/**\n\t * Called at chart destruction time, releases any resources associated to the context\n\t * previously returned by the acquireContext() method.\n\t * @param {CanvasRenderingContext2D} context - The context2d instance\n\t * @returns {Boolean} true if the method succeeded, else false\n\t */\n\treleaseContext: function() {},\n\n\t/**\n\t * Registers the specified listener on the given chart.\n\t * @param {Chart} chart - Chart from which to listen for event\n\t * @param {String} type - The ({@link IEvent}) type to listen for\n\t * @param {Function} listener - Receives a notification (an object that implements\n\t * the {@link IEvent} interface) when an event of the specified type occurs.\n\t */\n\taddEventListener: function() {},\n\n\t/**\n\t * Removes the specified listener previously registered with addEventListener.\n\t * @param {Chart} chart -Chart from which to remove the listener\n\t * @param {String} type - The ({@link IEvent}) type to remove\n\t * @param {Function} listener - The listener function to remove from the event target.\n\t */\n\tremoveEventListener: function() {}\n\n}, implementation);\n\n/**\n * @interface IPlatform\n * Allows abstracting platform dependencies away from the chart\n * @borrows Chart.platform.acquireContext as acquireContext\n * @borrows Chart.platform.releaseContext as releaseContext\n * @borrows Chart.platform.addEventListener as addEventListener\n * @borrows Chart.platform.removeEventListener as removeEventListener\n */\n\n/**\n * @interface IEvent\n * @prop {String} type - The event type name, possible values are:\n * 'contextmenu', 'mouseenter', 'mousedown', 'mousemove', 'mouseup', 'mouseout',\n * 'click', 'dblclick', 'keydown', 'keypress', 'keyup' and 'resize'\n * @prop {*} native - The original native event (null for emulated events, e.g. 'resize')\n * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)\n * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)\n */\n","'use strict';\n\nmodule.exports = {};\nmodule.exports.filler = require('./plugin.filler');\nmodule.exports.legend = require('./plugin.legend');\nmodule.exports.title = require('./plugin.title');\n","/**\n * Plugin based on discussion from the following Chart.js issues:\n * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569\n * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897\n */\n\n'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('global', {\n\tplugins: {\n\t\tfiller: {\n\t\t\tpropagate: true\n\t\t}\n\t}\n});\n\nvar mappers = {\n\tdataset: function(source) {\n\t\tvar index = source.fill;\n\t\tvar chart = source.chart;\n\t\tvar meta = chart.getDatasetMeta(index);\n\t\tvar visible = meta && chart.isDatasetVisible(index);\n\t\tvar points = (visible && meta.dataset._children) || [];\n\t\tvar length = points.length || 0;\n\n\t\treturn !length ? null : function(point, i) {\n\t\t\treturn (i < length && points[i]._view) || null;\n\t\t};\n\t},\n\n\tboundary: function(source) {\n\t\tvar boundary = source.boundary;\n\t\tvar x = boundary ? boundary.x : null;\n\t\tvar y = boundary ? boundary.y : null;\n\n\t\treturn function(point) {\n\t\t\treturn {\n\t\t\t\tx: x === null ? point.x : x,\n\t\t\t\ty: y === null ? point.y : y,\n\t\t\t};\n\t\t};\n\t}\n};\n\n// @todo if (fill[0] === '#')\nfunction decodeFill(el, index, count) {\n\tvar model = el._model || {};\n\tvar fill = model.fill;\n\tvar target;\n\n\tif (fill === undefined) {\n\t\tfill = !!model.backgroundColor;\n\t}\n\n\tif (fill === false || fill === null) {\n\t\treturn false;\n\t}\n\n\tif (fill === true) {\n\t\treturn 'origin';\n\t}\n\n\ttarget = parseFloat(fill, 10);\n\tif (isFinite(target) && Math.floor(target) === target) {\n\t\tif (fill[0] === '-' || fill[0] === '+') {\n\t\t\ttarget = index + target;\n\t\t}\n\n\t\tif (target === index || target < 0 || target >= count) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn target;\n\t}\n\n\tswitch (fill) {\n\t// compatibility\n\tcase 'bottom':\n\t\treturn 'start';\n\tcase 'top':\n\t\treturn 'end';\n\tcase 'zero':\n\t\treturn 'origin';\n\t// supported boundaries\n\tcase 'origin':\n\tcase 'start':\n\tcase 'end':\n\t\treturn fill;\n\t// invalid fill values\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nfunction computeBoundary(source) {\n\tvar model = source.el._model || {};\n\tvar scale = source.el._scale || {};\n\tvar fill = source.fill;\n\tvar target = null;\n\tvar horizontal;\n\n\tif (isFinite(fill)) {\n\t\treturn null;\n\t}\n\n\t// Backward compatibility: until v3, we still need to support boundary values set on\n\t// the model (scaleTop, scaleBottom and scaleZero) because some external plugins and\n\t// controllers might still use it (e.g. the Smith chart).\n\n\tif (fill === 'start') {\n\t\ttarget = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;\n\t} else if (fill === 'end') {\n\t\ttarget = model.scaleTop === undefined ? scale.top : model.scaleTop;\n\t} else if (model.scaleZero !== undefined) {\n\t\ttarget = model.scaleZero;\n\t} else if (scale.getBasePosition) {\n\t\ttarget = scale.getBasePosition();\n\t} else if (scale.getBasePixel) {\n\t\ttarget = scale.getBasePixel();\n\t}\n\n\tif (target !== undefined && target !== null) {\n\t\tif (target.x !== undefined && target.y !== undefined) {\n\t\t\treturn target;\n\t\t}\n\n\t\tif (typeof target === 'number' && isFinite(target)) {\n\t\t\thorizontal = scale.isHorizontal();\n\t\t\treturn {\n\t\t\t\tx: horizontal ? target : null,\n\t\t\t\ty: horizontal ? null : target\n\t\t\t};\n\t\t}\n\t}\n\n\treturn null;\n}\n\nfunction resolveTarget(sources, index, propagate) {\n\tvar source = sources[index];\n\tvar fill = source.fill;\n\tvar visited = [index];\n\tvar target;\n\n\tif (!propagate) {\n\t\treturn fill;\n\t}\n\n\twhile (fill !== false && visited.indexOf(fill) === -1) {\n\t\tif (!isFinite(fill)) {\n\t\t\treturn fill;\n\t\t}\n\n\t\ttarget = sources[fill];\n\t\tif (!target) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (target.visible) {\n\t\t\treturn fill;\n\t\t}\n\n\t\tvisited.push(fill);\n\t\tfill = target.fill;\n\t}\n\n\treturn false;\n}\n\nfunction createMapper(source) {\n\tvar fill = source.fill;\n\tvar type = 'dataset';\n\n\tif (fill === false) {\n\t\treturn null;\n\t}\n\n\tif (!isFinite(fill)) {\n\t\ttype = 'boundary';\n\t}\n\n\treturn mappers[type](source);\n}\n\nfunction isDrawable(point) {\n\treturn point && !point.skip;\n}\n\nfunction drawArea(ctx, curve0, curve1, len0, len1) {\n\tvar i;\n\n\tif (!len0 || !len1) {\n\t\treturn;\n\t}\n\n\t// building first area curve (normal)\n\tctx.moveTo(curve0[0].x, curve0[0].y);\n\tfor (i = 1; i < len0; ++i) {\n\t\thelpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);\n\t}\n\n\t// joining the two area curves\n\tctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);\n\n\t// building opposite area curve (reverse)\n\tfor (i = len1 - 1; i > 0; --i) {\n\t\thelpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);\n\t}\n}\n\nfunction doFill(ctx, points, mapper, view, color, loop) {\n\tvar count = points.length;\n\tvar span = view.spanGaps;\n\tvar curve0 = [];\n\tvar curve1 = [];\n\tvar len0 = 0;\n\tvar len1 = 0;\n\tvar i, ilen, index, p0, p1, d0, d1;\n\n\tctx.beginPath();\n\n\tfor (i = 0, ilen = (count + !!loop); i < ilen; ++i) {\n\t\tindex = i % count;\n\t\tp0 = points[index]._view;\n\t\tp1 = mapper(p0, index, view);\n\t\td0 = isDrawable(p0);\n\t\td1 = isDrawable(p1);\n\n\t\tif (d0 && d1) {\n\t\t\tlen0 = curve0.push(p0);\n\t\t\tlen1 = curve1.push(p1);\n\t\t} else if (len0 && len1) {\n\t\t\tif (!span) {\n\t\t\t\tdrawArea(ctx, curve0, curve1, len0, len1);\n\t\t\t\tlen0 = len1 = 0;\n\t\t\t\tcurve0 = [];\n\t\t\t\tcurve1 = [];\n\t\t\t} else {\n\t\t\t\tif (d0) {\n\t\t\t\t\tcurve0.push(p0);\n\t\t\t\t}\n\t\t\t\tif (d1) {\n\t\t\t\t\tcurve1.push(p1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdrawArea(ctx, curve0, curve1, len0, len1);\n\n\tctx.closePath();\n\tctx.fillStyle = color;\n\tctx.fill();\n}\n\nmodule.exports = {\n\tid: 'filler',\n\n\tafterDatasetsUpdate: function(chart, options) {\n\t\tvar count = (chart.data.datasets || []).length;\n\t\tvar propagate = options.propagate;\n\t\tvar sources = [];\n\t\tvar meta, i, el, source;\n\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\tel = meta.dataset;\n\t\t\tsource = null;\n\n\t\t\tif (el && el._model && el instanceof elements.Line) {\n\t\t\t\tsource = {\n\t\t\t\t\tvisible: chart.isDatasetVisible(i),\n\t\t\t\t\tfill: decodeFill(el, i, count),\n\t\t\t\t\tchart: chart,\n\t\t\t\t\tel: el\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tmeta.$filler = source;\n\t\t\tsources.push(source);\n\t\t}\n\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tsource = sources[i];\n\t\t\tif (!source) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsource.fill = resolveTarget(sources, i, propagate);\n\t\t\tsource.boundary = computeBoundary(source);\n\t\t\tsource.mapper = createMapper(source);\n\t\t}\n\t},\n\n\tbeforeDatasetDraw: function(chart, args) {\n\t\tvar meta = args.meta.$filler;\n\t\tif (!meta) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar ctx = chart.ctx;\n\t\tvar el = meta.el;\n\t\tvar view = el._view;\n\t\tvar points = el._children || [];\n\t\tvar mapper = meta.mapper;\n\t\tvar color = view.backgroundColor || defaults.global.defaultColor;\n\n\t\tif (mapper && color && points.length) {\n\t\t\thelpers.canvas.clipArea(ctx, chart.chartArea);\n\t\t\tdoFill(ctx, points, mapper, view, color, el._loop);\n\t\t\thelpers.canvas.unclipArea(ctx);\n\t\t}\n\t}\n};\n","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar Element = require('../core/core.element');\nvar helpers = require('../helpers/index');\nvar layouts = require('../core/core.layouts');\n\nvar noop = helpers.noop;\n\ndefaults._set('global', {\n\tlegend: {\n\t\tdisplay: true,\n\t\tposition: 'top',\n\t\tfullWidth: true,\n\t\treverse: false,\n\t\tweight: 1000,\n\n\t\t// a callback that will handle\n\t\tonClick: function(e, legendItem) {\n\t\t\tvar index = legendItem.datasetIndex;\n\t\t\tvar ci = this.chart;\n\t\t\tvar meta = ci.getDatasetMeta(index);\n\n\t\t\t// See controller.isDatasetVisible comment\n\t\t\tmeta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;\n\n\t\t\t// We hid a dataset ... rerender the chart\n\t\t\tci.update();\n\t\t},\n\n\t\tonHover: null,\n\n\t\tlabels: {\n\t\t\tboxWidth: 40,\n\t\t\tpadding: 10,\n\t\t\t// Generates labels shown in the legend\n\t\t\t// Valid properties to return:\n\t\t\t// text : text to display\n\t\t\t// fillStyle : fill of coloured box\n\t\t\t// strokeStyle: stroke of coloured box\n\t\t\t// hidden : if this legend item refers to a hidden item\n\t\t\t// lineCap : cap style for line\n\t\t\t// lineDash\n\t\t\t// lineDashOffset :\n\t\t\t// lineJoin :\n\t\t\t// lineWidth :\n\t\t\tgenerateLabels: function(chart) {\n\t\t\t\tvar data = chart.data;\n\t\t\t\treturn helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttext: dataset.label,\n\t\t\t\t\t\tfillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),\n\t\t\t\t\t\thidden: !chart.isDatasetVisible(i),\n\t\t\t\t\t\tlineCap: dataset.borderCapStyle,\n\t\t\t\t\t\tlineDash: dataset.borderDash,\n\t\t\t\t\t\tlineDashOffset: dataset.borderDashOffset,\n\t\t\t\t\t\tlineJoin: dataset.borderJoinStyle,\n\t\t\t\t\t\tlineWidth: dataset.borderWidth,\n\t\t\t\t\t\tstrokeStyle: dataset.borderColor,\n\t\t\t\t\t\tpointStyle: dataset.pointStyle,\n\n\t\t\t\t\t\t// Below is extra data used for toggling the datasets\n\t\t\t\t\t\tdatasetIndex: i\n\t\t\t\t\t};\n\t\t\t\t}, this) : [];\n\t\t\t}\n\t\t}\n\t},\n\n\tlegendCallback: function(chart) {\n\t\tvar text = [];\n\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\t\tfor (var i = 0; i < chart.data.datasets.length; i++) {\n\t\t\ttext.push('<li><span style=\"background-color:' + chart.data.datasets[i].backgroundColor + '\"></span>');\n\t\t\tif (chart.data.datasets[i].label) {\n\t\t\t\ttext.push(chart.data.datasets[i].label);\n\t\t\t}\n\t\t\ttext.push('</li>');\n\t\t}\n\t\ttext.push('</ul>');\n\t\treturn text.join('');\n\t}\n});\n\n/**\n * Helper function to get the box width based on the usePointStyle option\n * @param labelopts {Object} the label options on the legend\n * @param fontSize {Number} the label font size\n * @return {Number} width of the color box area\n */\nfunction getBoxWidth(labelOpts, fontSize) {\n\treturn labelOpts.usePointStyle ?\n\t\tfontSize * Math.SQRT2 :\n\t\tlabelOpts.boxWidth;\n}\n\n/**\n * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!\n */\nvar Legend = Element.extend({\n\n\tinitialize: function(config) {\n\t\thelpers.extend(this, config);\n\n\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\tthis.legendHitBoxes = [];\n\n\t\t// Are we in doughnut mode which has a different data type\n\t\tthis.doughnutMode = false;\n\t},\n\n\t// These methods are ordered by lifecycle. Utilities then follow.\n\t// Any function defined here is inherited by all legend types.\n\t// Any function can be extended by the legend type\n\n\tbeforeUpdate: noop,\n\tupdate: function(maxWidth, maxHeight, margins) {\n\t\tvar me = this;\n\n\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\tme.beforeUpdate();\n\n\t\t// Absorb the master measurements\n\t\tme.maxWidth = maxWidth;\n\t\tme.maxHeight = maxHeight;\n\t\tme.margins = margins;\n\n\t\t// Dimensions\n\t\tme.beforeSetDimensions();\n\t\tme.setDimensions();\n\t\tme.afterSetDimensions();\n\t\t// Labels\n\t\tme.beforeBuildLabels();\n\t\tme.buildLabels();\n\t\tme.afterBuildLabels();\n\n\t\t// Fit\n\t\tme.beforeFit();\n\t\tme.fit();\n\t\tme.afterFit();\n\t\t//\n\t\tme.afterUpdate();\n\n\t\treturn me.minSize;\n\t},\n\tafterUpdate: noop,\n\n\t//\n\n\tbeforeSetDimensions: noop,\n\tsetDimensions: function() {\n\t\tvar me = this;\n\t\t// Set the unconstrained dimension before label rotation\n\t\tif (me.isHorizontal()) {\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.left = 0;\n\t\t\tme.right = me.width;\n\t\t} else {\n\t\t\tme.height = me.maxHeight;\n\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.top = 0;\n\t\t\tme.bottom = me.height;\n\t\t}\n\n\t\t// Reset padding\n\t\tme.paddingLeft = 0;\n\t\tme.paddingTop = 0;\n\t\tme.paddingRight = 0;\n\t\tme.paddingBottom = 0;\n\n\t\t// Reset minSize\n\t\tme.minSize = {\n\t\t\twidth: 0,\n\t\t\theight: 0\n\t\t};\n\t},\n\tafterSetDimensions: noop,\n\n\t//\n\n\tbeforeBuildLabels: noop,\n\tbuildLabels: function() {\n\t\tvar me = this;\n\t\tvar labelOpts = me.options.labels || {};\n\t\tvar legendItems = helpers.callback(labelOpts.generateLabels, [me.chart], me) || [];\n\n\t\tif (labelOpts.filter) {\n\t\t\tlegendItems = legendItems.filter(function(item) {\n\t\t\t\treturn labelOpts.filter(item, me.chart.data);\n\t\t\t});\n\t\t}\n\n\t\tif (me.options.reverse) {\n\t\t\tlegendItems.reverse();\n\t\t}\n\n\t\tme.legendItems = legendItems;\n\t},\n\tafterBuildLabels: noop,\n\n\t//\n\n\tbeforeFit: noop,\n\tfit: function() {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\t\tvar labelOpts = opts.labels;\n\t\tvar display = opts.display;\n\n\t\tvar ctx = me.ctx;\n\n\t\tvar globalDefault = defaults.global;\n\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\tvar fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);\n\t\tvar fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);\n\t\tvar fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);\n\t\tvar labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\t// Reset hit boxes\n\t\tvar hitboxes = me.legendHitBoxes = [];\n\n\t\tvar minSize = me.minSize;\n\t\tvar isHorizontal = me.isHorizontal();\n\n\t\tif (isHorizontal) {\n\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\tminSize.height = display ? 10 : 0;\n\t\t} else {\n\t\t\tminSize.width = display ? 10 : 0;\n\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t}\n\n\t\t// Increase sizes here\n\t\tif (display) {\n\t\t\tctx.font = labelFont;\n\n\t\t\tif (isHorizontal) {\n\t\t\t\t// Labels\n\n\t\t\t\t// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n\t\t\t\tvar lineWidths = me.lineWidths = [0];\n\t\t\t\tvar totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;\n\n\t\t\t\tctx.textAlign = 'left';\n\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\tvar width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n\t\t\t\t\tif (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {\n\t\t\t\t\t\ttotalHeight += fontSize + (labelOpts.padding);\n\t\t\t\t\t\tlineWidths[lineWidths.length] = me.left;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\twidth: width,\n\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t};\n\n\t\t\t\t\tlineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n\t\t\t\t});\n\n\t\t\t\tminSize.height += totalHeight;\n\n\t\t\t} else {\n\t\t\t\tvar vPadding = labelOpts.padding;\n\t\t\t\tvar columnWidths = me.columnWidths = [];\n\t\t\t\tvar totalWidth = labelOpts.padding;\n\t\t\t\tvar currentColWidth = 0;\n\t\t\t\tvar currentColHeight = 0;\n\t\t\t\tvar itemHeight = fontSize + vPadding;\n\n\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\tvar itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n\t\t\t\t\t// If too tall, go to new column\n\t\t\t\t\tif (currentColHeight + itemHeight > minSize.height) {\n\t\t\t\t\t\ttotalWidth += currentColWidth + labelOpts.padding;\n\t\t\t\t\t\tcolumnWidths.push(currentColWidth); // previous column width\n\n\t\t\t\t\t\tcurrentColWidth = 0;\n\t\t\t\t\t\tcurrentColHeight = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get max width\n\t\t\t\t\tcurrentColWidth = Math.max(currentColWidth, itemWidth);\n\t\t\t\t\tcurrentColHeight += itemHeight;\n\n\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\twidth: itemWidth,\n\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t};\n\t\t\t\t});\n\n\t\t\t\ttotalWidth += currentColWidth;\n\t\t\t\tcolumnWidths.push(currentColWidth);\n\t\t\t\tminSize.width += totalWidth;\n\t\t\t}\n\t\t}\n\n\t\tme.width = minSize.width;\n\t\tme.height = minSize.height;\n\t},\n\tafterFit: noop,\n\n\t// Shared Methods\n\tisHorizontal: function() {\n\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t},\n\n\t// Actually draw the legend on the canvas\n\tdraw: function() {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\t\tvar labelOpts = opts.labels;\n\t\tvar globalDefault = defaults.global;\n\t\tvar lineDefault = globalDefault.elements.line;\n\t\tvar legendWidth = me.width;\n\t\tvar lineWidths = me.lineWidths;\n\n\t\tif (opts.display) {\n\t\t\tvar ctx = me.ctx;\n\t\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\t\tvar fontColor = valueOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor);\n\t\t\tvar fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);\n\t\t\tvar fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);\n\t\t\tvar fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);\n\t\t\tvar labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\t\t\tvar cursor;\n\n\t\t\t// Canvas setup\n\t\t\tctx.textAlign = 'left';\n\t\t\tctx.textBaseline = 'middle';\n\t\t\tctx.lineWidth = 0.5;\n\t\t\tctx.strokeStyle = fontColor; // for strikethrough effect\n\t\t\tctx.fillStyle = fontColor; // render in correct colour\n\t\t\tctx.font = labelFont;\n\n\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\tvar hitboxes = me.legendHitBoxes;\n\n\t\t\t// current position\n\t\t\tvar drawLegendBox = function(x, y, legendItem) {\n\t\t\t\tif (isNaN(boxWidth) || boxWidth <= 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Set the ctx for the box\n\t\t\t\tctx.save();\n\n\t\t\t\tctx.fillStyle = valueOrDefault(legendItem.fillStyle, globalDefault.defaultColor);\n\t\t\t\tctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\n\t\t\t\tctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n\t\t\t\tctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\n\t\t\t\tctx.lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\n\t\t\t\tctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);\n\t\t\t\tvar isLineWidthZero = (valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);\n\n\t\t\t\tif (ctx.setLineDash) {\n\t\t\t\t\t// IE 9 and 10 do not support line dash\n\t\t\t\t\tctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));\n\t\t\t\t}\n\n\t\t\t\tif (opts.labels && opts.labels.usePointStyle) {\n\t\t\t\t\t// Recalculate x and y for drawPoint() because its expecting\n\t\t\t\t\t// x and y to be center of figure (instead of top left)\n\t\t\t\t\tvar radius = fontSize * Math.SQRT2 / 2;\n\t\t\t\t\tvar offSet = radius / Math.SQRT2;\n\t\t\t\t\tvar centerX = x + offSet;\n\t\t\t\t\tvar centerY = y + offSet;\n\n\t\t\t\t\t// Draw pointStyle as legend symbol\n\t\t\t\t\thelpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\n\t\t\t\t} else {\n\t\t\t\t\t// Draw box as legend symbol\n\t\t\t\t\tif (!isLineWidthZero) {\n\t\t\t\t\t\tctx.strokeRect(x, y, boxWidth, fontSize);\n\t\t\t\t\t}\n\t\t\t\t\tctx.fillRect(x, y, boxWidth, fontSize);\n\t\t\t\t}\n\n\t\t\t\tctx.restore();\n\t\t\t};\n\t\t\tvar fillText = function(x, y, legendItem, textWidth) {\n\t\t\t\tvar halfFontSize = fontSize / 2;\n\t\t\t\tvar xLeft = boxWidth + halfFontSize + x;\n\t\t\t\tvar yMiddle = y + halfFontSize;\n\n\t\t\t\tctx.fillText(legendItem.text, xLeft, yMiddle);\n\n\t\t\t\tif (legendItem.hidden) {\n\t\t\t\t\t// Strikethrough the text if hidden\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.lineWidth = 2;\n\t\t\t\t\tctx.moveTo(xLeft, yMiddle);\n\t\t\t\t\tctx.lineTo(xLeft + textWidth, yMiddle);\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Horizontal\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tif (isHorizontal) {\n\t\t\t\tcursor = {\n\t\t\t\t\tx: me.left + ((legendWidth - lineWidths[0]) / 2),\n\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\tline: 0\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tcursor = {\n\t\t\t\t\tx: me.left + labelOpts.padding,\n\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\tline: 0\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tvar itemHeight = fontSize + labelOpts.padding;\n\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\tvar textWidth = ctx.measureText(legendItem.text).width;\n\t\t\t\tvar width = boxWidth + (fontSize / 2) + textWidth;\n\t\t\t\tvar x = cursor.x;\n\t\t\t\tvar y = cursor.y;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tif (x + width >= legendWidth) {\n\t\t\t\t\t\ty = cursor.y += itemHeight;\n\t\t\t\t\t\tcursor.line++;\n\t\t\t\t\t\tx = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);\n\t\t\t\t\t}\n\t\t\t\t} else if (y + itemHeight > me.bottom) {\n\t\t\t\t\tx = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\n\t\t\t\t\ty = cursor.y = me.top + labelOpts.padding;\n\t\t\t\t\tcursor.line++;\n\t\t\t\t}\n\n\t\t\t\tdrawLegendBox(x, y, legendItem);\n\n\t\t\t\thitboxes[i].left = x;\n\t\t\t\thitboxes[i].top = y;\n\n\t\t\t\t// Fill the actual label\n\t\t\t\tfillText(x, y, legendItem, textWidth);\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tcursor.x += width + (labelOpts.padding);\n\t\t\t\t} else {\n\t\t\t\t\tcursor.y += itemHeight;\n\t\t\t\t}\n\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * Handle an event\n\t * @private\n\t * @param {IEvent} event - The event to handle\n\t * @return {Boolean} true if a change occured\n\t */\n\thandleEvent: function(e) {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\t\tvar type = e.type === 'mouseup' ? 'click' : e.type;\n\t\tvar changed = false;\n\n\t\tif (type === 'mousemove') {\n\t\t\tif (!opts.onHover) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (type === 'click') {\n\t\t\tif (!opts.onClick) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\t// Chart event already has relative position in it\n\t\tvar x = e.x;\n\t\tvar y = e.y;\n\n\t\tif (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n\t\t\t// See if we are touching one of the dataset boxes\n\t\t\tvar lh = me.legendHitBoxes;\n\t\t\tfor (var i = 0; i < lh.length; ++i) {\n\t\t\t\tvar hitBox = lh[i];\n\n\t\t\t\tif (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n\t\t\t\t\t// Touching an element\n\t\t\t\t\tif (type === 'click') {\n\t\t\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\t\t\topts.onClick.call(me, e.native, me.legendItems[i]);\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (type === 'mousemove') {\n\t\t\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\t\t\topts.onHover.call(me, e.native, me.legendItems[i]);\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn changed;\n\t}\n});\n\nfunction createNewLegendAndAttach(chart, legendOpts) {\n\tvar legend = new Legend({\n\t\tctx: chart.ctx,\n\t\toptions: legendOpts,\n\t\tchart: chart\n\t});\n\n\tlayouts.configure(chart, legend, legendOpts);\n\tlayouts.addBox(chart, legend);\n\tchart.legend = legend;\n}\n\nmodule.exports = {\n\tid: 'legend',\n\n\t/**\n\t * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making\n\t * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of\n\t * the plugin, which one will be re-exposed in the chart.js file.\n\t * https://github.com/chartjs/Chart.js/pull/2640\n\t * @private\n\t */\n\t_element: Legend,\n\n\tbeforeInit: function(chart) {\n\t\tvar legendOpts = chart.options.legend;\n\n\t\tif (legendOpts) {\n\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\n\t\t}\n\t},\n\n\tbeforeUpdate: function(chart) {\n\t\tvar legendOpts = chart.options.legend;\n\t\tvar legend = chart.legend;\n\n\t\tif (legendOpts) {\n\t\t\thelpers.mergeIf(legendOpts, defaults.global.legend);\n\n\t\t\tif (legend) {\n\t\t\t\tlayouts.configure(chart, legend, legendOpts);\n\t\t\t\tlegend.options = legendOpts;\n\t\t\t} else {\n\t\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\n\t\t\t}\n\t\t} else if (legend) {\n\t\t\tlayouts.removeBox(chart, legend);\n\t\t\tdelete chart.legend;\n\t\t}\n\t},\n\n\tafterEvent: function(chart, e) {\n\t\tvar legend = chart.legend;\n\t\tif (legend) {\n\t\t\tlegend.handleEvent(e);\n\t\t}\n\t}\n};\n","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar Element = require('../core/core.element');\nvar helpers = require('../helpers/index');\nvar layouts = require('../core/core.layouts');\n\nvar noop = helpers.noop;\n\ndefaults._set('global', {\n\ttitle: {\n\t\tdisplay: false,\n\t\tfontStyle: 'bold',\n\t\tfullWidth: true,\n\t\tlineHeight: 1.2,\n\t\tpadding: 10,\n\t\tposition: 'top',\n\t\ttext: '',\n\t\tweight: 2000         // by default greater than legend (1000) to be above\n\t}\n});\n\n/**\n * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!\n */\nvar Title = Element.extend({\n\tinitialize: function(config) {\n\t\tvar me = this;\n\t\thelpers.extend(me, config);\n\n\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\tme.legendHitBoxes = [];\n\t},\n\n\t// These methods are ordered by lifecycle. Utilities then follow.\n\n\tbeforeUpdate: noop,\n\tupdate: function(maxWidth, maxHeight, margins) {\n\t\tvar me = this;\n\n\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\tme.beforeUpdate();\n\n\t\t// Absorb the master measurements\n\t\tme.maxWidth = maxWidth;\n\t\tme.maxHeight = maxHeight;\n\t\tme.margins = margins;\n\n\t\t// Dimensions\n\t\tme.beforeSetDimensions();\n\t\tme.setDimensions();\n\t\tme.afterSetDimensions();\n\t\t// Labels\n\t\tme.beforeBuildLabels();\n\t\tme.buildLabels();\n\t\tme.afterBuildLabels();\n\n\t\t// Fit\n\t\tme.beforeFit();\n\t\tme.fit();\n\t\tme.afterFit();\n\t\t//\n\t\tme.afterUpdate();\n\n\t\treturn me.minSize;\n\n\t},\n\tafterUpdate: noop,\n\n\t//\n\n\tbeforeSetDimensions: noop,\n\tsetDimensions: function() {\n\t\tvar me = this;\n\t\t// Set the unconstrained dimension before label rotation\n\t\tif (me.isHorizontal()) {\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.left = 0;\n\t\t\tme.right = me.width;\n\t\t} else {\n\t\t\tme.height = me.maxHeight;\n\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.top = 0;\n\t\t\tme.bottom = me.height;\n\t\t}\n\n\t\t// Reset padding\n\t\tme.paddingLeft = 0;\n\t\tme.paddingTop = 0;\n\t\tme.paddingRight = 0;\n\t\tme.paddingBottom = 0;\n\n\t\t// Reset minSize\n\t\tme.minSize = {\n\t\t\twidth: 0,\n\t\t\theight: 0\n\t\t};\n\t},\n\tafterSetDimensions: noop,\n\n\t//\n\n\tbeforeBuildLabels: noop,\n\tbuildLabels: noop,\n\tafterBuildLabels: noop,\n\n\t//\n\n\tbeforeFit: noop,\n\tfit: function() {\n\t\tvar me = this;\n\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\tvar opts = me.options;\n\t\tvar display = opts.display;\n\t\tvar fontSize = valueOrDefault(opts.fontSize, defaults.global.defaultFontSize);\n\t\tvar minSize = me.minSize;\n\t\tvar lineCount = helpers.isArray(opts.text) ? opts.text.length : 1;\n\t\tvar lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);\n\t\tvar textSize = display ? (lineCount * lineHeight) + (opts.padding * 2) : 0;\n\n\t\tif (me.isHorizontal()) {\n\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\tminSize.height = textSize;\n\t\t} else {\n\t\t\tminSize.width = textSize;\n\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t}\n\n\t\tme.width = minSize.width;\n\t\tme.height = minSize.height;\n\n\t},\n\tafterFit: noop,\n\n\t// Shared Methods\n\tisHorizontal: function() {\n\t\tvar pos = this.options.position;\n\t\treturn pos === 'top' || pos === 'bottom';\n\t},\n\n\t// Actually draw the title block on the canvas\n\tdraw: function() {\n\t\tvar me = this;\n\t\tvar ctx = me.ctx;\n\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\tvar opts = me.options;\n\t\tvar globalDefaults = defaults.global;\n\n\t\tif (opts.display) {\n\t\t\tvar fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize);\n\t\t\tvar fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle);\n\t\t\tvar fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily);\n\t\t\tvar titleFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\t\t\tvar lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);\n\t\t\tvar offset = lineHeight / 2 + opts.padding;\n\t\t\tvar rotation = 0;\n\t\t\tvar top = me.top;\n\t\t\tvar left = me.left;\n\t\t\tvar bottom = me.bottom;\n\t\t\tvar right = me.right;\n\t\t\tvar maxWidth, titleX, titleY;\n\n\t\t\tctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour\n\t\t\tctx.font = titleFont;\n\n\t\t\t// Horizontal\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\ttitleX = left + ((right - left) / 2); // midpoint of the width\n\t\t\t\ttitleY = top + offset;\n\t\t\t\tmaxWidth = right - left;\n\t\t\t} else {\n\t\t\t\ttitleX = opts.position === 'left' ? left + offset : right - offset;\n\t\t\t\ttitleY = top + ((bottom - top) / 2);\n\t\t\t\tmaxWidth = bottom - top;\n\t\t\t\trotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);\n\t\t\t}\n\n\t\t\tctx.save();\n\t\t\tctx.translate(titleX, titleY);\n\t\t\tctx.rotate(rotation);\n\t\t\tctx.textAlign = 'center';\n\t\t\tctx.textBaseline = 'middle';\n\n\t\t\tvar text = opts.text;\n\t\t\tif (helpers.isArray(text)) {\n\t\t\t\tvar y = 0;\n\t\t\t\tfor (var i = 0; i < text.length; ++i) {\n\t\t\t\t\tctx.fillText(text[i], 0, y, maxWidth);\n\t\t\t\t\ty += lineHeight;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tctx.fillText(text, 0, 0, maxWidth);\n\t\t\t}\n\n\t\t\tctx.restore();\n\t\t}\n\t}\n});\n\nfunction createNewTitleBlockAndAttach(chart, titleOpts) {\n\tvar title = new Title({\n\t\tctx: chart.ctx,\n\t\toptions: titleOpts,\n\t\tchart: chart\n\t});\n\n\tlayouts.configure(chart, title, titleOpts);\n\tlayouts.addBox(chart, title);\n\tchart.titleBlock = title;\n}\n\nmodule.exports = {\n\tid: 'title',\n\n\t/**\n\t * Backward compatibility: since 2.1.5, the title is registered as a plugin, making\n\t * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of\n\t * the plugin, which one will be re-exposed in the chart.js file.\n\t * https://github.com/chartjs/Chart.js/pull/2640\n\t * @private\n\t */\n\t_element: Title,\n\n\tbeforeInit: function(chart) {\n\t\tvar titleOpts = chart.options.title;\n\n\t\tif (titleOpts) {\n\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\n\t\t}\n\t},\n\n\tbeforeUpdate: function(chart) {\n\t\tvar titleOpts = chart.options.title;\n\t\tvar titleBlock = chart.titleBlock;\n\n\t\tif (titleOpts) {\n\t\t\thelpers.mergeIf(titleOpts, defaults.global.title);\n\n\t\t\tif (titleBlock) {\n\t\t\t\tlayouts.configure(chart, titleBlock, titleOpts);\n\t\t\t\ttitleBlock.options = titleOpts;\n\t\t\t} else {\n\t\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\n\t\t\t}\n\t\t} else if (titleBlock) {\n\t\t\tlayouts.removeBox(chart, titleBlock);\n\t\t\tdelete chart.titleBlock;\n\t\t}\n\t}\n};\n","'use strict';\n\nmodule.exports = function(Chart) {\n\n\t// Default config for a category scale\n\tvar defaultConfig = {\n\t\tposition: 'bottom'\n\t};\n\n\tvar DatasetScale = Chart.Scale.extend({\n\t\t/**\n\t\t* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those\n\t\t* else fall back to data.labels\n\t\t* @private\n\t\t*/\n\t\tgetLabels: function() {\n\t\t\tvar data = this.chart.data;\n\t\t\treturn this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;\n\t\t},\n\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar labels = me.getLabels();\n\t\t\tme.minIndex = 0;\n\t\t\tme.maxIndex = labels.length - 1;\n\t\t\tvar findIndex;\n\n\t\t\tif (me.options.ticks.min !== undefined) {\n\t\t\t\t// user specified min value\n\t\t\t\tfindIndex = labels.indexOf(me.options.ticks.min);\n\t\t\t\tme.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\n\t\t\t}\n\n\t\t\tif (me.options.ticks.max !== undefined) {\n\t\t\t\t// user specified max value\n\t\t\t\tfindIndex = labels.indexOf(me.options.ticks.max);\n\t\t\t\tme.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\n\t\t\t}\n\n\t\t\tme.min = labels[me.minIndex];\n\t\t\tme.max = labels[me.maxIndex];\n\t\t},\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar labels = me.getLabels();\n\t\t\t// If we are viewing some subset of labels, slice the original array\n\t\t\tme.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);\n\t\t},\n\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar data = me.chart.data;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tif (data.yLabels && !isHorizontal) {\n\t\t\t\treturn me.getRightValue(data.datasets[datasetIndex].data[index]);\n\t\t\t}\n\t\t\treturn me.ticks[index - me.minIndex];\n\t\t},\n\n\t\t// Used to get data value locations.  Value can either be an index or a numerical value\n\t\tgetPixelForValue: function(value, index) {\n\t\t\tvar me = this;\n\t\t\tvar offset = me.options.offset;\n\t\t\t// 1 is added because we need the length but we have the indexes\n\t\t\tvar offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1)), 1);\n\n\t\t\t// If value is a data object, then index is the index in the data array,\n\t\t\t// not the index of the scale. We need to change that.\n\t\t\tvar valueCategory;\n\t\t\tif (value !== undefined && value !== null) {\n\t\t\t\tvalueCategory = me.isHorizontal() ? value.x : value.y;\n\t\t\t}\n\t\t\tif (valueCategory !== undefined || (value !== undefined && isNaN(index))) {\n\t\t\t\tvar labels = me.getLabels();\n\t\t\t\tvalue = valueCategory || value;\n\t\t\t\tvar idx = labels.indexOf(value);\n\t\t\t\tindex = idx !== -1 ? idx : index;\n\t\t\t}\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar valueWidth = me.width / offsetAmt;\n\t\t\t\tvar widthOffset = (valueWidth * (index - me.minIndex));\n\n\t\t\t\tif (offset) {\n\t\t\t\t\twidthOffset += (valueWidth / 2);\n\t\t\t\t}\n\n\t\t\t\treturn me.left + Math.round(widthOffset);\n\t\t\t}\n\t\t\tvar valueHeight = me.height / offsetAmt;\n\t\t\tvar heightOffset = (valueHeight * (index - me.minIndex));\n\n\t\t\tif (offset) {\n\t\t\t\theightOffset += (valueHeight / 2);\n\t\t\t}\n\n\t\t\treturn me.top + Math.round(heightOffset);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.ticks[index], index + this.minIndex, null);\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar offset = me.options.offset;\n\t\t\tvar value;\n\t\t\tvar offsetAmt = Math.max((me._ticks.length - (offset ? 0 : 1)), 1);\n\t\t\tvar horz = me.isHorizontal();\n\t\t\tvar valueDimension = (horz ? me.width : me.height) / offsetAmt;\n\n\t\t\tpixel -= horz ? me.left : me.top;\n\n\t\t\tif (offset) {\n\t\t\t\tpixel -= (valueDimension / 2);\n\t\t\t}\n\n\t\t\tif (pixel <= 0) {\n\t\t\t\tvalue = 0;\n\t\t\t} else {\n\t\t\t\tvalue = Math.round(pixel / valueDimension);\n\t\t\t}\n\n\t\t\treturn value + me.minIndex;\n\t\t},\n\t\tgetBasePixel: function() {\n\t\t\treturn this.bottom;\n\t\t}\n\t});\n\n\tChart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);\n\n};\n","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar helpers = require('../helpers/index');\nvar Ticks = require('../core/core.ticks');\n\nmodule.exports = function(Chart) {\n\n\tvar defaultConfig = {\n\t\tposition: 'left',\n\t\tticks: {\n\t\t\tcallback: Ticks.formatters.linear\n\t\t}\n\t};\n\n\tvar LinearScale = Chart.LinearScaleBase.extend({\n\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar chart = me.chart;\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar DEFAULT_MIN = 0;\n\t\t\tvar DEFAULT_MAX = 1;\n\n\t\t\tfunction IDMatches(meta) {\n\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t}\n\n\t\t\t// First Calculate the range\n\t\t\tme.min = null;\n\t\t\tme.max = null;\n\n\t\t\tvar hasStacks = opts.stacked;\n\t\t\tif (hasStacks === undefined) {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (hasStacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n\t\t\t\t\t\tmeta.stack !== undefined) {\n\t\t\t\t\t\thasStacks = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (opts.stacked || hasStacks) {\n\t\t\t\tvar valuesPerStack = {};\n\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tvar key = [\n\t\t\t\t\t\tmeta.type,\n\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n\t\t\t\t\t\tmeta.stack\n\t\t\t\t\t].join('.');\n\n\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\tvaluesPerStack[key] = {\n\t\t\t\t\t\t\tpositiveValues: [],\n\t\t\t\t\t\t\tnegativeValues: []\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Store these per type\n\t\t\t\t\tvar positiveValues = valuesPerStack[key].positiveValues;\n\t\t\t\t\tvar negativeValues = valuesPerStack[key].negativeValues;\n\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpositiveValues[index] = positiveValues[index] || 0;\n\t\t\t\t\t\t\tnegativeValues[index] = negativeValues[index] || 0;\n\n\t\t\t\t\t\t\tif (opts.relativePoints) {\n\t\t\t\t\t\t\t\tpositiveValues[index] = 100;\n\t\t\t\t\t\t\t} else if (value < 0) {\n\t\t\t\t\t\t\t\tnegativeValues[index] += value;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpositiveValues[index] += value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thelpers.each(valuesPerStack, function(valuesForType) {\n\t\t\t\t\tvar values = valuesForType.positiveValues.concat(valuesForType.negativeValues);\n\t\t\t\t\tvar minVal = helpers.min(values);\n\t\t\t\t\tvar maxVal = helpers.max(values);\n\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tme.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;\n\t\t\tme.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;\n\n\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\t\tthis.handleTickRangeOptions();\n\t\t},\n\t\tgetTickLimit: function() {\n\t\t\tvar maxTicks;\n\t\t\tvar me = this;\n\t\t\tvar tickOpts = me.options.ticks;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));\n\t\t\t} else {\n\t\t\t\t// The factor of 2 used to scale the font size has been experimentally determined.\n\t\t\t\tvar tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize);\n\t\t\t\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));\n\t\t\t}\n\n\t\t\treturn maxTicks;\n\t\t},\n\t\t// Called after the ticks are built. We need\n\t\thandleDirectionalChanges: function() {\n\t\t\tif (!this.isHorizontal()) {\n\t\t\t\t// We are in a vertical orientation. The top value is the highest. So reverse the array\n\t\t\t\tthis.ticks.reverse();\n\t\t\t}\n\t\t},\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\t// Utils\n\t\tgetPixelForValue: function(value) {\n\t\t\t// This must be called after fit has been run so that\n\t\t\t// this.left, this.top, this.right, and this.bottom have been defined\n\t\t\tvar me = this;\n\t\t\tvar start = me.start;\n\n\t\t\tvar rightValue = +me.getRightValue(value);\n\t\t\tvar pixel;\n\t\t\tvar range = me.end - start;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tpixel = me.left + (me.width / range * (rightValue - start));\n\t\t\t} else {\n\t\t\t\tpixel = me.bottom - (me.height / range * (rightValue - start));\n\t\t\t}\n\t\t\treturn pixel;\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar innerDimension = isHorizontal ? me.width : me.height;\n\t\t\tvar offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;\n\t\t\treturn me.start + ((me.end - me.start) * offset);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.ticksAsNumbers[index]);\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);\n\n};\n","'use strict';\n\nvar helpers = require('../helpers/index');\n\n/**\n * Generate a set of linear ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {Array<Number>} array of tick values\n */\nfunction generateTicks(generationOptions, dataRange) {\n\tvar ticks = [];\n\t// To get a \"nice\" value for the tick spacing, we will use the appropriately named\n\t// \"nice number\" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n\t// for details.\n\n\tvar spacing;\n\tif (generationOptions.stepSize && generationOptions.stepSize > 0) {\n\t\tspacing = generationOptions.stepSize;\n\t} else {\n\t\tvar niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);\n\t\tspacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);\n\t}\n\tvar niceMin = Math.floor(dataRange.min / spacing) * spacing;\n\tvar niceMax = Math.ceil(dataRange.max / spacing) * spacing;\n\n\t// If min, max and stepSize is set and they make an evenly spaced scale use it.\n\tif (generationOptions.min && generationOptions.max && generationOptions.stepSize) {\n\t\t// If very close to our whole number, use it.\n\t\tif (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {\n\t\t\tniceMin = generationOptions.min;\n\t\t\tniceMax = generationOptions.max;\n\t\t}\n\t}\n\n\tvar numSpaces = (niceMax - niceMin) / spacing;\n\t// If very close to our rounded value, use it.\n\tif (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n\t\tnumSpaces = Math.round(numSpaces);\n\t} else {\n\t\tnumSpaces = Math.ceil(numSpaces);\n\t}\n\n\tvar precision = 1;\n\tif (spacing < 1) {\n\t\tprecision = Math.pow(10, spacing.toString().length - 2);\n\t\tniceMin = Math.round(niceMin * precision) / precision;\n\t\tniceMax = Math.round(niceMax * precision) / precision;\n\t}\n\tticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);\n\tfor (var j = 1; j < numSpaces; ++j) {\n\t\tticks.push(Math.round((niceMin + j * spacing) * precision) / precision);\n\t}\n\tticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);\n\n\treturn ticks;\n}\n\n\nmodule.exports = function(Chart) {\n\n\tvar noop = helpers.noop;\n\n\tChart.LinearScaleBase = Chart.Scale.extend({\n\t\tgetRightValue: function(value) {\n\t\t\tif (typeof value === 'string') {\n\t\t\t\treturn +value;\n\t\t\t}\n\t\t\treturn Chart.Scale.prototype.getRightValue.call(this, value);\n\t\t},\n\n\t\thandleTickRangeOptions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\n\t\t\t// do nothing since that would make the chart weird. If the user really wants a weird chart\n\t\t\t// axis, they can manually override it\n\t\t\tif (tickOpts.beginAtZero) {\n\t\t\t\tvar minSign = helpers.sign(me.min);\n\t\t\t\tvar maxSign = helpers.sign(me.max);\n\n\t\t\t\tif (minSign < 0 && maxSign < 0) {\n\t\t\t\t\t// move the top up to 0\n\t\t\t\t\tme.max = 0;\n\t\t\t\t} else if (minSign > 0 && maxSign > 0) {\n\t\t\t\t\t// move the bottom down to 0\n\t\t\t\t\tme.min = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;\n\t\t\tvar setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;\n\n\t\t\tif (tickOpts.min !== undefined) {\n\t\t\t\tme.min = tickOpts.min;\n\t\t\t} else if (tickOpts.suggestedMin !== undefined) {\n\t\t\t\tif (me.min === null) {\n\t\t\t\t\tme.min = tickOpts.suggestedMin;\n\t\t\t\t} else {\n\t\t\t\t\tme.min = Math.min(me.min, tickOpts.suggestedMin);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tickOpts.max !== undefined) {\n\t\t\t\tme.max = tickOpts.max;\n\t\t\t} else if (tickOpts.suggestedMax !== undefined) {\n\t\t\t\tif (me.max === null) {\n\t\t\t\t\tme.max = tickOpts.suggestedMax;\n\t\t\t\t} else {\n\t\t\t\t\tme.max = Math.max(me.max, tickOpts.suggestedMax);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (setMin !== setMax) {\n\t\t\t\t// We set the min or the max but not both.\n\t\t\t\t// So ensure that our range is good\n\t\t\t\t// Inverted or 0 length range can happen when\n\t\t\t\t// ticks.min is set, and no datasets are visible\n\t\t\t\tif (me.min >= me.max) {\n\t\t\t\t\tif (setMin) {\n\t\t\t\t\t\tme.max = me.min + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tme.min = me.max - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (me.min === me.max) {\n\t\t\t\tme.max++;\n\n\t\t\t\tif (!tickOpts.beginAtZero) {\n\t\t\t\t\tme.min--;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tgetTickLimit: noop,\n\t\thandleDirectionalChanges: noop,\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t// Figure out what the max number of ticks we can support it is based on the size of\n\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t\t\t// the graph. Make sure we always have at least 2 ticks\n\t\t\tvar maxTicks = me.getTickLimit();\n\t\t\tmaxTicks = Math.max(2, maxTicks);\n\n\t\t\tvar numericGeneratorOptions = {\n\t\t\t\tmaxTicks: maxTicks,\n\t\t\t\tmin: tickOpts.min,\n\t\t\t\tmax: tickOpts.max,\n\t\t\t\tstepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\n\t\t\t};\n\t\t\tvar ticks = me.ticks = generateTicks(numericGeneratorOptions, me);\n\n\t\t\tme.handleDirectionalChanges();\n\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers.max(ticks);\n\t\t\tme.min = helpers.min(ticks);\n\n\t\t\tif (tickOpts.reverse) {\n\t\t\t\tticks.reverse();\n\n\t\t\t\tme.start = me.max;\n\t\t\t\tme.end = me.min;\n\t\t\t} else {\n\t\t\t\tme.start = me.min;\n\t\t\t\tme.end = me.max;\n\t\t\t}\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\tme.ticksAsNumbers = me.ticks.slice();\n\t\t\tme.zeroLineIndex = me.ticks.indexOf(0);\n\n\t\t\tChart.Scale.prototype.convertTicksToLabels.call(me);\n\t\t}\n\t});\n};\n","'use strict';\n\nvar helpers = require('../helpers/index');\nvar Ticks = require('../core/core.ticks');\n\n/**\n * Generate a set of logarithmic ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {Array<Number>} array of tick values\n */\nfunction generateTicks(generationOptions, dataRange) {\n\tvar ticks = [];\n\tvar valueOrDefault = helpers.valueOrDefault;\n\n\t// Figure out what the max number of ticks we can support it is based on the size of\n\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t// the graph\n\tvar tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));\n\n\tvar endExp = Math.floor(helpers.log10(dataRange.max));\n\tvar endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n\tvar exp, significand;\n\n\tif (tickVal === 0) {\n\t\texp = Math.floor(helpers.log10(dataRange.minNotZero));\n\t\tsignificand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\n\n\t\tticks.push(tickVal);\n\t\ttickVal = significand * Math.pow(10, exp);\n\t} else {\n\t\texp = Math.floor(helpers.log10(tickVal));\n\t\tsignificand = Math.floor(tickVal / Math.pow(10, exp));\n\t}\n\tvar precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n\n\tdo {\n\t\tticks.push(tickVal);\n\n\t\t++significand;\n\t\tif (significand === 10) {\n\t\t\tsignificand = 1;\n\t\t\t++exp;\n\t\t\tprecision = exp >= 0 ? 1 : precision;\n\t\t}\n\n\t\ttickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n\t} while (exp < endExp || (exp === endExp && significand < endSignificand));\n\n\tvar lastTick = valueOrDefault(generationOptions.max, tickVal);\n\tticks.push(lastTick);\n\n\treturn ticks;\n}\n\n\nmodule.exports = function(Chart) {\n\n\tvar defaultConfig = {\n\t\tposition: 'left',\n\n\t\t// label settings\n\t\tticks: {\n\t\t\tcallback: Ticks.formatters.logarithmic\n\t\t}\n\t};\n\n\tvar LogarithmicScale = Chart.Scale.extend({\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar chart = me.chart;\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tfunction IDMatches(meta) {\n\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t}\n\n\t\t\t// Calculate Range\n\t\t\tme.min = null;\n\t\t\tme.max = null;\n\t\t\tme.minNotZero = null;\n\n\t\t\tvar hasStacks = opts.stacked;\n\t\t\tif (hasStacks === undefined) {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (hasStacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n\t\t\t\t\t\tmeta.stack !== undefined) {\n\t\t\t\t\t\thasStacks = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (opts.stacked || hasStacks) {\n\t\t\t\tvar valuesPerStack = {};\n\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tvar key = [\n\t\t\t\t\t\tmeta.type,\n\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n\t\t\t\t\t\tmeta.stack\n\t\t\t\t\t].join('.');\n\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\t\tvaluesPerStack[key] = [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar values = valuesPerStack[key];\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\t// invalid, hidden and negative values are ignored\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden || value < 0) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvalues[index] = values[index] || 0;\n\t\t\t\t\t\t\tvalues[index] += value;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thelpers.each(valuesPerStack, function(valuesForType) {\n\t\t\t\t\tif (valuesForType.length > 0) {\n\t\t\t\t\t\tvar minVal = helpers.min(valuesForType);\n\t\t\t\t\t\tvar maxVal = helpers.max(valuesForType);\n\t\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\t// invalid, hidden and negative values are ignored\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden || value < 0) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\n\t\t\t\t\t\t\t\tme.minNotZero = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Common base implementation to handle ticks.min, ticks.max\n\t\t\tthis.handleTickRangeOptions();\n\t\t},\n\t\thandleTickRangeOptions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\t\tvar DEFAULT_MIN = 1;\n\t\t\tvar DEFAULT_MAX = 10;\n\n\t\t\tme.min = valueOrDefault(tickOpts.min, me.min);\n\t\t\tme.max = valueOrDefault(tickOpts.max, me.max);\n\n\t\t\tif (me.min === me.max) {\n\t\t\t\tif (me.min !== 0 && me.min !== null) {\n\t\t\t\t\tme.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);\n\t\t\t\t\tme.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);\n\t\t\t\t} else {\n\t\t\t\t\tme.min = DEFAULT_MIN;\n\t\t\t\t\tme.max = DEFAULT_MAX;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (me.min === null) {\n\t\t\t\tme.min = Math.pow(10, Math.floor(helpers.log10(me.max)) - 1);\n\t\t\t}\n\t\t\tif (me.max === null) {\n\t\t\t\tme.max = me.min !== 0\n\t\t\t\t\t? Math.pow(10, Math.floor(helpers.log10(me.min)) + 1)\n\t\t\t\t\t: DEFAULT_MAX;\n\t\t\t}\n\t\t\tif (me.minNotZero === null) {\n\t\t\t\tif (me.min > 0) {\n\t\t\t\t\tme.minNotZero = me.min;\n\t\t\t\t} else if (me.max < 1) {\n\t\t\t\t\tme.minNotZero = Math.pow(10, Math.floor(helpers.log10(me.max)));\n\t\t\t\t} else {\n\t\t\t\t\tme.minNotZero = DEFAULT_MIN;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar reverse = !me.isHorizontal();\n\n\t\t\tvar generationOptions = {\n\t\t\t\tmin: tickOpts.min,\n\t\t\t\tmax: tickOpts.max\n\t\t\t};\n\t\t\tvar ticks = me.ticks = generateTicks(generationOptions, me);\n\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers.max(ticks);\n\t\t\tme.min = helpers.min(ticks);\n\n\t\t\tif (tickOpts.reverse) {\n\t\t\t\treverse = !reverse;\n\t\t\t\tme.start = me.max;\n\t\t\t\tme.end = me.min;\n\t\t\t} else {\n\t\t\t\tme.start = me.min;\n\t\t\t\tme.end = me.max;\n\t\t\t}\n\t\t\tif (reverse) {\n\t\t\t\tticks.reverse();\n\t\t\t}\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tthis.tickValues = this.ticks.slice();\n\n\t\t\tChart.Scale.prototype.convertTicksToLabels.call(this);\n\t\t},\n\t\t// Get the correct tooltip label\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.tickValues[index]);\n\t\t},\n\t\t/**\n\t\t * Returns the value of the first tick.\n\t\t * @param {Number} value - The minimum not zero value.\n\t\t * @return {Number} The first tick value.\n\t\t * @private\n\t\t */\n\t\t_getFirstTickValue: function(value) {\n\t\t\tvar exp = Math.floor(helpers.log10(value));\n\t\t\tvar significand = Math.floor(value / Math.pow(10, exp));\n\n\t\t\treturn significand * Math.pow(10, exp);\n\t\t},\n\t\tgetPixelForValue: function(value) {\n\t\t\tvar me = this;\n\t\t\tvar reverse = me.options.ticks.reverse;\n\t\t\tvar log10 = helpers.log10;\n\t\t\tvar firstTickValue = me._getFirstTickValue(me.minNotZero);\n\t\t\tvar offset = 0;\n\t\t\tvar innerDimension, pixel, start, end, sign;\n\n\t\t\tvalue = +me.getRightValue(value);\n\t\t\tif (reverse) {\n\t\t\t\tstart = me.end;\n\t\t\t\tend = me.start;\n\t\t\t\tsign = -1;\n\t\t\t} else {\n\t\t\t\tstart = me.start;\n\t\t\t\tend = me.end;\n\t\t\t\tsign = 1;\n\t\t\t}\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tinnerDimension = me.width;\n\t\t\t\tpixel = reverse ? me.right : me.left;\n\t\t\t} else {\n\t\t\t\tinnerDimension = me.height;\n\t\t\t\tsign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)\n\t\t\t\tpixel = reverse ? me.top : me.bottom;\n\t\t\t}\n\t\t\tif (value !== start) {\n\t\t\t\tif (start === 0) { // include zero tick\n\t\t\t\t\toffset = helpers.getValueOrDefault(\n\t\t\t\t\t\tme.options.ticks.fontSize,\n\t\t\t\t\t\tChart.defaults.global.defaultFontSize\n\t\t\t\t\t);\n\t\t\t\t\tinnerDimension -= offset;\n\t\t\t\t\tstart = firstTickValue;\n\t\t\t\t}\n\t\t\t\tif (value !== 0) {\n\t\t\t\t\toffset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));\n\t\t\t\t}\n\t\t\t\tpixel += sign * offset;\n\t\t\t}\n\t\t\treturn pixel;\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar reverse = me.options.ticks.reverse;\n\t\t\tvar log10 = helpers.log10;\n\t\t\tvar firstTickValue = me._getFirstTickValue(me.minNotZero);\n\t\t\tvar innerDimension, start, end, value;\n\n\t\t\tif (reverse) {\n\t\t\t\tstart = me.end;\n\t\t\t\tend = me.start;\n\t\t\t} else {\n\t\t\t\tstart = me.start;\n\t\t\t\tend = me.end;\n\t\t\t}\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tinnerDimension = me.width;\n\t\t\t\tvalue = reverse ? me.right - pixel : pixel - me.left;\n\t\t\t} else {\n\t\t\t\tinnerDimension = me.height;\n\t\t\t\tvalue = reverse ? pixel - me.top : me.bottom - pixel;\n\t\t\t}\n\t\t\tif (value !== start) {\n\t\t\t\tif (start === 0) { // include zero tick\n\t\t\t\t\tvar offset = helpers.getValueOrDefault(\n\t\t\t\t\t\tme.options.ticks.fontSize,\n\t\t\t\t\t\tChart.defaults.global.defaultFontSize\n\t\t\t\t\t);\n\t\t\t\t\tvalue -= offset;\n\t\t\t\t\tinnerDimension -= offset;\n\t\t\t\t\tstart = firstTickValue;\n\t\t\t\t}\n\t\t\t\tvalue *= log10(end) - log10(start);\n\t\t\t\tvalue /= innerDimension;\n\t\t\t\tvalue = Math.pow(10, log10(start) + value);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);\n\n};\n","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar helpers = require('../helpers/index');\nvar Ticks = require('../core/core.ticks');\n\nmodule.exports = function(Chart) {\n\n\tvar globalDefaults = defaults.global;\n\n\tvar defaultConfig = {\n\t\tdisplay: true,\n\n\t\t// Boolean - Whether to animate scaling the chart from the centre\n\t\tanimate: true,\n\t\tposition: 'chartArea',\n\n\t\tangleLines: {\n\t\t\tdisplay: true,\n\t\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\t\tlineWidth: 1\n\t\t},\n\n\t\tgridLines: {\n\t\t\tcircular: false\n\t\t},\n\n\t\t// label settings\n\t\tticks: {\n\t\t\t// Boolean - Show a backdrop to the scale label\n\t\t\tshowLabelBackdrop: true,\n\n\t\t\t// String - The colour of the label backdrop\n\t\t\tbackdropColor: 'rgba(255,255,255,0.75)',\n\n\t\t\t// Number - The backdrop padding above & below the label in pixels\n\t\t\tbackdropPaddingY: 2,\n\n\t\t\t// Number - The backdrop padding to the side of the label in pixels\n\t\t\tbackdropPaddingX: 2,\n\n\t\t\tcallback: Ticks.formatters.linear\n\t\t},\n\n\t\tpointLabels: {\n\t\t\t// Boolean - if true, show point labels\n\t\t\tdisplay: true,\n\n\t\t\t// Number - Point label font size in pixels\n\t\t\tfontSize: 10,\n\n\t\t\t// Function - Used to convert point labels\n\t\t\tcallback: function(label) {\n\t\t\t\treturn label;\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction getValueCount(scale) {\n\t\tvar opts = scale.options;\n\t\treturn opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;\n\t}\n\n\tfunction getPointLabelFontOptions(scale) {\n\t\tvar pointLabelOptions = scale.options.pointLabels;\n\t\tvar fontSize = helpers.valueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);\n\t\tvar fontStyle = helpers.valueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);\n\t\tvar fontFamily = helpers.valueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);\n\t\tvar font = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\treturn {\n\t\t\tsize: fontSize,\n\t\t\tstyle: fontStyle,\n\t\t\tfamily: fontFamily,\n\t\t\tfont: font\n\t\t};\n\t}\n\n\tfunction measureLabelSize(ctx, fontSize, label) {\n\t\tif (helpers.isArray(label)) {\n\t\t\treturn {\n\t\t\t\tw: helpers.longestText(ctx, ctx.font, label),\n\t\t\t\th: (label.length * fontSize) + ((label.length - 1) * 1.5 * fontSize)\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tw: ctx.measureText(label).width,\n\t\t\th: fontSize\n\t\t};\n\t}\n\n\tfunction determineLimits(angle, pos, size, min, max) {\n\t\tif (angle === min || angle === max) {\n\t\t\treturn {\n\t\t\t\tstart: pos - (size / 2),\n\t\t\t\tend: pos + (size / 2)\n\t\t\t};\n\t\t} else if (angle < min || angle > max) {\n\t\t\treturn {\n\t\t\t\tstart: pos - size - 5,\n\t\t\t\tend: pos\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tstart: pos,\n\t\t\tend: pos + size + 5\n\t\t};\n\t}\n\n\t/**\n\t * Helper function to fit a radial linear scale with point labels\n\t */\n\tfunction fitWithPointLabels(scale) {\n\t\t/*\n\t\t * Right, this is really confusing and there is a lot of maths going on here\n\t\t * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n\t\t *\n\t\t * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n\t\t *\n\t\t * Solution:\n\t\t *\n\t\t * We assume the radius of the polygon is half the size of the canvas at first\n\t\t * at each index we check if the text overlaps.\n\t\t *\n\t\t * Where it does, we store that angle and that index.\n\t\t *\n\t\t * After finding the largest index and angle we calculate how much we need to remove\n\t\t * from the shape radius to move the point inwards by that x.\n\t\t *\n\t\t * We average the left and right distances to get the maximum shape radius that can fit in the box\n\t\t * along with labels.\n\t\t *\n\t\t * Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n\t\t * on each side, removing that from the size, halving it and adding the left x protrusion width.\n\t\t *\n\t\t * This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n\t\t * and position it in the most space efficient manner\n\t\t *\n\t\t * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n\t\t */\n\n\t\tvar plFont = getPointLabelFontOptions(scale);\n\n\t\t// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n\t\t// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n\t\tvar largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n\t\tvar furthestLimits = {\n\t\t\tr: scale.width,\n\t\t\tl: 0,\n\t\t\tt: scale.height,\n\t\t\tb: 0\n\t\t};\n\t\tvar furthestAngles = {};\n\t\tvar i, textSize, pointPosition;\n\n\t\tscale.ctx.font = plFont.font;\n\t\tscale._pointLabelSizes = [];\n\n\t\tvar valueCount = getValueCount(scale);\n\t\tfor (i = 0; i < valueCount; i++) {\n\t\t\tpointPosition = scale.getPointPosition(i, largestPossibleRadius);\n\t\t\ttextSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');\n\t\t\tscale._pointLabelSizes[i] = textSize;\n\n\t\t\t// Add quarter circle to make degree 0 mean top of circle\n\t\t\tvar angleRadians = scale.getIndexAngle(i);\n\t\t\tvar angle = helpers.toDegrees(angleRadians) % 360;\n\t\t\tvar hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n\t\t\tvar vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n\n\t\t\tif (hLimits.start < furthestLimits.l) {\n\t\t\t\tfurthestLimits.l = hLimits.start;\n\t\t\t\tfurthestAngles.l = angleRadians;\n\t\t\t}\n\n\t\t\tif (hLimits.end > furthestLimits.r) {\n\t\t\t\tfurthestLimits.r = hLimits.end;\n\t\t\t\tfurthestAngles.r = angleRadians;\n\t\t\t}\n\n\t\t\tif (vLimits.start < furthestLimits.t) {\n\t\t\t\tfurthestLimits.t = vLimits.start;\n\t\t\t\tfurthestAngles.t = angleRadians;\n\t\t\t}\n\n\t\t\tif (vLimits.end > furthestLimits.b) {\n\t\t\t\tfurthestLimits.b = vLimits.end;\n\t\t\t\tfurthestAngles.b = angleRadians;\n\t\t\t}\n\t\t}\n\n\t\tscale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);\n\t}\n\n\t/**\n\t * Helper function to fit a radial linear scale with no point labels\n\t */\n\tfunction fit(scale) {\n\t\tvar largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n\t\tscale.drawingArea = Math.round(largestPossibleRadius);\n\t\tscale.setCenterPoint(0, 0, 0, 0);\n\t}\n\n\tfunction getTextAlignForAngle(angle) {\n\t\tif (angle === 0 || angle === 180) {\n\t\t\treturn 'center';\n\t\t} else if (angle < 180) {\n\t\t\treturn 'left';\n\t\t}\n\n\t\treturn 'right';\n\t}\n\n\tfunction fillText(ctx, text, position, fontSize) {\n\t\tif (helpers.isArray(text)) {\n\t\t\tvar y = position.y;\n\t\t\tvar spacing = 1.5 * fontSize;\n\n\t\t\tfor (var i = 0; i < text.length; ++i) {\n\t\t\t\tctx.fillText(text[i], position.x, y);\n\t\t\t\ty += spacing;\n\t\t\t}\n\t\t} else {\n\t\t\tctx.fillText(text, position.x, position.y);\n\t\t}\n\t}\n\n\tfunction adjustPointPositionForLabelHeight(angle, textSize, position) {\n\t\tif (angle === 90 || angle === 270) {\n\t\t\tposition.y -= (textSize.h / 2);\n\t\t} else if (angle > 270 || angle < 90) {\n\t\t\tposition.y -= textSize.h;\n\t\t}\n\t}\n\n\tfunction drawPointLabels(scale) {\n\t\tvar ctx = scale.ctx;\n\t\tvar opts = scale.options;\n\t\tvar angleLineOpts = opts.angleLines;\n\t\tvar pointLabelOpts = opts.pointLabels;\n\n\t\tctx.lineWidth = angleLineOpts.lineWidth;\n\t\tctx.strokeStyle = angleLineOpts.color;\n\n\t\tvar outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);\n\n\t\t// Point Label Font\n\t\tvar plFont = getPointLabelFontOptions(scale);\n\n\t\tctx.textBaseline = 'top';\n\n\t\tfor (var i = getValueCount(scale) - 1; i >= 0; i--) {\n\t\t\tif (angleLineOpts.display) {\n\t\t\t\tvar outerPosition = scale.getPointPosition(i, outerDistance);\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(scale.xCenter, scale.yCenter);\n\t\t\t\tctx.lineTo(outerPosition.x, outerPosition.y);\n\t\t\t\tctx.stroke();\n\t\t\t\tctx.closePath();\n\t\t\t}\n\n\t\t\tif (pointLabelOpts.display) {\n\t\t\t\t// Extra 3px out for some label spacing\n\t\t\t\tvar pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);\n\n\t\t\t\t// Keep this in loop since we may support array properties here\n\t\t\t\tvar pointLabelFontColor = helpers.valueAtIndexOrDefault(pointLabelOpts.fontColor, i, globalDefaults.defaultFontColor);\n\t\t\t\tctx.font = plFont.font;\n\t\t\t\tctx.fillStyle = pointLabelFontColor;\n\n\t\t\t\tvar angleRadians = scale.getIndexAngle(i);\n\t\t\t\tvar angle = helpers.toDegrees(angleRadians);\n\t\t\t\tctx.textAlign = getTextAlignForAngle(angle);\n\t\t\t\tadjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\n\t\t\t\tfillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction drawRadiusLine(scale, gridLineOpts, radius, index) {\n\t\tvar ctx = scale.ctx;\n\t\tctx.strokeStyle = helpers.valueAtIndexOrDefault(gridLineOpts.color, index - 1);\n\t\tctx.lineWidth = helpers.valueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);\n\n\t\tif (scale.options.gridLines.circular) {\n\t\t\t// Draw circular arcs between the points\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);\n\t\t\tctx.closePath();\n\t\t\tctx.stroke();\n\t\t} else {\n\t\t\t// Draw straight lines connecting each index\n\t\t\tvar valueCount = getValueCount(scale);\n\n\t\t\tif (valueCount === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tctx.beginPath();\n\t\t\tvar pointPosition = scale.getPointPosition(0, radius);\n\t\t\tctx.moveTo(pointPosition.x, pointPosition.y);\n\n\t\t\tfor (var i = 1; i < valueCount; i++) {\n\t\t\t\tpointPosition = scale.getPointPosition(i, radius);\n\t\t\t\tctx.lineTo(pointPosition.x, pointPosition.y);\n\t\t\t}\n\n\t\t\tctx.closePath();\n\t\t\tctx.stroke();\n\t\t}\n\t}\n\n\tfunction numberOrZero(param) {\n\t\treturn helpers.isNumber(param) ? param : 0;\n\t}\n\n\tvar LinearRadialScale = Chart.LinearScaleBase.extend({\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.height = me.maxHeight;\n\t\t\tme.xCenter = Math.round(me.width / 2);\n\t\t\tme.yCenter = Math.round(me.height / 2);\n\n\t\t\tvar minSize = helpers.min([me.height, me.width]);\n\t\t\tvar tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\tme.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);\n\t\t},\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar min = Number.POSITIVE_INFINITY;\n\t\t\tvar max = Number.NEGATIVE_INFINITY;\n\n\t\t\thelpers.each(chart.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\n\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmin = Math.min(value, min);\n\t\t\t\t\t\tmax = Math.max(value, max);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tme.min = (min === Number.POSITIVE_INFINITY ? 0 : min);\n\t\t\tme.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);\n\n\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\t\tme.handleTickRangeOptions();\n\t\t},\n\t\tgetTickLimit: function() {\n\t\t\tvar tickOpts = this.options.ticks;\n\t\t\tvar tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\treturn Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\n\t\t\tChart.LinearScaleBase.prototype.convertTicksToLabels.call(me);\n\n\t\t\t// Point labels\n\t\t\tme.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);\n\t\t},\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\tfit: function() {\n\t\t\tif (this.options.pointLabels.display) {\n\t\t\t\tfitWithPointLabels(this);\n\t\t\t} else {\n\t\t\t\tfit(this);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Set radius reductions and determine new radius and center point\n\t\t * @private\n\t\t */\n\t\tsetReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {\n\t\t\tvar me = this;\n\t\t\tvar radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\n\t\t\tvar radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\n\t\t\tvar radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\n\t\t\tvar radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);\n\n\t\t\tradiusReductionLeft = numberOrZero(radiusReductionLeft);\n\t\t\tradiusReductionRight = numberOrZero(radiusReductionRight);\n\t\t\tradiusReductionTop = numberOrZero(radiusReductionTop);\n\t\t\tradiusReductionBottom = numberOrZero(radiusReductionBottom);\n\n\t\t\tme.drawingArea = Math.min(\n\t\t\t\tMath.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),\n\t\t\t\tMath.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\n\t\t\tme.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\n\t\t},\n\t\tsetCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {\n\t\t\tvar me = this;\n\t\t\tvar maxRight = me.width - rightMovement - me.drawingArea;\n\t\t\tvar maxLeft = leftMovement + me.drawingArea;\n\t\t\tvar maxTop = topMovement + me.drawingArea;\n\t\t\tvar maxBottom = me.height - bottomMovement - me.drawingArea;\n\n\t\t\tme.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);\n\t\t\tme.yCenter = Math.round(((maxTop + maxBottom) / 2) + me.top);\n\t\t},\n\n\t\tgetIndexAngle: function(index) {\n\t\t\tvar angleMultiplier = (Math.PI * 2) / getValueCount(this);\n\t\t\tvar startAngle = this.chart.options && this.chart.options.startAngle ?\n\t\t\t\tthis.chart.options.startAngle :\n\t\t\t\t0;\n\n\t\t\tvar startAngleRadians = startAngle * Math.PI * 2 / 360;\n\n\t\t\t// Start from the top instead of right, so remove a quarter of the circle\n\t\t\treturn index * angleMultiplier + startAngleRadians;\n\t\t},\n\t\tgetDistanceFromCenterForValue: function(value) {\n\t\t\tvar me = this;\n\n\t\t\tif (value === null) {\n\t\t\t\treturn 0; // null always in center\n\t\t\t}\n\n\t\t\t// Take into account half font size + the yPadding of the top value\n\t\t\tvar scalingFactor = me.drawingArea / (me.max - me.min);\n\t\t\tif (me.options.ticks.reverse) {\n\t\t\t\treturn (me.max - value) * scalingFactor;\n\t\t\t}\n\t\t\treturn (value - me.min) * scalingFactor;\n\t\t},\n\t\tgetPointPosition: function(index, distanceFromCenter) {\n\t\t\tvar me = this;\n\t\t\tvar thisAngle = me.getIndexAngle(index) - (Math.PI / 2);\n\t\t\treturn {\n\t\t\t\tx: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,\n\t\t\t\ty: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter\n\t\t\t};\n\t\t},\n\t\tgetPointPositionForValue: function(index, value) {\n\t\t\treturn this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n\t\t},\n\n\t\tgetBasePosition: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\n\t\t\treturn me.getPointPositionForValue(0,\n\t\t\t\tme.beginAtZero ? 0 :\n\t\t\t\tmin < 0 && max < 0 ? max :\n\t\t\t\tmin > 0 && max > 0 ? min :\n\t\t\t\t0);\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar gridLineOpts = opts.gridLines;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar valueOrDefault = helpers.valueOrDefault;\n\n\t\t\tif (opts.display) {\n\t\t\t\tvar ctx = me.ctx;\n\t\t\t\tvar startAngle = this.getIndexAngle(0);\n\n\t\t\t\t// Tick Font\n\t\t\t\tvar tickFontSize = valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\t\tvar tickFontStyle = valueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);\n\t\t\t\tvar tickFontFamily = valueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);\n\t\t\t\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\n\n\t\t\t\thelpers.each(me.ticks, function(label, index) {\n\t\t\t\t\t// Don't draw a centre value (if it is minimum)\n\t\t\t\t\tif (index > 0 || tickOpts.reverse) {\n\t\t\t\t\t\tvar yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\n\n\t\t\t\t\t\t// Draw circular lines around the scale\n\t\t\t\t\t\tif (gridLineOpts.display && index !== 0) {\n\t\t\t\t\t\t\tdrawRadiusLine(me, gridLineOpts, yCenterOffset, index);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (tickOpts.display) {\n\t\t\t\t\t\t\tvar tickFontColor = valueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);\n\t\t\t\t\t\t\tctx.font = tickLabelFont;\n\n\t\t\t\t\t\t\tctx.save();\n\t\t\t\t\t\t\tctx.translate(me.xCenter, me.yCenter);\n\t\t\t\t\t\t\tctx.rotate(startAngle);\n\n\t\t\t\t\t\t\tif (tickOpts.showLabelBackdrop) {\n\t\t\t\t\t\t\t\tvar labelWidth = ctx.measureText(label).width;\n\t\t\t\t\t\t\t\tctx.fillStyle = tickOpts.backdropColor;\n\t\t\t\t\t\t\t\tctx.fillRect(\n\t\t\t\t\t\t\t\t\t-labelWidth / 2 - tickOpts.backdropPaddingX,\n\t\t\t\t\t\t\t\t\t-yCenterOffset - tickFontSize / 2 - tickOpts.backdropPaddingY,\n\t\t\t\t\t\t\t\t\tlabelWidth + tickOpts.backdropPaddingX * 2,\n\t\t\t\t\t\t\t\t\ttickFontSize + tickOpts.backdropPaddingY * 2\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tctx.textAlign = 'center';\n\t\t\t\t\t\t\tctx.textBaseline = 'middle';\n\t\t\t\t\t\t\tctx.fillStyle = tickFontColor;\n\t\t\t\t\t\t\tctx.fillText(label, 0, -yCenterOffset);\n\t\t\t\t\t\t\tctx.restore();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (opts.angleLines.display || opts.pointLabels.display) {\n\t\t\t\t\tdrawPointLabels(me);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);\n\n};\n","/* global window: false */\n'use strict';\n\nvar moment = require('moment');\nmoment = typeof moment === 'function' ? moment : window.moment;\n\nvar defaults = require('../core/core.defaults');\nvar helpers = require('../helpers/index');\n\n// Integer constants are from the ES6 spec.\nvar MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;\nvar MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\nvar INTERVALS = {\n\tmillisecond: {\n\t\tcommon: true,\n\t\tsize: 1,\n\t\tsteps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n\t},\n\tsecond: {\n\t\tcommon: true,\n\t\tsize: 1000,\n\t\tsteps: [1, 2, 5, 10, 30]\n\t},\n\tminute: {\n\t\tcommon: true,\n\t\tsize: 60000,\n\t\tsteps: [1, 2, 5, 10, 30]\n\t},\n\thour: {\n\t\tcommon: true,\n\t\tsize: 3600000,\n\t\tsteps: [1, 2, 3, 6, 12]\n\t},\n\tday: {\n\t\tcommon: true,\n\t\tsize: 86400000,\n\t\tsteps: [1, 2, 5]\n\t},\n\tweek: {\n\t\tcommon: false,\n\t\tsize: 604800000,\n\t\tsteps: [1, 2, 3, 4]\n\t},\n\tmonth: {\n\t\tcommon: true,\n\t\tsize: 2.628e9,\n\t\tsteps: [1, 2, 3]\n\t},\n\tquarter: {\n\t\tcommon: false,\n\t\tsize: 7.884e9,\n\t\tsteps: [1, 2, 3, 4]\n\t},\n\tyear: {\n\t\tcommon: true,\n\t\tsize: 3.154e10\n\t}\n};\n\nvar UNITS = Object.keys(INTERVALS);\n\nfunction sorter(a, b) {\n\treturn a - b;\n}\n\nfunction arrayUnique(items) {\n\tvar hash = {};\n\tvar out = [];\n\tvar i, ilen, item;\n\n\tfor (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\titem = items[i];\n\t\tif (!hash[item]) {\n\t\t\thash[item] = true;\n\t\t\tout.push(item);\n\t\t}\n\t}\n\n\treturn out;\n}\n\n/**\n * Returns an array of {time, pos} objects used to interpolate a specific `time` or position\n * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is\n * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other\n * extremity (left + width or top + height). Note that it would be more optimized to directly\n * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need\n * to create the lookup table. The table ALWAYS contains at least two items: min and max.\n *\n * @param {Number[]} timestamps - timestamps sorted from lowest to highest.\n * @param {String} distribution - If 'linear', timestamps will be spread linearly along the min\n * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.\n * If 'series', timestamps will be positioned at the same distance from each other. In this\n * case, only timestamps that break the time linearity are registered, meaning that in the\n * best case, all timestamps are linear, the table contains only min and max.\n */\nfunction buildLookupTable(timestamps, min, max, distribution) {\n\tif (distribution === 'linear' || !timestamps.length) {\n\t\treturn [\n\t\t\t{time: min, pos: 0},\n\t\t\t{time: max, pos: 1}\n\t\t];\n\t}\n\n\tvar table = [];\n\tvar items = [min];\n\tvar i, ilen, prev, curr, next;\n\n\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n\t\tcurr = timestamps[i];\n\t\tif (curr > min && curr < max) {\n\t\t\titems.push(curr);\n\t\t}\n\t}\n\n\titems.push(max);\n\n\tfor (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\tnext = items[i + 1];\n\t\tprev = items[i - 1];\n\t\tcurr = items[i];\n\n\t\t// only add points that breaks the scale linearity\n\t\tif (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {\n\t\t\ttable.push({time: curr, pos: i / (ilen - 1)});\n\t\t}\n\t}\n\n\treturn table;\n}\n\n// @see adapted from http://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/\nfunction lookup(table, key, value) {\n\tvar lo = 0;\n\tvar hi = table.length - 1;\n\tvar mid, i0, i1;\n\n\twhile (lo >= 0 && lo <= hi) {\n\t\tmid = (lo + hi) >> 1;\n\t\ti0 = table[mid - 1] || null;\n\t\ti1 = table[mid];\n\n\t\tif (!i0) {\n\t\t\t// given value is outside table (before first item)\n\t\t\treturn {lo: null, hi: i1};\n\t\t} else if (i1[key] < value) {\n\t\t\tlo = mid + 1;\n\t\t} else if (i0[key] > value) {\n\t\t\thi = mid - 1;\n\t\t} else {\n\t\t\treturn {lo: i0, hi: i1};\n\t\t}\n\t}\n\n\t// given value is outside table (after last item)\n\treturn {lo: i1, hi: null};\n}\n\n/**\n * Linearly interpolates the given source `value` using the table items `skey` values and\n * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')\n * returns the position for a timestamp equal to 42. If value is out of bounds, values at\n * index [0, 1] or [n - 1, n] are used for the interpolation.\n */\nfunction interpolate(table, skey, sval, tkey) {\n\tvar range = lookup(table, skey, sval);\n\n\t// Note: the lookup table ALWAYS contains at least 2 items (min and max)\n\tvar prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;\n\tvar next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;\n\n\tvar span = next[skey] - prev[skey];\n\tvar ratio = span ? (sval - prev[skey]) / span : 0;\n\tvar offset = (next[tkey] - prev[tkey]) * ratio;\n\n\treturn prev[tkey] + offset;\n}\n\n/**\n * Convert the given value to a moment object using the given time options.\n * @see http://momentjs.com/docs/#/parsing/\n */\nfunction momentify(value, options) {\n\tvar parser = options.parser;\n\tvar format = options.parser || options.format;\n\n\tif (typeof parser === 'function') {\n\t\treturn parser(value);\n\t}\n\n\tif (typeof value === 'string' && typeof format === 'string') {\n\t\treturn moment(value, format);\n\t}\n\n\tif (!(value instanceof moment)) {\n\t\tvalue = moment(value);\n\t}\n\n\tif (value.isValid()) {\n\t\treturn value;\n\t}\n\n\t// Labels are in an incompatible moment format and no `parser` has been provided.\n\t// The user might still use the deprecated `format` option to convert his inputs.\n\tif (typeof format === 'function') {\n\t\treturn format(value);\n\t}\n\n\treturn value;\n}\n\nfunction parse(input, scale) {\n\tif (helpers.isNullOrUndef(input)) {\n\t\treturn null;\n\t}\n\n\tvar options = scale.options.time;\n\tvar value = momentify(scale.getRightValue(input), options);\n\tif (!value.isValid()) {\n\t\treturn null;\n\t}\n\n\tif (options.round) {\n\t\tvalue.startOf(options.round);\n\t}\n\n\treturn value.valueOf();\n}\n\n/**\n * Returns the number of unit to skip to be able to display up to `capacity` number of ticks\n * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.\n */\nfunction determineStepSize(min, max, unit, capacity) {\n\tvar range = max - min;\n\tvar interval = INTERVALS[unit];\n\tvar milliseconds = interval.size;\n\tvar steps = interval.steps;\n\tvar i, ilen, factor;\n\n\tif (!steps) {\n\t\treturn Math.ceil(range / (capacity * milliseconds));\n\t}\n\n\tfor (i = 0, ilen = steps.length; i < ilen; ++i) {\n\t\tfactor = steps[i];\n\t\tif (Math.ceil(range / (milliseconds * factor)) <= capacity) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn factor;\n}\n\n/**\n * Figures out what unit results in an appropriate number of auto-generated ticks\n */\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n\tvar ilen = UNITS.length;\n\tvar i, interval, factor;\n\n\tfor (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n\t\tinterval = INTERVALS[UNITS[i]];\n\t\tfactor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;\n\n\t\tif (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n\t\t\treturn UNITS[i];\n\t\t}\n\t}\n\n\treturn UNITS[ilen - 1];\n}\n\n/**\n * Figures out what unit to format a set of ticks with\n */\nfunction determineUnitForFormatting(ticks, minUnit, min, max) {\n\tvar duration = moment.duration(moment(max).diff(moment(min)));\n\tvar ilen = UNITS.length;\n\tvar i, unit;\n\n\tfor (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {\n\t\tunit = UNITS[i];\n\t\tif (INTERVALS[unit].common && duration.as(unit) >= ticks.length) {\n\t\t\treturn unit;\n\t\t}\n\t}\n\n\treturn UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n\nfunction determineMajorUnit(unit) {\n\tfor (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n\t\tif (INTERVALS[UNITS[i]].common) {\n\t\t\treturn UNITS[i];\n\t\t}\n\t}\n}\n\n/**\n * Generates a maximum of `capacity` timestamps between min and max, rounded to the\n * `minor` unit, aligned on the `major` unit and using the given scale time `options`.\n * Important: this method can return ticks outside the min and max range, it's the\n * responsibility of the calling code to clamp values if needed.\n */\nfunction generate(min, max, capacity, options) {\n\tvar timeOpts = options.time;\n\tvar minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\n\tvar major = determineMajorUnit(minor);\n\tvar stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);\n\tvar weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n\tvar majorTicksEnabled = options.ticks.major.enabled;\n\tvar interval = INTERVALS[minor];\n\tvar first = moment(min);\n\tvar last = moment(max);\n\tvar ticks = [];\n\tvar time;\n\n\tif (!stepSize) {\n\t\tstepSize = determineStepSize(min, max, minor, capacity);\n\t}\n\n\t// For 'week' unit, handle the first day of week option\n\tif (weekday) {\n\t\tfirst = first.isoWeekday(weekday);\n\t\tlast = last.isoWeekday(weekday);\n\t}\n\n\t// Align first/last ticks on unit\n\tfirst = first.startOf(weekday ? 'day' : minor);\n\tlast = last.startOf(weekday ? 'day' : minor);\n\n\t// Make sure that the last tick include max\n\tif (last < max) {\n\t\tlast.add(1, minor);\n\t}\n\n\ttime = moment(first);\n\n\tif (majorTicksEnabled && major && !weekday && !timeOpts.round) {\n\t\t// Align the first tick on the previous `minor` unit aligned on the `major` unit:\n\t\t// we first aligned time on the previous `major` unit then add the number of full\n\t\t// stepSize there is between first and the previous major time.\n\t\ttime.startOf(major);\n\t\ttime.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);\n\t}\n\n\tfor (; time < last; time.add(stepSize, minor)) {\n\t\tticks.push(+time);\n\t}\n\n\tticks.push(+time);\n\n\treturn ticks;\n}\n\n/**\n * Returns the right and left offsets from edges in the form of {left, right}.\n * Offsets are added when the `offset` option is true.\n */\nfunction computeOffsets(table, ticks, min, max, options) {\n\tvar left = 0;\n\tvar right = 0;\n\tvar upper, lower;\n\n\tif (options.offset && ticks.length) {\n\t\tif (!options.time.min) {\n\t\t\tupper = ticks.length > 1 ? ticks[1] : max;\n\t\t\tlower = ticks[0];\n\t\t\tleft = (\n\t\t\t\tinterpolate(table, 'time', upper, 'pos') -\n\t\t\t\tinterpolate(table, 'time', lower, 'pos')\n\t\t\t) / 2;\n\t\t}\n\t\tif (!options.time.max) {\n\t\t\tupper = ticks[ticks.length - 1];\n\t\t\tlower = ticks.length > 1 ? ticks[ticks.length - 2] : min;\n\t\t\tright = (\n\t\t\t\tinterpolate(table, 'time', upper, 'pos') -\n\t\t\t\tinterpolate(table, 'time', lower, 'pos')\n\t\t\t) / 2;\n\t\t}\n\t}\n\n\treturn {left: left, right: right};\n}\n\nfunction ticksFromTimestamps(values, majorUnit) {\n\tvar ticks = [];\n\tvar i, ilen, value, major;\n\n\tfor (i = 0, ilen = values.length; i < ilen; ++i) {\n\t\tvalue = values[i];\n\t\tmajor = majorUnit ? value === +moment(value).startOf(majorUnit) : false;\n\n\t\tticks.push({\n\t\t\tvalue: value,\n\t\t\tmajor: major\n\t\t});\n\t}\n\n\treturn ticks;\n}\n\nfunction determineLabelFormat(data, timeOpts) {\n\tvar i, momentDate, hasTime;\n\tvar ilen = data.length;\n\n\t// find the label with the most parts (milliseconds, minutes, etc.)\n\t// format all labels with the same level of detail as the most specific label\n\tfor (i = 0; i < ilen; i++) {\n\t\tmomentDate = momentify(data[i], timeOpts);\n\t\tif (momentDate.millisecond() !== 0) {\n\t\t\treturn 'MMM D, YYYY h:mm:ss.SSS a';\n\t\t}\n\t\tif (momentDate.second() !== 0 || momentDate.minute() !== 0 || momentDate.hour() !== 0) {\n\t\t\thasTime = true;\n\t\t}\n\t}\n\tif (hasTime) {\n\t\treturn 'MMM D, YYYY h:mm:ss a';\n\t}\n\treturn 'MMM D, YYYY';\n}\n\nmodule.exports = function(Chart) {\n\n\tvar defaultConfig = {\n\t\tposition: 'bottom',\n\n\t\t/**\n\t\t * Data distribution along the scale:\n\t\t * - 'linear': data are spread according to their time (distances can vary),\n\t\t * - 'series': data are spread at the same distance from each other.\n\t\t * @see https://github.com/chartjs/Chart.js/pull/4507\n\t\t * @since 2.7.0\n\t\t */\n\t\tdistribution: 'linear',\n\n\t\t/**\n\t\t * Scale boundary strategy (bypassed by min/max time options)\n\t\t * - `data`: make sure data are fully visible, ticks outside are removed\n\t\t * - `ticks`: make sure ticks are fully visible, data outside are truncated\n\t\t * @see https://github.com/chartjs/Chart.js/pull/4556\n\t\t * @since 2.7.0\n\t\t */\n\t\tbounds: 'data',\n\n\t\ttime: {\n\t\t\tparser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\n\t\t\tformat: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/\n\t\t\tunit: false, // false == automatic or override with week, month, year, etc.\n\t\t\tround: false, // none, or override with week, month, year, etc.\n\t\t\tdisplayFormat: false, // DEPRECATED\n\t\t\tisoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/\n\t\t\tminUnit: 'millisecond',\n\n\t\t\t// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/\n\t\t\tdisplayFormats: {\n\t\t\t\tmillisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,\n\t\t\t\tsecond: 'h:mm:ss a', // 11:20:01 AM\n\t\t\t\tminute: 'h:mm a', // 11:20 AM\n\t\t\t\thour: 'hA', // 5PM\n\t\t\t\tday: 'MMM D', // Sep 4\n\t\t\t\tweek: 'll', // Week 46, or maybe \"[W]WW - YYYY\" ?\n\t\t\t\tmonth: 'MMM YYYY', // Sept 2015\n\t\t\t\tquarter: '[Q]Q - YYYY', // Q3\n\t\t\t\tyear: 'YYYY' // 2015\n\t\t\t},\n\t\t},\n\t\tticks: {\n\t\t\tautoSkip: false,\n\n\t\t\t/**\n\t\t\t * Ticks generation input values:\n\t\t\t * - 'auto': generates \"optimal\" ticks based on scale size and time options.\n\t\t\t * - 'data': generates ticks from data (including labels from data {t|x|y} objects).\n\t\t\t * - 'labels': generates ticks from user given `data.labels` values ONLY.\n\t\t\t * @see https://github.com/chartjs/Chart.js/pull/4507\n\t\t\t * @since 2.7.0\n\t\t\t */\n\t\t\tsource: 'auto',\n\n\t\t\tmajor: {\n\t\t\t\tenabled: false\n\t\t\t}\n\t\t}\n\t};\n\n\tvar TimeScale = Chart.Scale.extend({\n\t\tinitialize: function() {\n\t\t\tif (!moment) {\n\t\t\t\tthrow new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');\n\t\t\t}\n\n\t\t\tthis.mergeTicksOptions();\n\n\t\t\tChart.Scale.prototype.initialize.call(this);\n\t\t},\n\n\t\tupdate: function() {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\n\t\t\t// DEPRECATIONS: output a message only one time per update\n\t\t\tif (options.time && options.time.format) {\n\t\t\t\tconsole.warn('options.time.format is deprecated and replaced by options.time.parser.');\n\t\t\t}\n\n\t\t\treturn Chart.Scale.prototype.update.apply(me, arguments);\n\t\t},\n\n\t\t/**\n\t\t * Allows data to be referenced via 't' attribute\n\t\t */\n\t\tgetRightValue: function(rawValue) {\n\t\t\tif (rawValue && rawValue.t !== undefined) {\n\t\t\t\trawValue = rawValue.t;\n\t\t\t}\n\t\t\treturn Chart.Scale.prototype.getRightValue.call(this, rawValue);\n\t\t},\n\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar timeOpts = me.options.time;\n\t\t\tvar unit = timeOpts.unit || 'day';\n\t\t\tvar min = MAX_INTEGER;\n\t\t\tvar max = MIN_INTEGER;\n\t\t\tvar timestamps = [];\n\t\t\tvar datasets = [];\n\t\t\tvar labels = [];\n\t\t\tvar i, j, ilen, jlen, data, timestamp;\n\n\t\t\t// Convert labels to timestamps\n\t\t\tfor (i = 0, ilen = chart.data.labels.length; i < ilen; ++i) {\n\t\t\t\tlabels.push(parse(chart.data.labels[i], me));\n\t\t\t}\n\n\t\t\t// Convert data to timestamps\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\tif (chart.isDatasetVisible(i)) {\n\t\t\t\t\tdata = chart.data.datasets[i].data;\n\n\t\t\t\t\t// Let's consider that all data have the same format.\n\t\t\t\t\tif (helpers.isObject(data[0])) {\n\t\t\t\t\t\tdatasets[i] = [];\n\n\t\t\t\t\t\tfor (j = 0, jlen = data.length; j < jlen; ++j) {\n\t\t\t\t\t\t\ttimestamp = parse(data[j], me);\n\t\t\t\t\t\t\ttimestamps.push(timestamp);\n\t\t\t\t\t\t\tdatasets[i][j] = timestamp;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttimestamps.push.apply(timestamps, labels);\n\t\t\t\t\t\tdatasets[i] = labels.slice(0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdatasets[i] = [];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (labels.length) {\n\t\t\t\t// Sort labels **after** data have been converted\n\t\t\t\tlabels = arrayUnique(labels).sort(sorter);\n\t\t\t\tmin = Math.min(min, labels[0]);\n\t\t\t\tmax = Math.max(max, labels[labels.length - 1]);\n\t\t\t}\n\n\t\t\tif (timestamps.length) {\n\t\t\t\ttimestamps = arrayUnique(timestamps).sort(sorter);\n\t\t\t\tmin = Math.min(min, timestamps[0]);\n\t\t\t\tmax = Math.max(max, timestamps[timestamps.length - 1]);\n\t\t\t}\n\n\t\t\tmin = parse(timeOpts.min, me) || min;\n\t\t\tmax = parse(timeOpts.max, me) || max;\n\n\t\t\t// In case there is no valid min/max, set limits based on unit time option\n\t\t\tmin = min === MAX_INTEGER ? +moment().startOf(unit) : min;\n\t\t\tmax = max === MIN_INTEGER ? +moment().endOf(unit) + 1 : max;\n\n\t\t\t// Make sure that max is strictly higher than min (required by the lookup table)\n\t\t\tme.min = Math.min(min, max);\n\t\t\tme.max = Math.max(min + 1, max);\n\n\t\t\t// PRIVATE\n\t\t\tme._horizontal = me.isHorizontal();\n\t\t\tme._table = [];\n\t\t\tme._timestamps = {\n\t\t\t\tdata: timestamps,\n\t\t\t\tdatasets: datasets,\n\t\t\t\tlabels: labels\n\t\t\t};\n\t\t},\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\t\t\tvar options = me.options;\n\t\t\tvar timeOpts = options.time;\n\t\t\tvar timestamps = [];\n\t\t\tvar ticks = [];\n\t\t\tvar i, ilen, timestamp;\n\n\t\t\tswitch (options.ticks.source) {\n\t\t\tcase 'data':\n\t\t\t\ttimestamps = me._timestamps.data;\n\t\t\t\tbreak;\n\t\t\tcase 'labels':\n\t\t\t\ttimestamps = me._timestamps.labels;\n\t\t\t\tbreak;\n\t\t\tcase 'auto':\n\t\t\tdefault:\n\t\t\t\ttimestamps = generate(min, max, me.getLabelCapacity(min), options);\n\t\t\t}\n\n\t\t\tif (options.bounds === 'ticks' && timestamps.length) {\n\t\t\t\tmin = timestamps[0];\n\t\t\t\tmax = timestamps[timestamps.length - 1];\n\t\t\t}\n\n\t\t\t// Enforce limits with user min/max options\n\t\t\tmin = parse(timeOpts.min, me) || min;\n\t\t\tmax = parse(timeOpts.max, me) || max;\n\n\t\t\t// Remove ticks outside the min/max range\n\t\t\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n\t\t\t\ttimestamp = timestamps[i];\n\t\t\t\tif (timestamp >= min && timestamp <= max) {\n\t\t\t\t\tticks.push(timestamp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.min = min;\n\t\t\tme.max = max;\n\n\t\t\t// PRIVATE\n\t\t\tme._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);\n\t\t\tme._majorUnit = determineMajorUnit(me._unit);\n\t\t\tme._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);\n\t\t\tme._offsets = computeOffsets(me._table, ticks, min, max, options);\n\t\t\tme._labelFormat = determineLabelFormat(me._timestamps.data, timeOpts);\n\n\t\t\treturn ticksFromTimestamps(ticks, me._majorUnit);\n\t\t},\n\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar data = me.chart.data;\n\t\t\tvar timeOpts = me.options.time;\n\t\t\tvar label = data.labels && index < data.labels.length ? data.labels[index] : '';\n\t\t\tvar value = data.datasets[datasetIndex].data[index];\n\n\t\t\tif (helpers.isObject(value)) {\n\t\t\t\tlabel = me.getRightValue(value);\n\t\t\t}\n\t\t\tif (timeOpts.tooltipFormat) {\n\t\t\t\treturn momentify(label, timeOpts).format(timeOpts.tooltipFormat);\n\t\t\t}\n\t\t\tif (typeof label === 'string') {\n\t\t\t\treturn label;\n\t\t\t}\n\n\t\t\treturn momentify(label, timeOpts).format(me._labelFormat);\n\t\t},\n\n\t\t/**\n\t\t * Function to format an individual tick mark\n\t\t * @private\n\t\t */\n\t\ttickFormatFunction: function(tick, index, ticks, formatOverride) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tvar time = tick.valueOf();\n\t\t\tvar formats = options.time.displayFormats;\n\t\t\tvar minorFormat = formats[me._unit];\n\t\t\tvar majorUnit = me._majorUnit;\n\t\t\tvar majorFormat = formats[majorUnit];\n\t\t\tvar majorTime = tick.clone().startOf(majorUnit).valueOf();\n\t\t\tvar majorTickOpts = options.ticks.major;\n\t\t\tvar major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;\n\t\t\tvar label = tick.format(formatOverride ? formatOverride : major ? majorFormat : minorFormat);\n\t\t\tvar tickOpts = major ? majorTickOpts : options.ticks.minor;\n\t\t\tvar formatter = helpers.valueOrDefault(tickOpts.callback, tickOpts.userCallback);\n\n\t\t\treturn formatter ? formatter(label, index, ticks) : label;\n\t\t},\n\n\t\tconvertTicksToLabels: function(ticks) {\n\t\t\tvar labels = [];\n\t\t\tvar i, ilen;\n\n\t\t\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\t\t\tlabels.push(this.tickFormatFunction(moment(ticks[i].value), i, ticks));\n\t\t\t}\n\n\t\t\treturn labels;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetPixelForOffset: function(time) {\n\t\t\tvar me = this;\n\t\t\tvar size = me._horizontal ? me.width : me.height;\n\t\t\tvar start = me._horizontal ? me.left : me.top;\n\t\t\tvar pos = interpolate(me._table, 'time', time, 'pos');\n\n\t\t\treturn start + size * (me._offsets.left + pos) / (me._offsets.left + 1 + me._offsets.right);\n\t\t},\n\n\t\tgetPixelForValue: function(value, index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar time = null;\n\n\t\t\tif (index !== undefined && datasetIndex !== undefined) {\n\t\t\t\ttime = me._timestamps.datasets[datasetIndex][index];\n\t\t\t}\n\n\t\t\tif (time === null) {\n\t\t\t\ttime = parse(value, me);\n\t\t\t}\n\n\t\t\tif (time !== null) {\n\t\t\t\treturn me.getPixelForOffset(time);\n\t\t\t}\n\t\t},\n\n\t\tgetPixelForTick: function(index) {\n\t\t\tvar ticks = this.getTicks();\n\t\t\treturn index >= 0 && index < ticks.length ?\n\t\t\t\tthis.getPixelForOffset(ticks[index].value) :\n\t\t\t\tnull;\n\t\t},\n\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar size = me._horizontal ? me.width : me.height;\n\t\t\tvar start = me._horizontal ? me.left : me.top;\n\t\t\tvar pos = (size ? (pixel - start) / size : 0) * (me._offsets.left + 1 + me._offsets.left) - me._offsets.right;\n\t\t\tvar time = interpolate(me._table, 'pos', pos, 'time');\n\n\t\t\treturn moment(time);\n\t\t},\n\n\t\t/**\n\t\t * Crude approximation of what the label width might be\n\t\t * @private\n\t\t */\n\t\tgetLabelWidth: function(label) {\n\t\t\tvar me = this;\n\t\t\tvar ticksOpts = me.options.ticks;\n\t\t\tvar tickLabelWidth = me.ctx.measureText(label).width;\n\t\t\tvar angle = helpers.toRadians(ticksOpts.maxRotation);\n\t\t\tvar cosRotation = Math.cos(angle);\n\t\t\tvar sinRotation = Math.sin(angle);\n\t\t\tvar tickFontSize = helpers.valueOrDefault(ticksOpts.fontSize, defaults.global.defaultFontSize);\n\n\t\t\treturn (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetLabelCapacity: function(exampleTime) {\n\t\t\tvar me = this;\n\n\t\t\tvar formatOverride = me.options.time.displayFormats.millisecond;\t// Pick the longest format for guestimation\n\n\t\t\tvar exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, [], formatOverride);\n\t\t\tvar tickLabelWidth = me.getLabelWidth(exampleLabel);\n\t\t\tvar innerWidth = me.isHorizontal() ? me.width : me.height;\n\n\t\t\tvar capacity = Math.floor(innerWidth / tickLabelWidth);\n\t\t\treturn capacity > 0 ? capacity : 1;\n\t\t}\n\t});\n\n\tChart.scaleService.registerScaleType('time', TimeScale, defaultConfig);\n};\n","//! moment.js locale configuration\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../moment')) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n\n    function processRelativeTime(number, withoutSuffix, key, isFuture) {\n        var format = {\n            'm': ['eine Minute', 'einer Minute'],\n            'h': ['eine Stunde', 'einer Stunde'],\n            'd': ['ein Tag', 'einem Tag'],\n            'dd': [number + ' Tage', number + ' Tagen'],\n            'M': ['ein Monat', 'einem Monat'],\n            'MM': [number + ' Monate', number + ' Monaten'],\n            'y': ['ein Jahr', 'einem Jahr'],\n            'yy': [number + ' Jahre', number + ' Jahren']\n        };\n        return withoutSuffix ? format[key][0] : format[key][1];\n    }\n\n    var de = moment.defineLocale('de', {\n        months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),\n        monthsShort : 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),\n        monthsParseExact : true,\n        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),\n        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),\n        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),\n        weekdaysParseExact : true,\n        longDateFormat : {\n            LT: 'HH:mm',\n            LTS: 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D. MMMM YYYY',\n            LLL : 'D. MMMM YYYY HH:mm',\n            LLLL : 'dddd, D. MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[heute um] LT [Uhr]',\n            sameElse: 'L',\n            nextDay: '[morgen um] LT [Uhr]',\n            nextWeek: 'dddd [um] LT [Uhr]',\n            lastDay: '[gestern um] LT [Uhr]',\n            lastWeek: '[letzten] dddd [um] LT [Uhr]'\n        },\n        relativeTime : {\n            future : 'in %s',\n            past : 'vor %s',\n            s : 'ein paar Sekunden',\n            ss : '%d Sekunden',\n            m : processRelativeTime,\n            mm : '%d Minuten',\n            h : processRelativeTime,\n            hh : '%d Stunden',\n            d : processRelativeTime,\n            dd : processRelativeTime,\n            M : processRelativeTime,\n            MM : processRelativeTime,\n            y : processRelativeTime,\n            yy : processRelativeTime\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    return de;\n\n})));\n","//! moment.js\n\n;(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    global.moment = factory()\n}(this, (function () { 'use strict';\n\n    var hookCallback;\n\n    function hooks () {\n        return hookCallback.apply(null, arguments);\n    }\n\n    // This is done to register the method called with moment()\n    // without creating circular dependencies.\n    function setHookCallback (callback) {\n        hookCallback = callback;\n    }\n\n    function isArray(input) {\n        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';\n    }\n\n    function isObject(input) {\n        // IE8 will treat undefined and null as object if it wasn't for\n        // input != null\n        return input != null && Object.prototype.toString.call(input) === '[object Object]';\n    }\n\n    function isObjectEmpty(obj) {\n        if (Object.getOwnPropertyNames) {\n            return (Object.getOwnPropertyNames(obj).length === 0);\n        } else {\n            var k;\n            for (k in obj) {\n                if (obj.hasOwnProperty(k)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    function isUndefined(input) {\n        return input === void 0;\n    }\n\n    function isNumber(input) {\n        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';\n    }\n\n    function isDate(input) {\n        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';\n    }\n\n    function map(arr, fn) {\n        var res = [], i;\n        for (i = 0; i < arr.length; ++i) {\n            res.push(fn(arr[i], i));\n        }\n        return res;\n    }\n\n    function hasOwnProp(a, b) {\n        return Object.prototype.hasOwnProperty.call(a, b);\n    }\n\n    function extend(a, b) {\n        for (var i in b) {\n            if (hasOwnProp(b, i)) {\n                a[i] = b[i];\n            }\n        }\n\n        if (hasOwnProp(b, 'toString')) {\n            a.toString = b.toString;\n        }\n\n        if (hasOwnProp(b, 'valueOf')) {\n            a.valueOf = b.valueOf;\n        }\n\n        return a;\n    }\n\n    function createUTC (input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, true).utc();\n    }\n\n    function defaultParsingFlags() {\n        // We need to deep clone this object.\n        return {\n            empty           : false,\n            unusedTokens    : [],\n            unusedInput     : [],\n            overflow        : -2,\n            charsLeftOver   : 0,\n            nullInput       : false,\n            invalidMonth    : null,\n            invalidFormat   : false,\n            userInvalidated : false,\n            iso             : false,\n            parsedDateParts : [],\n            meridiem        : null,\n            rfc2822         : false,\n            weekdayMismatch : false\n        };\n    }\n\n    function getParsingFlags(m) {\n        if (m._pf == null) {\n            m._pf = defaultParsingFlags();\n        }\n        return m._pf;\n    }\n\n    var some;\n    if (Array.prototype.some) {\n        some = Array.prototype.some;\n    } else {\n        some = function (fun) {\n            var t = Object(this);\n            var len = t.length >>> 0;\n\n            for (var i = 0; i < len; i++) {\n                if (i in t && fun.call(this, t[i], i, t)) {\n                    return true;\n                }\n            }\n\n            return false;\n        };\n    }\n\n    function isValid(m) {\n        if (m._isValid == null) {\n            var flags = getParsingFlags(m);\n            var parsedParts = some.call(flags.parsedDateParts, function (i) {\n                return i != null;\n            });\n            var isNowValid = !isNaN(m._d.getTime()) &&\n                flags.overflow < 0 &&\n                !flags.empty &&\n                !flags.invalidMonth &&\n                !flags.invalidWeekday &&\n                !flags.weekdayMismatch &&\n                !flags.nullInput &&\n                !flags.invalidFormat &&\n                !flags.userInvalidated &&\n                (!flags.meridiem || (flags.meridiem && parsedParts));\n\n            if (m._strict) {\n                isNowValid = isNowValid &&\n                    flags.charsLeftOver === 0 &&\n                    flags.unusedTokens.length === 0 &&\n                    flags.bigHour === undefined;\n            }\n\n            if (Object.isFrozen == null || !Object.isFrozen(m)) {\n                m._isValid = isNowValid;\n            }\n            else {\n                return isNowValid;\n            }\n        }\n        return m._isValid;\n    }\n\n    function createInvalid (flags) {\n        var m = createUTC(NaN);\n        if (flags != null) {\n            extend(getParsingFlags(m), flags);\n        }\n        else {\n            getParsingFlags(m).userInvalidated = true;\n        }\n\n        return m;\n    }\n\n    // Plugins that add properties should also add the key here (null value),\n    // so we can properly clone ourselves.\n    var momentProperties = hooks.momentProperties = [];\n\n    function copyConfig(to, from) {\n        var i, prop, val;\n\n        if (!isUndefined(from._isAMomentObject)) {\n            to._isAMomentObject = from._isAMomentObject;\n        }\n        if (!isUndefined(from._i)) {\n            to._i = from._i;\n        }\n        if (!isUndefined(from._f)) {\n            to._f = from._f;\n        }\n        if (!isUndefined(from._l)) {\n            to._l = from._l;\n        }\n        if (!isUndefined(from._strict)) {\n            to._strict = from._strict;\n        }\n        if (!isUndefined(from._tzm)) {\n            to._tzm = from._tzm;\n        }\n        if (!isUndefined(from._isUTC)) {\n            to._isUTC = from._isUTC;\n        }\n        if (!isUndefined(from._offset)) {\n            to._offset = from._offset;\n        }\n        if (!isUndefined(from._pf)) {\n            to._pf = getParsingFlags(from);\n        }\n        if (!isUndefined(from._locale)) {\n            to._locale = from._locale;\n        }\n\n        if (momentProperties.length > 0) {\n            for (i = 0; i < momentProperties.length; i++) {\n                prop = momentProperties[i];\n                val = from[prop];\n                if (!isUndefined(val)) {\n                    to[prop] = val;\n                }\n            }\n        }\n\n        return to;\n    }\n\n    var updateInProgress = false;\n\n    // Moment prototype object\n    function Moment(config) {\n        copyConfig(this, config);\n        this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n        if (!this.isValid()) {\n            this._d = new Date(NaN);\n        }\n        // Prevent infinite loop in case updateOffset creates new moment\n        // objects.\n        if (updateInProgress === false) {\n            updateInProgress = true;\n            hooks.updateOffset(this);\n            updateInProgress = false;\n        }\n    }\n\n    function isMoment (obj) {\n        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);\n    }\n\n    function absFloor (number) {\n        if (number < 0) {\n            // -0 -> 0\n            return Math.ceil(number) || 0;\n        } else {\n            return Math.floor(number);\n        }\n    }\n\n    function toInt(argumentForCoercion) {\n        var coercedNumber = +argumentForCoercion,\n            value = 0;\n\n        if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n            value = absFloor(coercedNumber);\n        }\n\n        return value;\n    }\n\n    // compare two arrays, return the number of differences\n    function compareArrays(array1, array2, dontConvert) {\n        var len = Math.min(array1.length, array2.length),\n            lengthDiff = Math.abs(array1.length - array2.length),\n            diffs = 0,\n            i;\n        for (i = 0; i < len; i++) {\n            if ((dontConvert && array1[i] !== array2[i]) ||\n                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {\n                diffs++;\n            }\n        }\n        return diffs + lengthDiff;\n    }\n\n    function warn(msg) {\n        if (hooks.suppressDeprecationWarnings === false &&\n                (typeof console !==  'undefined') && console.warn) {\n            console.warn('Deprecation warning: ' + msg);\n        }\n    }\n\n    function deprecate(msg, fn) {\n        var firstTime = true;\n\n        return extend(function () {\n            if (hooks.deprecationHandler != null) {\n                hooks.deprecationHandler(null, msg);\n            }\n            if (firstTime) {\n                var args = [];\n                var arg;\n                for (var i = 0; i < arguments.length; i++) {\n                    arg = '';\n                    if (typeof arguments[i] === 'object') {\n                        arg += '\\n[' + i + '] ';\n                        for (var key in arguments[0]) {\n                            arg += key + ': ' + arguments[0][key] + ', ';\n                        }\n                        arg = arg.slice(0, -2); // Remove trailing comma and space\n                    } else {\n                        arg = arguments[i];\n                    }\n                    args.push(arg);\n                }\n                warn(msg + '\\nArguments: ' + Array.prototype.slice.call(args).join('') + '\\n' + (new Error()).stack);\n                firstTime = false;\n            }\n            return fn.apply(this, arguments);\n        }, fn);\n    }\n\n    var deprecations = {};\n\n    function deprecateSimple(name, msg) {\n        if (hooks.deprecationHandler != null) {\n            hooks.deprecationHandler(name, msg);\n        }\n        if (!deprecations[name]) {\n            warn(msg);\n            deprecations[name] = true;\n        }\n    }\n\n    hooks.suppressDeprecationWarnings = false;\n    hooks.deprecationHandler = null;\n\n    function isFunction(input) {\n        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';\n    }\n\n    function set (config) {\n        var prop, i;\n        for (i in config) {\n            prop = config[i];\n            if (isFunction(prop)) {\n                this[i] = prop;\n            } else {\n                this['_' + i] = prop;\n            }\n        }\n        this._config = config;\n        // Lenient ordinal parsing accepts just a number in addition to\n        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        this._dayOfMonthOrdinalParseLenient = new RegExp(\n            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +\n                '|' + (/\\d{1,2}/).source);\n    }\n\n    function mergeConfigs(parentConfig, childConfig) {\n        var res = extend({}, parentConfig), prop;\n        for (prop in childConfig) {\n            if (hasOwnProp(childConfig, prop)) {\n                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\n                    res[prop] = {};\n                    extend(res[prop], parentConfig[prop]);\n                    extend(res[prop], childConfig[prop]);\n                } else if (childConfig[prop] != null) {\n                    res[prop] = childConfig[prop];\n                } else {\n                    delete res[prop];\n                }\n            }\n        }\n        for (prop in parentConfig) {\n            if (hasOwnProp(parentConfig, prop) &&\n                    !hasOwnProp(childConfig, prop) &&\n                    isObject(parentConfig[prop])) {\n                // make sure changes to properties don't modify parent config\n                res[prop] = extend({}, res[prop]);\n            }\n        }\n        return res;\n    }\n\n    function Locale(config) {\n        if (config != null) {\n            this.set(config);\n        }\n    }\n\n    var keys;\n\n    if (Object.keys) {\n        keys = Object.keys;\n    } else {\n        keys = function (obj) {\n            var i, res = [];\n            for (i in obj) {\n                if (hasOwnProp(obj, i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        };\n    }\n\n    var defaultCalendar = {\n        sameDay : '[Today at] LT',\n        nextDay : '[Tomorrow at] LT',\n        nextWeek : 'dddd [at] LT',\n        lastDay : '[Yesterday at] LT',\n        lastWeek : '[Last] dddd [at] LT',\n        sameElse : 'L'\n    };\n\n    function calendar (key, mom, now) {\n        var output = this._calendar[key] || this._calendar['sameElse'];\n        return isFunction(output) ? output.call(mom, now) : output;\n    }\n\n    var defaultLongDateFormat = {\n        LTS  : 'h:mm:ss A',\n        LT   : 'h:mm A',\n        L    : 'MM/DD/YYYY',\n        LL   : 'MMMM D, YYYY',\n        LLL  : 'MMMM D, YYYY h:mm A',\n        LLLL : 'dddd, MMMM D, YYYY h:mm A'\n    };\n\n    function longDateFormat (key) {\n        var format = this._longDateFormat[key],\n            formatUpper = this._longDateFormat[key.toUpperCase()];\n\n        if (format || !formatUpper) {\n            return format;\n        }\n\n        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {\n            return val.slice(1);\n        });\n\n        return this._longDateFormat[key];\n    }\n\n    var defaultInvalidDate = 'Invalid date';\n\n    function invalidDate () {\n        return this._invalidDate;\n    }\n\n    var defaultOrdinal = '%d';\n    var defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\n\n    function ordinal (number) {\n        return this._ordinal.replace('%d', number);\n    }\n\n    var defaultRelativeTime = {\n        future : 'in %s',\n        past   : '%s ago',\n        s  : 'a few seconds',\n        ss : '%d seconds',\n        m  : 'a minute',\n        mm : '%d minutes',\n        h  : 'an hour',\n        hh : '%d hours',\n        d  : 'a day',\n        dd : '%d days',\n        M  : 'a month',\n        MM : '%d months',\n        y  : 'a year',\n        yy : '%d years'\n    };\n\n    function relativeTime (number, withoutSuffix, string, isFuture) {\n        var output = this._relativeTime[string];\n        return (isFunction(output)) ?\n            output(number, withoutSuffix, string, isFuture) :\n            output.replace(/%d/i, number);\n    }\n\n    function pastFuture (diff, output) {\n        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n        return isFunction(format) ? format(output) : format.replace(/%s/i, output);\n    }\n\n    var aliases = {};\n\n    function addUnitAlias (unit, shorthand) {\n        var lowerCase = unit.toLowerCase();\n        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\n    }\n\n    function normalizeUnits(units) {\n        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;\n    }\n\n    function normalizeObjectUnits(inputObject) {\n        var normalizedInput = {},\n            normalizedProp,\n            prop;\n\n        for (prop in inputObject) {\n            if (hasOwnProp(inputObject, prop)) {\n                normalizedProp = normalizeUnits(prop);\n                if (normalizedProp) {\n                    normalizedInput[normalizedProp] = inputObject[prop];\n                }\n            }\n        }\n\n        return normalizedInput;\n    }\n\n    var priorities = {};\n\n    function addUnitPriority(unit, priority) {\n        priorities[unit] = priority;\n    }\n\n    function getPrioritizedUnits(unitsObj) {\n        var units = [];\n        for (var u in unitsObj) {\n            units.push({unit: u, priority: priorities[u]});\n        }\n        units.sort(function (a, b) {\n            return a.priority - b.priority;\n        });\n        return units;\n    }\n\n    function zeroFill(number, targetLength, forceSign) {\n        var absNumber = '' + Math.abs(number),\n            zerosToFill = targetLength - absNumber.length,\n            sign = number >= 0;\n        return (sign ? (forceSign ? '+' : '') : '-') +\n            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\n    }\n\n    var formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;\n\n    var localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g;\n\n    var formatFunctions = {};\n\n    var formatTokenFunctions = {};\n\n    // token:    'M'\n    // padded:   ['MM', 2]\n    // ordinal:  'Mo'\n    // callback: function () { this.month() + 1 }\n    function addFormatToken (token, padded, ordinal, callback) {\n        var func = callback;\n        if (typeof callback === 'string') {\n            func = function () {\n                return this[callback]();\n            };\n        }\n        if (token) {\n            formatTokenFunctions[token] = func;\n        }\n        if (padded) {\n            formatTokenFunctions[padded[0]] = function () {\n                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n            };\n        }\n        if (ordinal) {\n            formatTokenFunctions[ordinal] = function () {\n                return this.localeData().ordinal(func.apply(this, arguments), token);\n            };\n        }\n    }\n\n    function removeFormattingTokens(input) {\n        if (input.match(/\\[[\\s\\S]/)) {\n            return input.replace(/^\\[|\\]$/g, '');\n        }\n        return input.replace(/\\\\/g, '');\n    }\n\n    function makeFormatFunction(format) {\n        var array = format.match(formattingTokens), i, length;\n\n        for (i = 0, length = array.length; i < length; i++) {\n            if (formatTokenFunctions[array[i]]) {\n                array[i] = formatTokenFunctions[array[i]];\n            } else {\n                array[i] = removeFormattingTokens(array[i]);\n            }\n        }\n\n        return function (mom) {\n            var output = '', i;\n            for (i = 0; i < length; i++) {\n                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];\n            }\n            return output;\n        };\n    }\n\n    // format date using native date object\n    function formatMoment(m, format) {\n        if (!m.isValid()) {\n            return m.localeData().invalidDate();\n        }\n\n        format = expandFormat(format, m.localeData());\n        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\n\n        return formatFunctions[format](m);\n    }\n\n    function expandFormat(format, locale) {\n        var i = 5;\n\n        function replaceLongDateFormatTokens(input) {\n            return locale.longDateFormat(input) || input;\n        }\n\n        localFormattingTokens.lastIndex = 0;\n        while (i >= 0 && localFormattingTokens.test(format)) {\n            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n            localFormattingTokens.lastIndex = 0;\n            i -= 1;\n        }\n\n        return format;\n    }\n\n    var match1         = /\\d/;            //       0 - 9\n    var match2         = /\\d\\d/;          //      00 - 99\n    var match3         = /\\d{3}/;         //     000 - 999\n    var match4         = /\\d{4}/;         //    0000 - 9999\n    var match6         = /[+-]?\\d{6}/;    // -999999 - 999999\n    var match1to2      = /\\d\\d?/;         //       0 - 99\n    var match3to4      = /\\d\\d\\d\\d?/;     //     999 - 9999\n    var match5to6      = /\\d\\d\\d\\d\\d\\d?/; //   99999 - 999999\n    var match1to3      = /\\d{1,3}/;       //       0 - 999\n    var match1to4      = /\\d{1,4}/;       //       0 - 9999\n    var match1to6      = /[+-]?\\d{1,6}/;  // -999999 - 999999\n\n    var matchUnsigned  = /\\d+/;           //       0 - inf\n    var matchSigned    = /[+-]?\\d+/;      //    -inf - inf\n\n    var matchOffset    = /Z|[+-]\\d\\d:?\\d\\d/gi; // +00:00 -00:00 +0000 -0000 or Z\n    var matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z\n\n    var matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/; // 123456789 123456789.123\n\n    // any word (or two) characters or numbers including two/three word month in arabic.\n    // includes scottish gaelic two word and hyphenated months\n    var matchWord = /[0-9]{0,256}['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFF07\\uFF10-\\uFFEF]{1,256}|[\\u0600-\\u06FF\\/]{1,256}(\\s*?[\\u0600-\\u06FF]{1,256}){1,2}/i;\n\n    var regexes = {};\n\n    function addRegexToken (token, regex, strictRegex) {\n        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {\n            return (isStrict && strictRegex) ? strictRegex : regex;\n        };\n    }\n\n    function getParseRegexForToken (token, config) {\n        if (!hasOwnProp(regexes, token)) {\n            return new RegExp(unescapeFormat(token));\n        }\n\n        return regexes[token](config._strict, config._locale);\n    }\n\n    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n    function unescapeFormat(s) {\n        return regexEscape(s.replace('\\\\', '').replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {\n            return p1 || p2 || p3 || p4;\n        }));\n    }\n\n    function regexEscape(s) {\n        return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    }\n\n    var tokens = {};\n\n    function addParseToken (token, callback) {\n        var i, func = callback;\n        if (typeof token === 'string') {\n            token = [token];\n        }\n        if (isNumber(callback)) {\n            func = function (input, array) {\n                array[callback] = toInt(input);\n            };\n        }\n        for (i = 0; i < token.length; i++) {\n            tokens[token[i]] = func;\n        }\n    }\n\n    function addWeekParseToken (token, callback) {\n        addParseToken(token, function (input, array, config, token) {\n            config._w = config._w || {};\n            callback(input, config._w, config, token);\n        });\n    }\n\n    function addTimeToArrayFromToken(token, input, config) {\n        if (input != null && hasOwnProp(tokens, token)) {\n            tokens[token](input, config._a, config, token);\n        }\n    }\n\n    var YEAR = 0;\n    var MONTH = 1;\n    var DATE = 2;\n    var HOUR = 3;\n    var MINUTE = 4;\n    var SECOND = 5;\n    var MILLISECOND = 6;\n    var WEEK = 7;\n    var WEEKDAY = 8;\n\n    // FORMATTING\n\n    addFormatToken('Y', 0, 0, function () {\n        var y = this.year();\n        return y <= 9999 ? '' + y : '+' + y;\n    });\n\n    addFormatToken(0, ['YY', 2], 0, function () {\n        return this.year() % 100;\n    });\n\n    addFormatToken(0, ['YYYY',   4],       0, 'year');\n    addFormatToken(0, ['YYYYY',  5],       0, 'year');\n    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\n\n    // ALIASES\n\n    addUnitAlias('year', 'y');\n\n    // PRIORITIES\n\n    addUnitPriority('year', 1);\n\n    // PARSING\n\n    addRegexToken('Y',      matchSigned);\n    addRegexToken('YY',     match1to2, match2);\n    addRegexToken('YYYY',   match1to4, match4);\n    addRegexToken('YYYYY',  match1to6, match6);\n    addRegexToken('YYYYYY', match1to6, match6);\n\n    addParseToken(['YYYYY', 'YYYYYY'], YEAR);\n    addParseToken('YYYY', function (input, array) {\n        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\n    });\n    addParseToken('YY', function (input, array) {\n        array[YEAR] = hooks.parseTwoDigitYear(input);\n    });\n    addParseToken('Y', function (input, array) {\n        array[YEAR] = parseInt(input, 10);\n    });\n\n    // HELPERS\n\n    function daysInYear(year) {\n        return isLeapYear(year) ? 366 : 365;\n    }\n\n    function isLeapYear(year) {\n        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n    }\n\n    // HOOKS\n\n    hooks.parseTwoDigitYear = function (input) {\n        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n    };\n\n    // MOMENTS\n\n    var getSetYear = makeGetSet('FullYear', true);\n\n    function getIsLeapYear () {\n        return isLeapYear(this.year());\n    }\n\n    function makeGetSet (unit, keepTime) {\n        return function (value) {\n            if (value != null) {\n                set$1(this, unit, value);\n                hooks.updateOffset(this, keepTime);\n                return this;\n            } else {\n                return get(this, unit);\n            }\n        };\n    }\n\n    function get (mom, unit) {\n        return mom.isValid() ?\n            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;\n    }\n\n    function set$1 (mom, unit, value) {\n        if (mom.isValid() && !isNaN(value)) {\n            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {\n                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));\n            }\n            else {\n                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function stringGet (units) {\n        units = normalizeUnits(units);\n        if (isFunction(this[units])) {\n            return this[units]();\n        }\n        return this;\n    }\n\n\n    function stringSet (units, value) {\n        if (typeof units === 'object') {\n            units = normalizeObjectUnits(units);\n            var prioritized = getPrioritizedUnits(units);\n            for (var i = 0; i < prioritized.length; i++) {\n                this[prioritized[i].unit](units[prioritized[i].unit]);\n            }\n        } else {\n            units = normalizeUnits(units);\n            if (isFunction(this[units])) {\n                return this[units](value);\n            }\n        }\n        return this;\n    }\n\n    function mod(n, x) {\n        return ((n % x) + x) % x;\n    }\n\n    var indexOf;\n\n    if (Array.prototype.indexOf) {\n        indexOf = Array.prototype.indexOf;\n    } else {\n        indexOf = function (o) {\n            // I know\n            var i;\n            for (i = 0; i < this.length; ++i) {\n                if (this[i] === o) {\n                    return i;\n                }\n            }\n            return -1;\n        };\n    }\n\n    function daysInMonth(year, month) {\n        if (isNaN(year) || isNaN(month)) {\n            return NaN;\n        }\n        var modMonth = mod(month, 12);\n        year += (month - modMonth) / 12;\n        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);\n    }\n\n    // FORMATTING\n\n    addFormatToken('M', ['MM', 2], 'Mo', function () {\n        return this.month() + 1;\n    });\n\n    addFormatToken('MMM', 0, 0, function (format) {\n        return this.localeData().monthsShort(this, format);\n    });\n\n    addFormatToken('MMMM', 0, 0, function (format) {\n        return this.localeData().months(this, format);\n    });\n\n    // ALIASES\n\n    addUnitAlias('month', 'M');\n\n    // PRIORITY\n\n    addUnitPriority('month', 8);\n\n    // PARSING\n\n    addRegexToken('M',    match1to2);\n    addRegexToken('MM',   match1to2, match2);\n    addRegexToken('MMM',  function (isStrict, locale) {\n        return locale.monthsShortRegex(isStrict);\n    });\n    addRegexToken('MMMM', function (isStrict, locale) {\n        return locale.monthsRegex(isStrict);\n    });\n\n    addParseToken(['M', 'MM'], function (input, array) {\n        array[MONTH] = toInt(input) - 1;\n    });\n\n    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\n        var month = config._locale.monthsParse(input, token, config._strict);\n        // if we didn't find a month name, mark the date as invalid.\n        if (month != null) {\n            array[MONTH] = month;\n        } else {\n            getParsingFlags(config).invalidMonth = input;\n        }\n    });\n\n    // LOCALES\n\n    var MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/;\n    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');\n    function localeMonths (m, format) {\n        if (!m) {\n            return isArray(this._months) ? this._months :\n                this._months['standalone'];\n        }\n        return isArray(this._months) ? this._months[m.month()] :\n            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];\n    }\n\n    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');\n    function localeMonthsShort (m, format) {\n        if (!m) {\n            return isArray(this._monthsShort) ? this._monthsShort :\n                this._monthsShort['standalone'];\n        }\n        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :\n            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];\n    }\n\n    function handleStrictParse(monthName, format, strict) {\n        var i, ii, mom, llc = monthName.toLocaleLowerCase();\n        if (!this._monthsParse) {\n            // this is not used\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n            for (i = 0; i < 12; ++i) {\n                mom = createUTC([2000, i]);\n                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();\n                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\n            }\n        }\n\n        if (strict) {\n            if (format === 'MMM') {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === 'MMM') {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n\n    function localeMonthsParse (monthName, format, strict) {\n        var i, mom, regex;\n\n        if (this._monthsParseExact) {\n            return handleStrictParse.call(this, monthName, format, strict);\n        }\n\n        if (!this._monthsParse) {\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n        }\n\n        // TODO: add sorting\n        // Sorting makes sure if one month (or abbr) is a prefix of another\n        // see sorting in computeMonthsParse\n        for (i = 0; i < 12; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, i]);\n            if (strict && !this._longMonthsParse[i]) {\n                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\n                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\n            }\n            if (!strict && !this._monthsParse[i]) {\n                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (!strict && this._monthsParse[i].test(monthName)) {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function setMonth (mom, value) {\n        var dayOfMonth;\n\n        if (!mom.isValid()) {\n            // No op\n            return mom;\n        }\n\n        if (typeof value === 'string') {\n            if (/^\\d+$/.test(value)) {\n                value = toInt(value);\n            } else {\n                value = mom.localeData().monthsParse(value);\n                // TODO: Another silent failure?\n                if (!isNumber(value)) {\n                    return mom;\n                }\n            }\n        }\n\n        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\n        return mom;\n    }\n\n    function getSetMonth (value) {\n        if (value != null) {\n            setMonth(this, value);\n            hooks.updateOffset(this, true);\n            return this;\n        } else {\n            return get(this, 'Month');\n        }\n    }\n\n    function getDaysInMonth () {\n        return daysInMonth(this.year(), this.month());\n    }\n\n    var defaultMonthsShortRegex = matchWord;\n    function monthsShortRegex (isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsShortStrictRegex;\n            } else {\n                return this._monthsShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_monthsShortRegex')) {\n                this._monthsShortRegex = defaultMonthsShortRegex;\n            }\n            return this._monthsShortStrictRegex && isStrict ?\n                this._monthsShortStrictRegex : this._monthsShortRegex;\n        }\n    }\n\n    var defaultMonthsRegex = matchWord;\n    function monthsRegex (isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsStrictRegex;\n            } else {\n                return this._monthsRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                this._monthsRegex = defaultMonthsRegex;\n            }\n            return this._monthsStrictRegex && isStrict ?\n                this._monthsStrictRegex : this._monthsRegex;\n        }\n    }\n\n    function computeMonthsParse () {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n\n        var shortPieces = [], longPieces = [], mixedPieces = [],\n            i, mom;\n        for (i = 0; i < 12; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, i]);\n            shortPieces.push(this.monthsShort(mom, ''));\n            longPieces.push(this.months(mom, ''));\n            mixedPieces.push(this.months(mom, ''));\n            mixedPieces.push(this.monthsShort(mom, ''));\n        }\n        // Sorting makes sure if one month (or abbr) is a prefix of another it\n        // will match the longer piece.\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n        for (i = 0; i < 12; i++) {\n            shortPieces[i] = regexEscape(shortPieces[i]);\n            longPieces[i] = regexEscape(longPieces[i]);\n        }\n        for (i = 0; i < 24; i++) {\n            mixedPieces[i] = regexEscape(mixedPieces[i]);\n        }\n\n        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n        this._monthsShortRegex = this._monthsRegex;\n        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n    }\n\n    function createDate (y, m, d, h, M, s, ms) {\n        // can't just apply() to create a date:\n        // https://stackoverflow.com/q/181348\n        var date = new Date(y, m, d, h, M, s, ms);\n\n        // the date constructor remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {\n            date.setFullYear(y);\n        }\n        return date;\n    }\n\n    function createUTCDate (y) {\n        var date = new Date(Date.UTC.apply(null, arguments));\n\n        // the Date.UTC function remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {\n            date.setUTCFullYear(y);\n        }\n        return date;\n    }\n\n    // start-of-first-week - start-of-year\n    function firstWeekOffset(year, dow, doy) {\n        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n            fwd = 7 + dow - doy,\n            // first-week day local weekday -- which local weekday is fwd\n            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\n\n        return -fwdlw + fwd - 1;\n    }\n\n    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {\n        var localWeekday = (7 + weekday - dow) % 7,\n            weekOffset = firstWeekOffset(year, dow, doy),\n            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\n            resYear, resDayOfYear;\n\n        if (dayOfYear <= 0) {\n            resYear = year - 1;\n            resDayOfYear = daysInYear(resYear) + dayOfYear;\n        } else if (dayOfYear > daysInYear(year)) {\n            resYear = year + 1;\n            resDayOfYear = dayOfYear - daysInYear(year);\n        } else {\n            resYear = year;\n            resDayOfYear = dayOfYear;\n        }\n\n        return {\n            year: resYear,\n            dayOfYear: resDayOfYear\n        };\n    }\n\n    function weekOfYear(mom, dow, doy) {\n        var weekOffset = firstWeekOffset(mom.year(), dow, doy),\n            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\n            resWeek, resYear;\n\n        if (week < 1) {\n            resYear = mom.year() - 1;\n            resWeek = week + weeksInYear(resYear, dow, doy);\n        } else if (week > weeksInYear(mom.year(), dow, doy)) {\n            resWeek = week - weeksInYear(mom.year(), dow, doy);\n            resYear = mom.year() + 1;\n        } else {\n            resYear = mom.year();\n            resWeek = week;\n        }\n\n        return {\n            week: resWeek,\n            year: resYear\n        };\n    }\n\n    function weeksInYear(year, dow, doy) {\n        var weekOffset = firstWeekOffset(year, dow, doy),\n            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\n        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\n    }\n\n    // FORMATTING\n\n    addFormatToken('w', ['ww', 2], 'wo', 'week');\n    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\n\n    // ALIASES\n\n    addUnitAlias('week', 'w');\n    addUnitAlias('isoWeek', 'W');\n\n    // PRIORITIES\n\n    addUnitPriority('week', 5);\n    addUnitPriority('isoWeek', 5);\n\n    // PARSING\n\n    addRegexToken('w',  match1to2);\n    addRegexToken('ww', match1to2, match2);\n    addRegexToken('W',  match1to2);\n    addRegexToken('WW', match1to2, match2);\n\n    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {\n        week[token.substr(0, 1)] = toInt(input);\n    });\n\n    // HELPERS\n\n    // LOCALES\n\n    function localeWeek (mom) {\n        return weekOfYear(mom, this._week.dow, this._week.doy).week;\n    }\n\n    var defaultLocaleWeek = {\n        dow : 0, // Sunday is the first day of the week.\n        doy : 6  // The week that contains Jan 1st is the first week of the year.\n    };\n\n    function localeFirstDayOfWeek () {\n        return this._week.dow;\n    }\n\n    function localeFirstDayOfYear () {\n        return this._week.doy;\n    }\n\n    // MOMENTS\n\n    function getSetWeek (input) {\n        var week = this.localeData().week(this);\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    function getSetISOWeek (input) {\n        var week = weekOfYear(this, 1, 4).week;\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    // FORMATTING\n\n    addFormatToken('d', 0, 'do', 'day');\n\n    addFormatToken('dd', 0, 0, function (format) {\n        return this.localeData().weekdaysMin(this, format);\n    });\n\n    addFormatToken('ddd', 0, 0, function (format) {\n        return this.localeData().weekdaysShort(this, format);\n    });\n\n    addFormatToken('dddd', 0, 0, function (format) {\n        return this.localeData().weekdays(this, format);\n    });\n\n    addFormatToken('e', 0, 0, 'weekday');\n    addFormatToken('E', 0, 0, 'isoWeekday');\n\n    // ALIASES\n\n    addUnitAlias('day', 'd');\n    addUnitAlias('weekday', 'e');\n    addUnitAlias('isoWeekday', 'E');\n\n    // PRIORITY\n    addUnitPriority('day', 11);\n    addUnitPriority('weekday', 11);\n    addUnitPriority('isoWeekday', 11);\n\n    // PARSING\n\n    addRegexToken('d',    match1to2);\n    addRegexToken('e',    match1to2);\n    addRegexToken('E',    match1to2);\n    addRegexToken('dd',   function (isStrict, locale) {\n        return locale.weekdaysMinRegex(isStrict);\n    });\n    addRegexToken('ddd',   function (isStrict, locale) {\n        return locale.weekdaysShortRegex(isStrict);\n    });\n    addRegexToken('dddd',   function (isStrict, locale) {\n        return locale.weekdaysRegex(isStrict);\n    });\n\n    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {\n        var weekday = config._locale.weekdaysParse(input, token, config._strict);\n        // if we didn't get a weekday name, mark the date as invalid\n        if (weekday != null) {\n            week.d = weekday;\n        } else {\n            getParsingFlags(config).invalidWeekday = input;\n        }\n    });\n\n    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\n        week[token] = toInt(input);\n    });\n\n    // HELPERS\n\n    function parseWeekday(input, locale) {\n        if (typeof input !== 'string') {\n            return input;\n        }\n\n        if (!isNaN(input)) {\n            return parseInt(input, 10);\n        }\n\n        input = locale.weekdaysParse(input);\n        if (typeof input === 'number') {\n            return input;\n        }\n\n        return null;\n    }\n\n    function parseIsoWeekday(input, locale) {\n        if (typeof input === 'string') {\n            return locale.weekdaysParse(input) % 7 || 7;\n        }\n        return isNaN(input) ? null : input;\n    }\n\n    // LOCALES\n\n    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');\n    function localeWeekdays (m, format) {\n        if (!m) {\n            return isArray(this._weekdays) ? this._weekdays :\n                this._weekdays['standalone'];\n        }\n        return isArray(this._weekdays) ? this._weekdays[m.day()] :\n            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];\n    }\n\n    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');\n    function localeWeekdaysShort (m) {\n        return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;\n    }\n\n    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');\n    function localeWeekdaysMin (m) {\n        return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;\n    }\n\n    function handleStrictParse$1(weekdayName, format, strict) {\n        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._minWeekdaysParse = [];\n\n            for (i = 0; i < 7; ++i) {\n                mom = createUTC([2000, 1]).day(i);\n                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();\n                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();\n                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();\n            }\n        }\n\n        if (strict) {\n            if (format === 'dddd') {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === 'ddd') {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === 'dddd') {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === 'ddd') {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n\n    function localeWeekdaysParse (weekdayName, format, strict) {\n        var i, mom, regex;\n\n        if (this._weekdaysParseExact) {\n            return handleStrictParse$1.call(this, weekdayName, format, strict);\n        }\n\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._minWeekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._fullWeekdaysParse = [];\n        }\n\n        for (i = 0; i < 7; i++) {\n            // make the regex if we don't have it already\n\n            mom = createUTC([2000, 1]).day(i);\n            if (strict && !this._fullWeekdaysParse[i]) {\n                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\\\.?') + '$', 'i');\n                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\\\.?') + '$', 'i');\n                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\\\.?') + '$', 'i');\n            }\n            if (!this._weekdaysParse[i]) {\n                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\n                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function getSetDayOfWeek (input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n        if (input != null) {\n            input = parseWeekday(input, this.localeData());\n            return this.add(input - day, 'd');\n        } else {\n            return day;\n        }\n    }\n\n    function getSetLocaleDayOfWeek (input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n        return input == null ? weekday : this.add(input - weekday, 'd');\n    }\n\n    function getSetISODayOfWeek (input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n\n        // behaves the same as moment#day except\n        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n        // as a setter, sunday should belong to the previous week.\n\n        if (input != null) {\n            var weekday = parseIsoWeekday(input, this.localeData());\n            return this.day(this.day() % 7 ? weekday : weekday - 7);\n        } else {\n            return this.day() || 7;\n        }\n    }\n\n    var defaultWeekdaysRegex = matchWord;\n    function weekdaysRegex (isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysStrictRegex;\n            } else {\n                return this._weekdaysRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                this._weekdaysRegex = defaultWeekdaysRegex;\n            }\n            return this._weekdaysStrictRegex && isStrict ?\n                this._weekdaysStrictRegex : this._weekdaysRegex;\n        }\n    }\n\n    var defaultWeekdaysShortRegex = matchWord;\n    function weekdaysShortRegex (isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysShortStrictRegex;\n            } else {\n                return this._weekdaysShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysShortRegex')) {\n                this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n            }\n            return this._weekdaysShortStrictRegex && isStrict ?\n                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\n        }\n    }\n\n    var defaultWeekdaysMinRegex = matchWord;\n    function weekdaysMinRegex (isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysMinStrictRegex;\n            } else {\n                return this._weekdaysMinRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysMinRegex')) {\n                this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n            }\n            return this._weekdaysMinStrictRegex && isStrict ?\n                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\n        }\n    }\n\n\n    function computeWeekdaysParse () {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n\n        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],\n            i, mom, minp, shortp, longp;\n        for (i = 0; i < 7; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, 1]).day(i);\n            minp = this.weekdaysMin(mom, '');\n            shortp = this.weekdaysShort(mom, '');\n            longp = this.weekdays(mom, '');\n            minPieces.push(minp);\n            shortPieces.push(shortp);\n            longPieces.push(longp);\n            mixedPieces.push(minp);\n            mixedPieces.push(shortp);\n            mixedPieces.push(longp);\n        }\n        // Sorting makes sure if one weekday (or abbr) is a prefix of another it\n        // will match the longer piece.\n        minPieces.sort(cmpLenRev);\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n        for (i = 0; i < 7; i++) {\n            shortPieces[i] = regexEscape(shortPieces[i]);\n            longPieces[i] = regexEscape(longPieces[i]);\n            mixedPieces[i] = regexEscape(mixedPieces[i]);\n        }\n\n        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n        this._weekdaysShortRegex = this._weekdaysRegex;\n        this._weekdaysMinRegex = this._weekdaysRegex;\n\n        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');\n    }\n\n    // FORMATTING\n\n    function hFormat() {\n        return this.hours() % 12 || 12;\n    }\n\n    function kFormat() {\n        return this.hours() || 24;\n    }\n\n    addFormatToken('H', ['HH', 2], 0, 'hour');\n    addFormatToken('h', ['hh', 2], 0, hFormat);\n    addFormatToken('k', ['kk', 2], 0, kFormat);\n\n    addFormatToken('hmm', 0, 0, function () {\n        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);\n    });\n\n    addFormatToken('hmmss', 0, 0, function () {\n        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +\n            zeroFill(this.seconds(), 2);\n    });\n\n    addFormatToken('Hmm', 0, 0, function () {\n        return '' + this.hours() + zeroFill(this.minutes(), 2);\n    });\n\n    addFormatToken('Hmmss', 0, 0, function () {\n        return '' + this.hours() + zeroFill(this.minutes(), 2) +\n            zeroFill(this.seconds(), 2);\n    });\n\n    function meridiem (token, lowercase) {\n        addFormatToken(token, 0, 0, function () {\n            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\n        });\n    }\n\n    meridiem('a', true);\n    meridiem('A', false);\n\n    // ALIASES\n\n    addUnitAlias('hour', 'h');\n\n    // PRIORITY\n    addUnitPriority('hour', 13);\n\n    // PARSING\n\n    function matchMeridiem (isStrict, locale) {\n        return locale._meridiemParse;\n    }\n\n    addRegexToken('a',  matchMeridiem);\n    addRegexToken('A',  matchMeridiem);\n    addRegexToken('H',  match1to2);\n    addRegexToken('h',  match1to2);\n    addRegexToken('k',  match1to2);\n    addRegexToken('HH', match1to2, match2);\n    addRegexToken('hh', match1to2, match2);\n    addRegexToken('kk', match1to2, match2);\n\n    addRegexToken('hmm', match3to4);\n    addRegexToken('hmmss', match5to6);\n    addRegexToken('Hmm', match3to4);\n    addRegexToken('Hmmss', match5to6);\n\n    addParseToken(['H', 'HH'], HOUR);\n    addParseToken(['k', 'kk'], function (input, array, config) {\n        var kInput = toInt(input);\n        array[HOUR] = kInput === 24 ? 0 : kInput;\n    });\n    addParseToken(['a', 'A'], function (input, array, config) {\n        config._isPm = config._locale.isPM(input);\n        config._meridiem = input;\n    });\n    addParseToken(['h', 'hh'], function (input, array, config) {\n        array[HOUR] = toInt(input);\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('hmm', function (input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('hmmss', function (input, array, config) {\n        var pos1 = input.length - 4;\n        var pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('Hmm', function (input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n    });\n    addParseToken('Hmmss', function (input, array, config) {\n        var pos1 = input.length - 4;\n        var pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n    });\n\n    // LOCALES\n\n    function localeIsPM (input) {\n        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n        // Using charAt should be more compatible.\n        return ((input + '').toLowerCase().charAt(0) === 'p');\n    }\n\n    var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i;\n    function localeMeridiem (hours, minutes, isLower) {\n        if (hours > 11) {\n            return isLower ? 'pm' : 'PM';\n        } else {\n            return isLower ? 'am' : 'AM';\n        }\n    }\n\n\n    // MOMENTS\n\n    // Setting the hour should keep the time, because the user explicitly\n    // specified which hour they want. So trying to maintain the same hour (in\n    // a new timezone) makes sense. Adding/subtracting hours does not follow\n    // this rule.\n    var getSetHour = makeGetSet('Hours', true);\n\n    var baseConfig = {\n        calendar: defaultCalendar,\n        longDateFormat: defaultLongDateFormat,\n        invalidDate: defaultInvalidDate,\n        ordinal: defaultOrdinal,\n        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\n        relativeTime: defaultRelativeTime,\n\n        months: defaultLocaleMonths,\n        monthsShort: defaultLocaleMonthsShort,\n\n        week: defaultLocaleWeek,\n\n        weekdays: defaultLocaleWeekdays,\n        weekdaysMin: defaultLocaleWeekdaysMin,\n        weekdaysShort: defaultLocaleWeekdaysShort,\n\n        meridiemParse: defaultLocaleMeridiemParse\n    };\n\n    // internal storage for locale config files\n    var locales = {};\n    var localeFamilies = {};\n    var globalLocale;\n\n    function normalizeLocale(key) {\n        return key ? key.toLowerCase().replace('_', '-') : key;\n    }\n\n    // pick the locale from the array\n    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\n    function chooseLocale(names) {\n        var i = 0, j, next, locale, split;\n\n        while (i < names.length) {\n            split = normalizeLocale(names[i]).split('-');\n            j = split.length;\n            next = normalizeLocale(names[i + 1]);\n            next = next ? next.split('-') : null;\n            while (j > 0) {\n                locale = loadLocale(split.slice(0, j).join('-'));\n                if (locale) {\n                    return locale;\n                }\n                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {\n                    //the next array item is better than a shallower substring of this one\n                    break;\n                }\n                j--;\n            }\n            i++;\n        }\n        return globalLocale;\n    }\n\n    function loadLocale(name) {\n        var oldLocale = null;\n        // TODO: Find a better way to register and load all the locales in Node\n        if (!locales[name] && (typeof module !== 'undefined') &&\n                module && module.exports) {\n            try {\n                oldLocale = globalLocale._abbr;\n                var aliasedRequire = require;\n                aliasedRequire('./locale/' + name);\n                getSetGlobalLocale(oldLocale);\n            } catch (e) {}\n        }\n        return locales[name];\n    }\n\n    // This function will load locale and then set the global locale.  If\n    // no arguments are passed in, it will simply return the current global\n    // locale key.\n    function getSetGlobalLocale (key, values) {\n        var data;\n        if (key) {\n            if (isUndefined(values)) {\n                data = getLocale(key);\n            }\n            else {\n                data = defineLocale(key, values);\n            }\n\n            if (data) {\n                // moment.duration._locale = moment._locale = data;\n                globalLocale = data;\n            }\n            else {\n                if ((typeof console !==  'undefined') && console.warn) {\n                    //warn user if arguments are passed but the locale could not be set\n                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');\n                }\n            }\n        }\n\n        return globalLocale._abbr;\n    }\n\n    function defineLocale (name, config) {\n        if (config !== null) {\n            var locale, parentConfig = baseConfig;\n            config.abbr = name;\n            if (locales[name] != null) {\n                deprecateSimple('defineLocaleOverride',\n                        'use moment.updateLocale(localeName, config) to change ' +\n                        'an existing locale. moment.defineLocale(localeName, ' +\n                        'config) should only be used for creating a new locale ' +\n                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');\n                parentConfig = locales[name]._config;\n            } else if (config.parentLocale != null) {\n                if (locales[config.parentLocale] != null) {\n                    parentConfig = locales[config.parentLocale]._config;\n                } else {\n                    locale = loadLocale(config.parentLocale);\n                    if (locale != null) {\n                        parentConfig = locale._config;\n                    } else {\n                        if (!localeFamilies[config.parentLocale]) {\n                            localeFamilies[config.parentLocale] = [];\n                        }\n                        localeFamilies[config.parentLocale].push({\n                            name: name,\n                            config: config\n                        });\n                        return null;\n                    }\n                }\n            }\n            locales[name] = new Locale(mergeConfigs(parentConfig, config));\n\n            if (localeFamilies[name]) {\n                localeFamilies[name].forEach(function (x) {\n                    defineLocale(x.name, x.config);\n                });\n            }\n\n            // backwards compat for now: also set the locale\n            // make sure we set the locale AFTER all child locales have been\n            // created, so we won't end up with the child locale set.\n            getSetGlobalLocale(name);\n\n\n            return locales[name];\n        } else {\n            // useful for testing\n            delete locales[name];\n            return null;\n        }\n    }\n\n    function updateLocale(name, config) {\n        if (config != null) {\n            var locale, tmpLocale, parentConfig = baseConfig;\n            // MERGE\n            tmpLocale = loadLocale(name);\n            if (tmpLocale != null) {\n                parentConfig = tmpLocale._config;\n            }\n            config = mergeConfigs(parentConfig, config);\n            locale = new Locale(config);\n            locale.parentLocale = locales[name];\n            locales[name] = locale;\n\n            // backwards compat for now: also set the locale\n            getSetGlobalLocale(name);\n        } else {\n            // pass null for config to unupdate, useful for tests\n            if (locales[name] != null) {\n                if (locales[name].parentLocale != null) {\n                    locales[name] = locales[name].parentLocale;\n                } else if (locales[name] != null) {\n                    delete locales[name];\n                }\n            }\n        }\n        return locales[name];\n    }\n\n    // returns locale data\n    function getLocale (key) {\n        var locale;\n\n        if (key && key._locale && key._locale._abbr) {\n            key = key._locale._abbr;\n        }\n\n        if (!key) {\n            return globalLocale;\n        }\n\n        if (!isArray(key)) {\n            //short-circuit everything else\n            locale = loadLocale(key);\n            if (locale) {\n                return locale;\n            }\n            key = [key];\n        }\n\n        return chooseLocale(key);\n    }\n\n    function listLocales() {\n        return keys(locales);\n    }\n\n    function checkOverflow (m) {\n        var overflow;\n        var a = m._a;\n\n        if (a && getParsingFlags(m).overflow === -2) {\n            overflow =\n                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :\n                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :\n                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :\n                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :\n                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :\n                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :\n                -1;\n\n            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n                overflow = DATE;\n            }\n            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\n                overflow = WEEK;\n            }\n            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\n                overflow = WEEKDAY;\n            }\n\n            getParsingFlags(m).overflow = overflow;\n        }\n\n        return m;\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function currentDateArray(config) {\n        // hooks is actually the exported moment object\n        var nowValue = new Date(hooks.now());\n        if (config._useUTC) {\n            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];\n        }\n        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\n    }\n\n    // convert an array to a date.\n    // the array should mirror the parameters below\n    // note: all values past the year are optional and will default to the lowest possible value.\n    // [year, month, day , hour, minute, second, millisecond]\n    function configFromArray (config) {\n        var i, date, input = [], currentDate, expectedWeekday, yearToUse;\n\n        if (config._d) {\n            return;\n        }\n\n        currentDate = currentDateArray(config);\n\n        //compute day of the year from weeks and weekdays\n        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n            dayOfYearFromWeekInfo(config);\n        }\n\n        //if the day of the year is set, figure out what it is\n        if (config._dayOfYear != null) {\n            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n\n            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {\n                getParsingFlags(config)._overflowDayOfYear = true;\n            }\n\n            date = createUTCDate(yearToUse, 0, config._dayOfYear);\n            config._a[MONTH] = date.getUTCMonth();\n            config._a[DATE] = date.getUTCDate();\n        }\n\n        // Default to current date.\n        // * if no year, month, day of month are given, default to today\n        // * if day of month is given, default month and year\n        // * if month is given, default only year\n        // * if year is given, don't default anything\n        for (i = 0; i < 3 && config._a[i] == null; ++i) {\n            config._a[i] = input[i] = currentDate[i];\n        }\n\n        // Zero out whatever was not defaulted, including time\n        for (; i < 7; i++) {\n            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\n        }\n\n        // Check for 24:00:00.000\n        if (config._a[HOUR] === 24 &&\n                config._a[MINUTE] === 0 &&\n                config._a[SECOND] === 0 &&\n                config._a[MILLISECOND] === 0) {\n            config._nextDay = true;\n            config._a[HOUR] = 0;\n        }\n\n        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\n        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();\n\n        // Apply timezone offset from input. The actual utcOffset can be changed\n        // with parseZone.\n        if (config._tzm != null) {\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n        }\n\n        if (config._nextDay) {\n            config._a[HOUR] = 24;\n        }\n\n        // check for mismatching day of week\n        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {\n            getParsingFlags(config).weekdayMismatch = true;\n        }\n    }\n\n    function dayOfYearFromWeekInfo(config) {\n        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;\n\n        w = config._w;\n        if (w.GG != null || w.W != null || w.E != null) {\n            dow = 1;\n            doy = 4;\n\n            // TODO: We need to take the current isoWeekYear, but that depends on\n            // how we interpret now (local, utc, fixed offset). So create\n            // a now version of current config (take local/utc/offset flags, and\n            // create now).\n            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);\n            week = defaults(w.W, 1);\n            weekday = defaults(w.E, 1);\n            if (weekday < 1 || weekday > 7) {\n                weekdayOverflow = true;\n            }\n        } else {\n            dow = config._locale._week.dow;\n            doy = config._locale._week.doy;\n\n            var curWeek = weekOfYear(createLocal(), dow, doy);\n\n            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\n\n            // Default to current week.\n            week = defaults(w.w, curWeek.week);\n\n            if (w.d != null) {\n                // weekday -- low day numbers are considered next week\n                weekday = w.d;\n                if (weekday < 0 || weekday > 6) {\n                    weekdayOverflow = true;\n                }\n            } else if (w.e != null) {\n                // local weekday -- counting starts from begining of week\n                weekday = w.e + dow;\n                if (w.e < 0 || w.e > 6) {\n                    weekdayOverflow = true;\n                }\n            } else {\n                // default to begining of week\n                weekday = dow;\n            }\n        }\n        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\n            getParsingFlags(config)._overflowWeeks = true;\n        } else if (weekdayOverflow != null) {\n            getParsingFlags(config)._overflowWeekday = true;\n        } else {\n            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\n            config._a[YEAR] = temp.year;\n            config._dayOfYear = temp.dayOfYear;\n        }\n    }\n\n    // iso 8601 regex\n    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\n    var extendedIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n    var basicIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n\n    var tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/;\n\n    var isoDates = [\n        ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d\\d-\\d\\d/],\n        ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/],\n        ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/],\n        ['GGGG-[W]WW', /\\d{4}-W\\d\\d/, false],\n        ['YYYY-DDD', /\\d{4}-\\d{3}/],\n        ['YYYY-MM', /\\d{4}-\\d\\d/, false],\n        ['YYYYYYMMDD', /[+-]\\d{10}/],\n        ['YYYYMMDD', /\\d{8}/],\n        // YYYYMM is NOT allowed by the standard\n        ['GGGG[W]WWE', /\\d{4}W\\d{3}/],\n        ['GGGG[W]WW', /\\d{4}W\\d{2}/, false],\n        ['YYYYDDD', /\\d{7}/]\n    ];\n\n    // iso time formats and regexes\n    var isoTimes = [\n        ['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n        ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/],\n        ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/],\n        ['HH:mm', /\\d\\d:\\d\\d/],\n        ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/],\n        ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/],\n        ['HHmmss', /\\d\\d\\d\\d\\d\\d/],\n        ['HHmm', /\\d\\d\\d\\d/],\n        ['HH', /\\d\\d/]\n    ];\n\n    var aspNetJsonRegex = /^\\/?Date\\((\\-?\\d+)/i;\n\n    // date from iso format\n    function configFromISO(config) {\n        var i, l,\n            string = config._i,\n            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\n            allowTime, dateFormat, timeFormat, tzFormat;\n\n        if (match) {\n            getParsingFlags(config).iso = true;\n\n            for (i = 0, l = isoDates.length; i < l; i++) {\n                if (isoDates[i][1].exec(match[1])) {\n                    dateFormat = isoDates[i][0];\n                    allowTime = isoDates[i][2] !== false;\n                    break;\n                }\n            }\n            if (dateFormat == null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[3]) {\n                for (i = 0, l = isoTimes.length; i < l; i++) {\n                    if (isoTimes[i][1].exec(match[3])) {\n                        // match[2] should be 'T' or space\n                        timeFormat = (match[2] || ' ') + isoTimes[i][0];\n                        break;\n                    }\n                }\n                if (timeFormat == null) {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            if (!allowTime && timeFormat != null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[4]) {\n                if (tzRegex.exec(match[4])) {\n                    tzFormat = 'Z';\n                } else {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\n            configFromStringAndFormat(config);\n        } else {\n            config._isValid = false;\n        }\n    }\n\n    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\n    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/;\n\n    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\n        var result = [\n            untruncateYear(yearStr),\n            defaultLocaleMonthsShort.indexOf(monthStr),\n            parseInt(dayStr, 10),\n            parseInt(hourStr, 10),\n            parseInt(minuteStr, 10)\n        ];\n\n        if (secondStr) {\n            result.push(parseInt(secondStr, 10));\n        }\n\n        return result;\n    }\n\n    function untruncateYear(yearStr) {\n        var year = parseInt(yearStr, 10);\n        if (year <= 49) {\n            return 2000 + year;\n        } else if (year <= 999) {\n            return 1900 + year;\n        }\n        return year;\n    }\n\n    function preprocessRFC2822(s) {\n        // Remove comments and folding whitespace and replace multiple-spaces with a single space\n        return s.replace(/\\([^)]*\\)|[\\n\\t]/g, ' ').replace(/(\\s\\s+)/g, ' ').replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n    }\n\n    function checkWeekday(weekdayStr, parsedInput, config) {\n        if (weekdayStr) {\n            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.\n            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),\n                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();\n            if (weekdayProvided !== weekdayActual) {\n                getParsingFlags(config).weekdayMismatch = true;\n                config._isValid = false;\n                return false;\n            }\n        }\n        return true;\n    }\n\n    var obsOffsets = {\n        UT: 0,\n        GMT: 0,\n        EDT: -4 * 60,\n        EST: -5 * 60,\n        CDT: -5 * 60,\n        CST: -6 * 60,\n        MDT: -6 * 60,\n        MST: -7 * 60,\n        PDT: -7 * 60,\n        PST: -8 * 60\n    };\n\n    function calculateOffset(obsOffset, militaryOffset, numOffset) {\n        if (obsOffset) {\n            return obsOffsets[obsOffset];\n        } else if (militaryOffset) {\n            // the only allowed military tz is Z\n            return 0;\n        } else {\n            var hm = parseInt(numOffset, 10);\n            var m = hm % 100, h = (hm - m) / 100;\n            return h * 60 + m;\n        }\n    }\n\n    // date and time from ref 2822 format\n    function configFromRFC2822(config) {\n        var match = rfc2822.exec(preprocessRFC2822(config._i));\n        if (match) {\n            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);\n            if (!checkWeekday(match[1], parsedArray, config)) {\n                return;\n            }\n\n            config._a = parsedArray;\n            config._tzm = calculateOffset(match[8], match[9], match[10]);\n\n            config._d = createUTCDate.apply(null, config._a);\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n\n            getParsingFlags(config).rfc2822 = true;\n        } else {\n            config._isValid = false;\n        }\n    }\n\n    // date from iso format or fallback\n    function configFromString(config) {\n        var matched = aspNetJsonRegex.exec(config._i);\n\n        if (matched !== null) {\n            config._d = new Date(+matched[1]);\n            return;\n        }\n\n        configFromISO(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n\n        configFromRFC2822(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n\n        // Final attempt, use Input Fallback\n        hooks.createFromInputFallback(config);\n    }\n\n    hooks.createFromInputFallback = deprecate(\n        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +\n        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +\n        'discouraged and will be removed in an upcoming major release. Please refer to ' +\n        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',\n        function (config) {\n            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n        }\n    );\n\n    // constant that refers to the ISO standard\n    hooks.ISO_8601 = function () {};\n\n    // constant that refers to the RFC 2822 form\n    hooks.RFC_2822 = function () {};\n\n    // date from string and format string\n    function configFromStringAndFormat(config) {\n        // TODO: Move this to another part of the creation flow to prevent circular deps\n        if (config._f === hooks.ISO_8601) {\n            configFromISO(config);\n            return;\n        }\n        if (config._f === hooks.RFC_2822) {\n            configFromRFC2822(config);\n            return;\n        }\n        config._a = [];\n        getParsingFlags(config).empty = true;\n\n        // This array is used to make a Date, either with `new Date` or `Date.UTC`\n        var string = '' + config._i,\n            i, parsedInput, tokens, token, skipped,\n            stringLength = string.length,\n            totalParsedInputLength = 0;\n\n        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n\n        for (i = 0; i < tokens.length; i++) {\n            token = tokens[i];\n            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n            // console.log('token', token, 'parsedInput', parsedInput,\n            //         'regex', getParseRegexForToken(token, config));\n            if (parsedInput) {\n                skipped = string.substr(0, string.indexOf(parsedInput));\n                if (skipped.length > 0) {\n                    getParsingFlags(config).unusedInput.push(skipped);\n                }\n                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n                totalParsedInputLength += parsedInput.length;\n            }\n            // don't parse if it's not a known token\n            if (formatTokenFunctions[token]) {\n                if (parsedInput) {\n                    getParsingFlags(config).empty = false;\n                }\n                else {\n                    getParsingFlags(config).unusedTokens.push(token);\n                }\n                addTimeToArrayFromToken(token, parsedInput, config);\n            }\n            else if (config._strict && !parsedInput) {\n                getParsingFlags(config).unusedTokens.push(token);\n            }\n        }\n\n        // add remaining unparsed input length to the string\n        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n        if (string.length > 0) {\n            getParsingFlags(config).unusedInput.push(string);\n        }\n\n        // clear _12h flag if hour is <= 12\n        if (config._a[HOUR] <= 12 &&\n            getParsingFlags(config).bigHour === true &&\n            config._a[HOUR] > 0) {\n            getParsingFlags(config).bigHour = undefined;\n        }\n\n        getParsingFlags(config).parsedDateParts = config._a.slice(0);\n        getParsingFlags(config).meridiem = config._meridiem;\n        // handle meridiem\n        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\n\n        configFromArray(config);\n        checkOverflow(config);\n    }\n\n\n    function meridiemFixWrap (locale, hour, meridiem) {\n        var isPm;\n\n        if (meridiem == null) {\n            // nothing to do\n            return hour;\n        }\n        if (locale.meridiemHour != null) {\n            return locale.meridiemHour(hour, meridiem);\n        } else if (locale.isPM != null) {\n            // Fallback\n            isPm = locale.isPM(meridiem);\n            if (isPm && hour < 12) {\n                hour += 12;\n            }\n            if (!isPm && hour === 12) {\n                hour = 0;\n            }\n            return hour;\n        } else {\n            // this is not supposed to happen\n            return hour;\n        }\n    }\n\n    // date from string and array of format strings\n    function configFromStringAndArray(config) {\n        var tempConfig,\n            bestMoment,\n\n            scoreToBeat,\n            i,\n            currentScore;\n\n        if (config._f.length === 0) {\n            getParsingFlags(config).invalidFormat = true;\n            config._d = new Date(NaN);\n            return;\n        }\n\n        for (i = 0; i < config._f.length; i++) {\n            currentScore = 0;\n            tempConfig = copyConfig({}, config);\n            if (config._useUTC != null) {\n                tempConfig._useUTC = config._useUTC;\n            }\n            tempConfig._f = config._f[i];\n            configFromStringAndFormat(tempConfig);\n\n            if (!isValid(tempConfig)) {\n                continue;\n            }\n\n            // if there is any input that was not parsed add a penalty for that format\n            currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\n            //or tokens\n            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n\n            getParsingFlags(tempConfig).score = currentScore;\n\n            if (scoreToBeat == null || currentScore < scoreToBeat) {\n                scoreToBeat = currentScore;\n                bestMoment = tempConfig;\n            }\n        }\n\n        extend(config, bestMoment || tempConfig);\n    }\n\n    function configFromObject(config) {\n        if (config._d) {\n            return;\n        }\n\n        var i = normalizeObjectUnits(config._i);\n        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {\n            return obj && parseInt(obj, 10);\n        });\n\n        configFromArray(config);\n    }\n\n    function createFromConfig (config) {\n        var res = new Moment(checkOverflow(prepareConfig(config)));\n        if (res._nextDay) {\n            // Adding is smart enough around DST\n            res.add(1, 'd');\n            res._nextDay = undefined;\n        }\n\n        return res;\n    }\n\n    function prepareConfig (config) {\n        var input = config._i,\n            format = config._f;\n\n        config._locale = config._locale || getLocale(config._l);\n\n        if (input === null || (format === undefined && input === '')) {\n            return createInvalid({nullInput: true});\n        }\n\n        if (typeof input === 'string') {\n            config._i = input = config._locale.preparse(input);\n        }\n\n        if (isMoment(input)) {\n            return new Moment(checkOverflow(input));\n        } else if (isDate(input)) {\n            config._d = input;\n        } else if (isArray(format)) {\n            configFromStringAndArray(config);\n        } else if (format) {\n            configFromStringAndFormat(config);\n        }  else {\n            configFromInput(config);\n        }\n\n        if (!isValid(config)) {\n            config._d = null;\n        }\n\n        return config;\n    }\n\n    function configFromInput(config) {\n        var input = config._i;\n        if (isUndefined(input)) {\n            config._d = new Date(hooks.now());\n        } else if (isDate(input)) {\n            config._d = new Date(input.valueOf());\n        } else if (typeof input === 'string') {\n            configFromString(config);\n        } else if (isArray(input)) {\n            config._a = map(input.slice(0), function (obj) {\n                return parseInt(obj, 10);\n            });\n            configFromArray(config);\n        } else if (isObject(input)) {\n            configFromObject(config);\n        } else if (isNumber(input)) {\n            // from milliseconds\n            config._d = new Date(input);\n        } else {\n            hooks.createFromInputFallback(config);\n        }\n    }\n\n    function createLocalOrUTC (input, format, locale, strict, isUTC) {\n        var c = {};\n\n        if (locale === true || locale === false) {\n            strict = locale;\n            locale = undefined;\n        }\n\n        if ((isObject(input) && isObjectEmpty(input)) ||\n                (isArray(input) && input.length === 0)) {\n            input = undefined;\n        }\n        // object construction must be done this way.\n        // https://github.com/moment/moment/issues/1423\n        c._isAMomentObject = true;\n        c._useUTC = c._isUTC = isUTC;\n        c._l = locale;\n        c._i = input;\n        c._f = format;\n        c._strict = strict;\n\n        return createFromConfig(c);\n    }\n\n    function createLocal (input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, false);\n    }\n\n    var prototypeMin = deprecate(\n        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',\n        function () {\n            var other = createLocal.apply(null, arguments);\n            if (this.isValid() && other.isValid()) {\n                return other < this ? this : other;\n            } else {\n                return createInvalid();\n            }\n        }\n    );\n\n    var prototypeMax = deprecate(\n        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',\n        function () {\n            var other = createLocal.apply(null, arguments);\n            if (this.isValid() && other.isValid()) {\n                return other > this ? this : other;\n            } else {\n                return createInvalid();\n            }\n        }\n    );\n\n    // Pick a moment m from moments so that m[fn](other) is true for all\n    // other. This relies on the function fn to be transitive.\n    //\n    // moments should either be an array of moment objects or an array, whose\n    // first element is an array of moment objects.\n    function pickBy(fn, moments) {\n        var res, i;\n        if (moments.length === 1 && isArray(moments[0])) {\n            moments = moments[0];\n        }\n        if (!moments.length) {\n            return createLocal();\n        }\n        res = moments[0];\n        for (i = 1; i < moments.length; ++i) {\n            if (!moments[i].isValid() || moments[i][fn](res)) {\n                res = moments[i];\n            }\n        }\n        return res;\n    }\n\n    // TODO: Use [].sort instead?\n    function min () {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isBefore', args);\n    }\n\n    function max () {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isAfter', args);\n    }\n\n    var now = function () {\n        return Date.now ? Date.now() : +(new Date());\n    };\n\n    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];\n\n    function isDurationValid(m) {\n        for (var key in m) {\n            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {\n                return false;\n            }\n        }\n\n        var unitHasDecimal = false;\n        for (var i = 0; i < ordering.length; ++i) {\n            if (m[ordering[i]]) {\n                if (unitHasDecimal) {\n                    return false; // only allow non-integers for smallest unit\n                }\n                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\n                    unitHasDecimal = true;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    function isValid$1() {\n        return this._isValid;\n    }\n\n    function createInvalid$1() {\n        return createDuration(NaN);\n    }\n\n    function Duration (duration) {\n        var normalizedInput = normalizeObjectUnits(duration),\n            years = normalizedInput.year || 0,\n            quarters = normalizedInput.quarter || 0,\n            months = normalizedInput.month || 0,\n            weeks = normalizedInput.week || 0,\n            days = normalizedInput.day || 0,\n            hours = normalizedInput.hour || 0,\n            minutes = normalizedInput.minute || 0,\n            seconds = normalizedInput.second || 0,\n            milliseconds = normalizedInput.millisecond || 0;\n\n        this._isValid = isDurationValid(normalizedInput);\n\n        // representation for dateAddRemove\n        this._milliseconds = +milliseconds +\n            seconds * 1e3 + // 1000\n            minutes * 6e4 + // 1000 * 60\n            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\n        // Because of dateAddRemove treats 24 hours as different from a\n        // day when working around DST, we need to store them separately\n        this._days = +days +\n            weeks * 7;\n        // It is impossible to translate months into days without knowing\n        // which months you are are talking about, so we have to store\n        // it separately.\n        this._months = +months +\n            quarters * 3 +\n            years * 12;\n\n        this._data = {};\n\n        this._locale = getLocale();\n\n        this._bubble();\n    }\n\n    function isDuration (obj) {\n        return obj instanceof Duration;\n    }\n\n    function absRound (number) {\n        if (number < 0) {\n            return Math.round(-1 * number) * -1;\n        } else {\n            return Math.round(number);\n        }\n    }\n\n    // FORMATTING\n\n    function offset (token, separator) {\n        addFormatToken(token, 0, 0, function () {\n            var offset = this.utcOffset();\n            var sign = '+';\n            if (offset < 0) {\n                offset = -offset;\n                sign = '-';\n            }\n            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);\n        });\n    }\n\n    offset('Z', ':');\n    offset('ZZ', '');\n\n    // PARSING\n\n    addRegexToken('Z',  matchShortOffset);\n    addRegexToken('ZZ', matchShortOffset);\n    addParseToken(['Z', 'ZZ'], function (input, array, config) {\n        config._useUTC = true;\n        config._tzm = offsetFromString(matchShortOffset, input);\n    });\n\n    // HELPERS\n\n    // timezone chunker\n    // '+10:00' > ['10',  '00']\n    // '-1530'  > ['-15', '30']\n    var chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\n    function offsetFromString(matcher, string) {\n        var matches = (string || '').match(matcher);\n\n        if (matches === null) {\n            return null;\n        }\n\n        var chunk   = matches[matches.length - 1] || [];\n        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n        var minutes = +(parts[1] * 60) + toInt(parts[2]);\n\n        return minutes === 0 ?\n          0 :\n          parts[0] === '+' ? minutes : -minutes;\n    }\n\n    // Return a moment from input, that is local/utc/zone equivalent to model.\n    function cloneWithOffset(input, model) {\n        var res, diff;\n        if (model._isUTC) {\n            res = model.clone();\n            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();\n            // Use low-level api, because this fn is low-level api.\n            res._d.setTime(res._d.valueOf() + diff);\n            hooks.updateOffset(res, false);\n            return res;\n        } else {\n            return createLocal(input).local();\n        }\n    }\n\n    function getDateOffset (m) {\n        // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n        // https://github.com/moment/moment/pull/1871\n        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;\n    }\n\n    // HOOKS\n\n    // This function will be called whenever a moment is mutated.\n    // It is intended to keep the offset in sync with the timezone.\n    hooks.updateOffset = function () {};\n\n    // MOMENTS\n\n    // keepLocalTime = true means only change the timezone, without\n    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n    // +0200, so we adjust the time as needed, to be valid.\n    //\n    // Keeping the time actually adds/subtracts (one hour)\n    // from the actual represented time. That is why we call updateOffset\n    // a second time. In case it wants us to change the offset again\n    // _changeInProgress == true case, then we have to adjust, because\n    // there is no such time in the given timezone.\n    function getSetOffset (input, keepLocalTime, keepMinutes) {\n        var offset = this._offset || 0,\n            localAdjust;\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        if (input != null) {\n            if (typeof input === 'string') {\n                input = offsetFromString(matchShortOffset, input);\n                if (input === null) {\n                    return this;\n                }\n            } else if (Math.abs(input) < 16 && !keepMinutes) {\n                input = input * 60;\n            }\n            if (!this._isUTC && keepLocalTime) {\n                localAdjust = getDateOffset(this);\n            }\n            this._offset = input;\n            this._isUTC = true;\n            if (localAdjust != null) {\n                this.add(localAdjust, 'm');\n            }\n            if (offset !== input) {\n                if (!keepLocalTime || this._changeInProgress) {\n                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);\n                } else if (!this._changeInProgress) {\n                    this._changeInProgress = true;\n                    hooks.updateOffset(this, true);\n                    this._changeInProgress = null;\n                }\n            }\n            return this;\n        } else {\n            return this._isUTC ? offset : getDateOffset(this);\n        }\n    }\n\n    function getSetZone (input, keepLocalTime) {\n        if (input != null) {\n            if (typeof input !== 'string') {\n                input = -input;\n            }\n\n            this.utcOffset(input, keepLocalTime);\n\n            return this;\n        } else {\n            return -this.utcOffset();\n        }\n    }\n\n    function setOffsetToUTC (keepLocalTime) {\n        return this.utcOffset(0, keepLocalTime);\n    }\n\n    function setOffsetToLocal (keepLocalTime) {\n        if (this._isUTC) {\n            this.utcOffset(0, keepLocalTime);\n            this._isUTC = false;\n\n            if (keepLocalTime) {\n                this.subtract(getDateOffset(this), 'm');\n            }\n        }\n        return this;\n    }\n\n    function setOffsetToParsedOffset () {\n        if (this._tzm != null) {\n            this.utcOffset(this._tzm, false, true);\n        } else if (typeof this._i === 'string') {\n            var tZone = offsetFromString(matchOffset, this._i);\n            if (tZone != null) {\n                this.utcOffset(tZone);\n            }\n            else {\n                this.utcOffset(0, true);\n            }\n        }\n        return this;\n    }\n\n    function hasAlignedHourOffset (input) {\n        if (!this.isValid()) {\n            return false;\n        }\n        input = input ? createLocal(input).utcOffset() : 0;\n\n        return (this.utcOffset() - input) % 60 === 0;\n    }\n\n    function isDaylightSavingTime () {\n        return (\n            this.utcOffset() > this.clone().month(0).utcOffset() ||\n            this.utcOffset() > this.clone().month(5).utcOffset()\n        );\n    }\n\n    function isDaylightSavingTimeShifted () {\n        if (!isUndefined(this._isDSTShifted)) {\n            return this._isDSTShifted;\n        }\n\n        var c = {};\n\n        copyConfig(c, this);\n        c = prepareConfig(c);\n\n        if (c._a) {\n            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n            this._isDSTShifted = this.isValid() &&\n                compareArrays(c._a, other.toArray()) > 0;\n        } else {\n            this._isDSTShifted = false;\n        }\n\n        return this._isDSTShifted;\n    }\n\n    function isLocal () {\n        return this.isValid() ? !this._isUTC : false;\n    }\n\n    function isUtcOffset () {\n        return this.isValid() ? this._isUTC : false;\n    }\n\n    function isUtc () {\n        return this.isValid() ? this._isUTC && this._offset === 0 : false;\n    }\n\n    // ASP.NET json date format regex\n    var aspNetRegex = /^(\\-|\\+)?(?:(\\d*)[. ])?(\\d+)\\:(\\d+)(?:\\:(\\d+)(\\.\\d*)?)?$/;\n\n    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n    // and further modified to allow for strings containing both week and day\n    var isoRegex = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n\n    function createDuration (input, key) {\n        var duration = input,\n            // matching against regexp is expensive, do it on demand\n            match = null,\n            sign,\n            ret,\n            diffRes;\n\n        if (isDuration(input)) {\n            duration = {\n                ms : input._milliseconds,\n                d  : input._days,\n                M  : input._months\n            };\n        } else if (isNumber(input)) {\n            duration = {};\n            if (key) {\n                duration[key] = input;\n            } else {\n                duration.milliseconds = input;\n            }\n        } else if (!!(match = aspNetRegex.exec(input))) {\n            sign = (match[1] === '-') ? -1 : 1;\n            duration = {\n                y  : 0,\n                d  : toInt(match[DATE])                         * sign,\n                h  : toInt(match[HOUR])                         * sign,\n                m  : toInt(match[MINUTE])                       * sign,\n                s  : toInt(match[SECOND])                       * sign,\n                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match\n            };\n        } else if (!!(match = isoRegex.exec(input))) {\n            sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;\n            duration = {\n                y : parseIso(match[2], sign),\n                M : parseIso(match[3], sign),\n                w : parseIso(match[4], sign),\n                d : parseIso(match[5], sign),\n                h : parseIso(match[6], sign),\n                m : parseIso(match[7], sign),\n                s : parseIso(match[8], sign)\n            };\n        } else if (duration == null) {// checks for null or undefined\n            duration = {};\n        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {\n            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));\n\n            duration = {};\n            duration.ms = diffRes.milliseconds;\n            duration.M = diffRes.months;\n        }\n\n        ret = new Duration(duration);\n\n        if (isDuration(input) && hasOwnProp(input, '_locale')) {\n            ret._locale = input._locale;\n        }\n\n        return ret;\n    }\n\n    createDuration.fn = Duration.prototype;\n    createDuration.invalid = createInvalid$1;\n\n    function parseIso (inp, sign) {\n        // We'd normally use ~~inp for this, but unfortunately it also\n        // converts floats to ints.\n        // inp may be undefined, so careful calling replace on it.\n        var res = inp && parseFloat(inp.replace(',', '.'));\n        // apply sign while we're at it\n        return (isNaN(res) ? 0 : res) * sign;\n    }\n\n    function positiveMomentsDifference(base, other) {\n        var res = {milliseconds: 0, months: 0};\n\n        res.months = other.month() - base.month() +\n            (other.year() - base.year()) * 12;\n        if (base.clone().add(res.months, 'M').isAfter(other)) {\n            --res.months;\n        }\n\n        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));\n\n        return res;\n    }\n\n    function momentsDifference(base, other) {\n        var res;\n        if (!(base.isValid() && other.isValid())) {\n            return {milliseconds: 0, months: 0};\n        }\n\n        other = cloneWithOffset(other, base);\n        if (base.isBefore(other)) {\n            res = positiveMomentsDifference(base, other);\n        } else {\n            res = positiveMomentsDifference(other, base);\n            res.milliseconds = -res.milliseconds;\n            res.months = -res.months;\n        }\n\n        return res;\n    }\n\n    // TODO: remove 'name' arg after deprecation is removed\n    function createAdder(direction, name) {\n        return function (val, period) {\n            var dur, tmp;\n            //invert the arguments, but complain about it\n            if (period !== null && !isNaN(+period)) {\n                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +\n                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');\n                tmp = val; val = period; period = tmp;\n            }\n\n            val = typeof val === 'string' ? +val : val;\n            dur = createDuration(val, period);\n            addSubtract(this, dur, direction);\n            return this;\n        };\n    }\n\n    function addSubtract (mom, duration, isAdding, updateOffset) {\n        var milliseconds = duration._milliseconds,\n            days = absRound(duration._days),\n            months = absRound(duration._months);\n\n        if (!mom.isValid()) {\n            // No op\n            return;\n        }\n\n        updateOffset = updateOffset == null ? true : updateOffset;\n\n        if (months) {\n            setMonth(mom, get(mom, 'Month') + months * isAdding);\n        }\n        if (days) {\n            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);\n        }\n        if (milliseconds) {\n            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\n        }\n        if (updateOffset) {\n            hooks.updateOffset(mom, days || months);\n        }\n    }\n\n    var add      = createAdder(1, 'add');\n    var subtract = createAdder(-1, 'subtract');\n\n    function getCalendarFormat(myMoment, now) {\n        var diff = myMoment.diff(now, 'days', true);\n        return diff < -6 ? 'sameElse' :\n                diff < -1 ? 'lastWeek' :\n                diff < 0 ? 'lastDay' :\n                diff < 1 ? 'sameDay' :\n                diff < 2 ? 'nextDay' :\n                diff < 7 ? 'nextWeek' : 'sameElse';\n    }\n\n    function calendar$1 (time, formats) {\n        // We want to compare the start of today, vs this.\n        // Getting start-of-today depends on whether we're local/utc/offset or not.\n        var now = time || createLocal(),\n            sod = cloneWithOffset(now, this).startOf('day'),\n            format = hooks.calendarFormat(this, sod) || 'sameElse';\n\n        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);\n\n        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));\n    }\n\n    function clone () {\n        return new Moment(this);\n    }\n\n    function isAfter (input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\n        if (units === 'millisecond') {\n            return this.valueOf() > localInput.valueOf();\n        } else {\n            return localInput.valueOf() < this.clone().startOf(units).valueOf();\n        }\n    }\n\n    function isBefore (input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\n        if (units === 'millisecond') {\n            return this.valueOf() < localInput.valueOf();\n        } else {\n            return this.clone().endOf(units).valueOf() < localInput.valueOf();\n        }\n    }\n\n    function isBetween (from, to, units, inclusivity) {\n        inclusivity = inclusivity || '()';\n        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&\n            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));\n    }\n\n    function isSame (input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input),\n            inputMs;\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units || 'millisecond');\n        if (units === 'millisecond') {\n            return this.valueOf() === localInput.valueOf();\n        } else {\n            inputMs = localInput.valueOf();\n            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();\n        }\n    }\n\n    function isSameOrAfter (input, units) {\n        return this.isSame(input, units) || this.isAfter(input,units);\n    }\n\n    function isSameOrBefore (input, units) {\n        return this.isSame(input, units) || this.isBefore(input,units);\n    }\n\n    function diff (input, units, asFloat) {\n        var that,\n            zoneDelta,\n            output;\n\n        if (!this.isValid()) {\n            return NaN;\n        }\n\n        that = cloneWithOffset(input, this);\n\n        if (!that.isValid()) {\n            return NaN;\n        }\n\n        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\n\n        units = normalizeUnits(units);\n\n        switch (units) {\n            case 'year': output = monthDiff(this, that) / 12; break;\n            case 'month': output = monthDiff(this, that); break;\n            case 'quarter': output = monthDiff(this, that) / 3; break;\n            case 'second': output = (this - that) / 1e3; break; // 1000\n            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60\n            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60\n            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst\n            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst\n            default: output = this - that;\n        }\n\n        return asFloat ? output : absFloor(output);\n    }\n\n    function monthDiff (a, b) {\n        // difference in months\n        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),\n            // b is in (anchor - 1 month, anchor + 1 month)\n            anchor = a.clone().add(wholeMonthDiff, 'months'),\n            anchor2, adjust;\n\n        if (b - anchor < 0) {\n            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor - anchor2);\n        } else {\n            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor2 - anchor);\n        }\n\n        //check for negative zero, return zero if negative zero\n        return -(wholeMonthDiff + adjust) || 0;\n    }\n\n    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\n    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\n\n    function toString () {\n        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\n    }\n\n    function toISOString(keepOffset) {\n        if (!this.isValid()) {\n            return null;\n        }\n        var utc = keepOffset !== true;\n        var m = utc ? this.clone().utc() : this;\n        if (m.year() < 0 || m.year() > 9999) {\n            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');\n        }\n        if (isFunction(Date.prototype.toISOString)) {\n            // native implementation is ~50x faster, use it when we can\n            if (utc) {\n                return this.toDate().toISOString();\n            } else {\n                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));\n            }\n        }\n        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');\n    }\n\n    /**\n     * Return a human readable representation of a moment that can\n     * also be evaluated to get a new moment which is the same\n     *\n     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\n     */\n    function inspect () {\n        if (!this.isValid()) {\n            return 'moment.invalid(/* ' + this._i + ' */)';\n        }\n        var func = 'moment';\n        var zone = '';\n        if (!this.isLocal()) {\n            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';\n            zone = 'Z';\n        }\n        var prefix = '[' + func + '(\"]';\n        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';\n        var datetime = '-MM-DD[T]HH:mm:ss.SSS';\n        var suffix = zone + '[\")]';\n\n        return this.format(prefix + year + datetime + suffix);\n    }\n\n    function format (inputString) {\n        if (!inputString) {\n            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;\n        }\n        var output = formatMoment(this, inputString);\n        return this.localeData().postformat(output);\n    }\n\n    function from (time, withoutSuffix) {\n        if (this.isValid() &&\n                ((isMoment(time) && time.isValid()) ||\n                 createLocal(time).isValid())) {\n            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n\n    function fromNow (withoutSuffix) {\n        return this.from(createLocal(), withoutSuffix);\n    }\n\n    function to (time, withoutSuffix) {\n        if (this.isValid() &&\n                ((isMoment(time) && time.isValid()) ||\n                 createLocal(time).isValid())) {\n            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n\n    function toNow (withoutSuffix) {\n        return this.to(createLocal(), withoutSuffix);\n    }\n\n    // If passed a locale key, it will set the locale for this\n    // instance.  Otherwise, it will return the locale configuration\n    // variables for this instance.\n    function locale (key) {\n        var newLocaleData;\n\n        if (key === undefined) {\n            return this._locale._abbr;\n        } else {\n            newLocaleData = getLocale(key);\n            if (newLocaleData != null) {\n                this._locale = newLocaleData;\n            }\n            return this;\n        }\n    }\n\n    var lang = deprecate(\n        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\n        function (key) {\n            if (key === undefined) {\n                return this.localeData();\n            } else {\n                return this.locale(key);\n            }\n        }\n    );\n\n    function localeData () {\n        return this._locale;\n    }\n\n    function startOf (units) {\n        units = normalizeUnits(units);\n        // the following switch intentionally omits break keywords\n        // to utilize falling through the cases.\n        switch (units) {\n            case 'year':\n                this.month(0);\n                /* falls through */\n            case 'quarter':\n            case 'month':\n                this.date(1);\n                /* falls through */\n            case 'week':\n            case 'isoWeek':\n            case 'day':\n            case 'date':\n                this.hours(0);\n                /* falls through */\n            case 'hour':\n                this.minutes(0);\n                /* falls through */\n            case 'minute':\n                this.seconds(0);\n                /* falls through */\n            case 'second':\n                this.milliseconds(0);\n        }\n\n        // weeks are a special case\n        if (units === 'week') {\n            this.weekday(0);\n        }\n        if (units === 'isoWeek') {\n            this.isoWeekday(1);\n        }\n\n        // quarters are also special\n        if (units === 'quarter') {\n            this.month(Math.floor(this.month() / 3) * 3);\n        }\n\n        return this;\n    }\n\n    function endOf (units) {\n        units = normalizeUnits(units);\n        if (units === undefined || units === 'millisecond') {\n            return this;\n        }\n\n        // 'date' is an alias for 'day', so it should be considered as such.\n        if (units === 'date') {\n            units = 'day';\n        }\n\n        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');\n    }\n\n    function valueOf () {\n        return this._d.valueOf() - ((this._offset || 0) * 60000);\n    }\n\n    function unix () {\n        return Math.floor(this.valueOf() / 1000);\n    }\n\n    function toDate () {\n        return new Date(this.valueOf());\n    }\n\n    function toArray () {\n        var m = this;\n        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];\n    }\n\n    function toObject () {\n        var m = this;\n        return {\n            years: m.year(),\n            months: m.month(),\n            date: m.date(),\n            hours: m.hours(),\n            minutes: m.minutes(),\n            seconds: m.seconds(),\n            milliseconds: m.milliseconds()\n        };\n    }\n\n    function toJSON () {\n        // new Date(NaN).toJSON() === null\n        return this.isValid() ? this.toISOString() : null;\n    }\n\n    function isValid$2 () {\n        return isValid(this);\n    }\n\n    function parsingFlags () {\n        return extend({}, getParsingFlags(this));\n    }\n\n    function invalidAt () {\n        return getParsingFlags(this).overflow;\n    }\n\n    function creationData() {\n        return {\n            input: this._i,\n            format: this._f,\n            locale: this._locale,\n            isUTC: this._isUTC,\n            strict: this._strict\n        };\n    }\n\n    // FORMATTING\n\n    addFormatToken(0, ['gg', 2], 0, function () {\n        return this.weekYear() % 100;\n    });\n\n    addFormatToken(0, ['GG', 2], 0, function () {\n        return this.isoWeekYear() % 100;\n    });\n\n    function addWeekYearFormatToken (token, getter) {\n        addFormatToken(0, [token, token.length], 0, getter);\n    }\n\n    addWeekYearFormatToken('gggg',     'weekYear');\n    addWeekYearFormatToken('ggggg',    'weekYear');\n    addWeekYearFormatToken('GGGG',  'isoWeekYear');\n    addWeekYearFormatToken('GGGGG', 'isoWeekYear');\n\n    // ALIASES\n\n    addUnitAlias('weekYear', 'gg');\n    addUnitAlias('isoWeekYear', 'GG');\n\n    // PRIORITY\n\n    addUnitPriority('weekYear', 1);\n    addUnitPriority('isoWeekYear', 1);\n\n\n    // PARSING\n\n    addRegexToken('G',      matchSigned);\n    addRegexToken('g',      matchSigned);\n    addRegexToken('GG',     match1to2, match2);\n    addRegexToken('gg',     match1to2, match2);\n    addRegexToken('GGGG',   match1to4, match4);\n    addRegexToken('gggg',   match1to4, match4);\n    addRegexToken('GGGGG',  match1to6, match6);\n    addRegexToken('ggggg',  match1to6, match6);\n\n    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {\n        week[token.substr(0, 2)] = toInt(input);\n    });\n\n    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\n        week[token] = hooks.parseTwoDigitYear(input);\n    });\n\n    // MOMENTS\n\n    function getSetWeekYear (input) {\n        return getSetWeekYearHelper.call(this,\n                input,\n                this.week(),\n                this.weekday(),\n                this.localeData()._week.dow,\n                this.localeData()._week.doy);\n    }\n\n    function getSetISOWeekYear (input) {\n        return getSetWeekYearHelper.call(this,\n                input, this.isoWeek(), this.isoWeekday(), 1, 4);\n    }\n\n    function getISOWeeksInYear () {\n        return weeksInYear(this.year(), 1, 4);\n    }\n\n    function getWeeksInYear () {\n        var weekInfo = this.localeData()._week;\n        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n    }\n\n    function getSetWeekYearHelper(input, week, weekday, dow, doy) {\n        var weeksTarget;\n        if (input == null) {\n            return weekOfYear(this, dow, doy).year;\n        } else {\n            weeksTarget = weeksInYear(input, dow, doy);\n            if (week > weeksTarget) {\n                week = weeksTarget;\n            }\n            return setWeekAll.call(this, input, week, weekday, dow, doy);\n        }\n    }\n\n    function setWeekAll(weekYear, week, weekday, dow, doy) {\n        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\n            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n\n        this.year(date.getUTCFullYear());\n        this.month(date.getUTCMonth());\n        this.date(date.getUTCDate());\n        return this;\n    }\n\n    // FORMATTING\n\n    addFormatToken('Q', 0, 'Qo', 'quarter');\n\n    // ALIASES\n\n    addUnitAlias('quarter', 'Q');\n\n    // PRIORITY\n\n    addUnitPriority('quarter', 7);\n\n    // PARSING\n\n    addRegexToken('Q', match1);\n    addParseToken('Q', function (input, array) {\n        array[MONTH] = (toInt(input) - 1) * 3;\n    });\n\n    // MOMENTS\n\n    function getSetQuarter (input) {\n        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n    }\n\n    // FORMATTING\n\n    addFormatToken('D', ['DD', 2], 'Do', 'date');\n\n    // ALIASES\n\n    addUnitAlias('date', 'D');\n\n    // PRIORITY\n    addUnitPriority('date', 9);\n\n    // PARSING\n\n    addRegexToken('D',  match1to2);\n    addRegexToken('DD', match1to2, match2);\n    addRegexToken('Do', function (isStrict, locale) {\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        return isStrict ?\n          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :\n          locale._dayOfMonthOrdinalParseLenient;\n    });\n\n    addParseToken(['D', 'DD'], DATE);\n    addParseToken('Do', function (input, array) {\n        array[DATE] = toInt(input.match(match1to2)[0]);\n    });\n\n    // MOMENTS\n\n    var getSetDayOfMonth = makeGetSet('Date', true);\n\n    // FORMATTING\n\n    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\n\n    // ALIASES\n\n    addUnitAlias('dayOfYear', 'DDD');\n\n    // PRIORITY\n    addUnitPriority('dayOfYear', 4);\n\n    // PARSING\n\n    addRegexToken('DDD',  match1to3);\n    addRegexToken('DDDD', match3);\n    addParseToken(['DDD', 'DDDD'], function (input, array, config) {\n        config._dayOfYear = toInt(input);\n    });\n\n    // HELPERS\n\n    // MOMENTS\n\n    function getSetDayOfYear (input) {\n        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;\n        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');\n    }\n\n    // FORMATTING\n\n    addFormatToken('m', ['mm', 2], 0, 'minute');\n\n    // ALIASES\n\n    addUnitAlias('minute', 'm');\n\n    // PRIORITY\n\n    addUnitPriority('minute', 14);\n\n    // PARSING\n\n    addRegexToken('m',  match1to2);\n    addRegexToken('mm', match1to2, match2);\n    addParseToken(['m', 'mm'], MINUTE);\n\n    // MOMENTS\n\n    var getSetMinute = makeGetSet('Minutes', false);\n\n    // FORMATTING\n\n    addFormatToken('s', ['ss', 2], 0, 'second');\n\n    // ALIASES\n\n    addUnitAlias('second', 's');\n\n    // PRIORITY\n\n    addUnitPriority('second', 15);\n\n    // PARSING\n\n    addRegexToken('s',  match1to2);\n    addRegexToken('ss', match1to2, match2);\n    addParseToken(['s', 'ss'], SECOND);\n\n    // MOMENTS\n\n    var getSetSecond = makeGetSet('Seconds', false);\n\n    // FORMATTING\n\n    addFormatToken('S', 0, 0, function () {\n        return ~~(this.millisecond() / 100);\n    });\n\n    addFormatToken(0, ['SS', 2], 0, function () {\n        return ~~(this.millisecond() / 10);\n    });\n\n    addFormatToken(0, ['SSS', 3], 0, 'millisecond');\n    addFormatToken(0, ['SSSS', 4], 0, function () {\n        return this.millisecond() * 10;\n    });\n    addFormatToken(0, ['SSSSS', 5], 0, function () {\n        return this.millisecond() * 100;\n    });\n    addFormatToken(0, ['SSSSSS', 6], 0, function () {\n        return this.millisecond() * 1000;\n    });\n    addFormatToken(0, ['SSSSSSS', 7], 0, function () {\n        return this.millisecond() * 10000;\n    });\n    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {\n        return this.millisecond() * 100000;\n    });\n    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\n        return this.millisecond() * 1000000;\n    });\n\n\n    // ALIASES\n\n    addUnitAlias('millisecond', 'ms');\n\n    // PRIORITY\n\n    addUnitPriority('millisecond', 16);\n\n    // PARSING\n\n    addRegexToken('S',    match1to3, match1);\n    addRegexToken('SS',   match1to3, match2);\n    addRegexToken('SSS',  match1to3, match3);\n\n    var token;\n    for (token = 'SSSS'; token.length <= 9; token += 'S') {\n        addRegexToken(token, matchUnsigned);\n    }\n\n    function parseMs(input, array) {\n        array[MILLISECOND] = toInt(('0.' + input) * 1000);\n    }\n\n    for (token = 'S'; token.length <= 9; token += 'S') {\n        addParseToken(token, parseMs);\n    }\n    // MOMENTS\n\n    var getSetMillisecond = makeGetSet('Milliseconds', false);\n\n    // FORMATTING\n\n    addFormatToken('z',  0, 0, 'zoneAbbr');\n    addFormatToken('zz', 0, 0, 'zoneName');\n\n    // MOMENTS\n\n    function getZoneAbbr () {\n        return this._isUTC ? 'UTC' : '';\n    }\n\n    function getZoneName () {\n        return this._isUTC ? 'Coordinated Universal Time' : '';\n    }\n\n    var proto = Moment.prototype;\n\n    proto.add               = add;\n    proto.calendar          = calendar$1;\n    proto.clone             = clone;\n    proto.diff              = diff;\n    proto.endOf             = endOf;\n    proto.format            = format;\n    proto.from              = from;\n    proto.fromNow           = fromNow;\n    proto.to                = to;\n    proto.toNow             = toNow;\n    proto.get               = stringGet;\n    proto.invalidAt         = invalidAt;\n    proto.isAfter           = isAfter;\n    proto.isBefore          = isBefore;\n    proto.isBetween         = isBetween;\n    proto.isSame            = isSame;\n    proto.isSameOrAfter     = isSameOrAfter;\n    proto.isSameOrBefore    = isSameOrBefore;\n    proto.isValid           = isValid$2;\n    proto.lang              = lang;\n    proto.locale            = locale;\n    proto.localeData        = localeData;\n    proto.max               = prototypeMax;\n    proto.min               = prototypeMin;\n    proto.parsingFlags      = parsingFlags;\n    proto.set               = stringSet;\n    proto.startOf           = startOf;\n    proto.subtract          = subtract;\n    proto.toArray           = toArray;\n    proto.toObject          = toObject;\n    proto.toDate            = toDate;\n    proto.toISOString       = toISOString;\n    proto.inspect           = inspect;\n    proto.toJSON            = toJSON;\n    proto.toString          = toString;\n    proto.unix              = unix;\n    proto.valueOf           = valueOf;\n    proto.creationData      = creationData;\n    proto.year       = getSetYear;\n    proto.isLeapYear = getIsLeapYear;\n    proto.weekYear    = getSetWeekYear;\n    proto.isoWeekYear = getSetISOWeekYear;\n    proto.quarter = proto.quarters = getSetQuarter;\n    proto.month       = getSetMonth;\n    proto.daysInMonth = getDaysInMonth;\n    proto.week           = proto.weeks        = getSetWeek;\n    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;\n    proto.weeksInYear    = getWeeksInYear;\n    proto.isoWeeksInYear = getISOWeeksInYear;\n    proto.date       = getSetDayOfMonth;\n    proto.day        = proto.days             = getSetDayOfWeek;\n    proto.weekday    = getSetLocaleDayOfWeek;\n    proto.isoWeekday = getSetISODayOfWeek;\n    proto.dayOfYear  = getSetDayOfYear;\n    proto.hour = proto.hours = getSetHour;\n    proto.minute = proto.minutes = getSetMinute;\n    proto.second = proto.seconds = getSetSecond;\n    proto.millisecond = proto.milliseconds = getSetMillisecond;\n    proto.utcOffset            = getSetOffset;\n    proto.utc                  = setOffsetToUTC;\n    proto.local                = setOffsetToLocal;\n    proto.parseZone            = setOffsetToParsedOffset;\n    proto.hasAlignedHourOffset = hasAlignedHourOffset;\n    proto.isDST                = isDaylightSavingTime;\n    proto.isLocal              = isLocal;\n    proto.isUtcOffset          = isUtcOffset;\n    proto.isUtc                = isUtc;\n    proto.isUTC                = isUtc;\n    proto.zoneAbbr = getZoneAbbr;\n    proto.zoneName = getZoneName;\n    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);\n    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);\n    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);\n    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);\n    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);\n\n    function createUnix (input) {\n        return createLocal(input * 1000);\n    }\n\n    function createInZone () {\n        return createLocal.apply(null, arguments).parseZone();\n    }\n\n    function preParsePostFormat (string) {\n        return string;\n    }\n\n    var proto$1 = Locale.prototype;\n\n    proto$1.calendar        = calendar;\n    proto$1.longDateFormat  = longDateFormat;\n    proto$1.invalidDate     = invalidDate;\n    proto$1.ordinal         = ordinal;\n    proto$1.preparse        = preParsePostFormat;\n    proto$1.postformat      = preParsePostFormat;\n    proto$1.relativeTime    = relativeTime;\n    proto$1.pastFuture      = pastFuture;\n    proto$1.set             = set;\n\n    proto$1.months            =        localeMonths;\n    proto$1.monthsShort       =        localeMonthsShort;\n    proto$1.monthsParse       =        localeMonthsParse;\n    proto$1.monthsRegex       = monthsRegex;\n    proto$1.monthsShortRegex  = monthsShortRegex;\n    proto$1.week = localeWeek;\n    proto$1.firstDayOfYear = localeFirstDayOfYear;\n    proto$1.firstDayOfWeek = localeFirstDayOfWeek;\n\n    proto$1.weekdays       =        localeWeekdays;\n    proto$1.weekdaysMin    =        localeWeekdaysMin;\n    proto$1.weekdaysShort  =        localeWeekdaysShort;\n    proto$1.weekdaysParse  =        localeWeekdaysParse;\n\n    proto$1.weekdaysRegex       =        weekdaysRegex;\n    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;\n    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;\n\n    proto$1.isPM = localeIsPM;\n    proto$1.meridiem = localeMeridiem;\n\n    function get$1 (format, index, field, setter) {\n        var locale = getLocale();\n        var utc = createUTC().set(setter, index);\n        return locale[field](utc, format);\n    }\n\n    function listMonthsImpl (format, index, field) {\n        if (isNumber(format)) {\n            index = format;\n            format = undefined;\n        }\n\n        format = format || '';\n\n        if (index != null) {\n            return get$1(format, index, field, 'month');\n        }\n\n        var i;\n        var out = [];\n        for (i = 0; i < 12; i++) {\n            out[i] = get$1(format, i, field, 'month');\n        }\n        return out;\n    }\n\n    // ()\n    // (5)\n    // (fmt, 5)\n    // (fmt)\n    // (true)\n    // (true, 5)\n    // (true, fmt, 5)\n    // (true, fmt)\n    function listWeekdaysImpl (localeSorted, format, index, field) {\n        if (typeof localeSorted === 'boolean') {\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n\n            format = format || '';\n        } else {\n            format = localeSorted;\n            index = format;\n            localeSorted = false;\n\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n\n            format = format || '';\n        }\n\n        var locale = getLocale(),\n            shift = localeSorted ? locale._week.dow : 0;\n\n        if (index != null) {\n            return get$1(format, (index + shift) % 7, field, 'day');\n        }\n\n        var i;\n        var out = [];\n        for (i = 0; i < 7; i++) {\n            out[i] = get$1(format, (i + shift) % 7, field, 'day');\n        }\n        return out;\n    }\n\n    function listMonths (format, index) {\n        return listMonthsImpl(format, index, 'months');\n    }\n\n    function listMonthsShort (format, index) {\n        return listMonthsImpl(format, index, 'monthsShort');\n    }\n\n    function listWeekdays (localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\n    }\n\n    function listWeekdaysShort (localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\n    }\n\n    function listWeekdaysMin (localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');\n    }\n\n    getSetGlobalLocale('en', {\n        dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\n        ordinal : function (number) {\n            var b = number % 10,\n                output = (toInt(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n            return number + output;\n        }\n    });\n\n    // Side effect imports\n\n    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);\n    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);\n\n    var mathAbs = Math.abs;\n\n    function abs () {\n        var data           = this._data;\n\n        this._milliseconds = mathAbs(this._milliseconds);\n        this._days         = mathAbs(this._days);\n        this._months       = mathAbs(this._months);\n\n        data.milliseconds  = mathAbs(data.milliseconds);\n        data.seconds       = mathAbs(data.seconds);\n        data.minutes       = mathAbs(data.minutes);\n        data.hours         = mathAbs(data.hours);\n        data.months        = mathAbs(data.months);\n        data.years         = mathAbs(data.years);\n\n        return this;\n    }\n\n    function addSubtract$1 (duration, input, value, direction) {\n        var other = createDuration(input, value);\n\n        duration._milliseconds += direction * other._milliseconds;\n        duration._days         += direction * other._days;\n        duration._months       += direction * other._months;\n\n        return duration._bubble();\n    }\n\n    // supports only 2.0-style add(1, 's') or add(duration)\n    function add$1 (input, value) {\n        return addSubtract$1(this, input, value, 1);\n    }\n\n    // supports only 2.0-style subtract(1, 's') or subtract(duration)\n    function subtract$1 (input, value) {\n        return addSubtract$1(this, input, value, -1);\n    }\n\n    function absCeil (number) {\n        if (number < 0) {\n            return Math.floor(number);\n        } else {\n            return Math.ceil(number);\n        }\n    }\n\n    function bubble () {\n        var milliseconds = this._milliseconds;\n        var days         = this._days;\n        var months       = this._months;\n        var data         = this._data;\n        var seconds, minutes, hours, years, monthsFromDays;\n\n        // if we have a mix of positive and negative values, bubble down first\n        // check: https://github.com/moment/moment/issues/2166\n        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||\n                (milliseconds <= 0 && days <= 0 && months <= 0))) {\n            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n            days = 0;\n            months = 0;\n        }\n\n        // The following code bubbles up values, see the tests for\n        // examples of what that means.\n        data.milliseconds = milliseconds % 1000;\n\n        seconds           = absFloor(milliseconds / 1000);\n        data.seconds      = seconds % 60;\n\n        minutes           = absFloor(seconds / 60);\n        data.minutes      = minutes % 60;\n\n        hours             = absFloor(minutes / 60);\n        data.hours        = hours % 24;\n\n        days += absFloor(hours / 24);\n\n        // convert days to months\n        monthsFromDays = absFloor(daysToMonths(days));\n        months += monthsFromDays;\n        days -= absCeil(monthsToDays(monthsFromDays));\n\n        // 12 months -> 1 year\n        years = absFloor(months / 12);\n        months %= 12;\n\n        data.days   = days;\n        data.months = months;\n        data.years  = years;\n\n        return this;\n    }\n\n    function daysToMonths (days) {\n        // 400 years have 146097 days (taking into account leap year rules)\n        // 400 years have 12 months === 4800\n        return days * 4800 / 146097;\n    }\n\n    function monthsToDays (months) {\n        // the reverse of daysToMonths\n        return months * 146097 / 4800;\n    }\n\n    function as (units) {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        var days;\n        var months;\n        var milliseconds = this._milliseconds;\n\n        units = normalizeUnits(units);\n\n        if (units === 'month' || units === 'year') {\n            days   = this._days   + milliseconds / 864e5;\n            months = this._months + daysToMonths(days);\n            return units === 'month' ? months : months / 12;\n        } else {\n            // handle milliseconds separately because of floating point math errors (issue #1867)\n            days = this._days + Math.round(monthsToDays(this._months));\n            switch (units) {\n                case 'week'   : return days / 7     + milliseconds / 6048e5;\n                case 'day'    : return days         + milliseconds / 864e5;\n                case 'hour'   : return days * 24    + milliseconds / 36e5;\n                case 'minute' : return days * 1440  + milliseconds / 6e4;\n                case 'second' : return days * 86400 + milliseconds / 1000;\n                // Math.floor prevents floating point math errors here\n                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;\n                default: throw new Error('Unknown unit ' + units);\n            }\n        }\n    }\n\n    // TODO: Use this.as('ms')?\n    function valueOf$1 () {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        return (\n            this._milliseconds +\n            this._days * 864e5 +\n            (this._months % 12) * 2592e6 +\n            toInt(this._months / 12) * 31536e6\n        );\n    }\n\n    function makeAs (alias) {\n        return function () {\n            return this.as(alias);\n        };\n    }\n\n    var asMilliseconds = makeAs('ms');\n    var asSeconds      = makeAs('s');\n    var asMinutes      = makeAs('m');\n    var asHours        = makeAs('h');\n    var asDays         = makeAs('d');\n    var asWeeks        = makeAs('w');\n    var asMonths       = makeAs('M');\n    var asYears        = makeAs('y');\n\n    function clone$1 () {\n        return createDuration(this);\n    }\n\n    function get$2 (units) {\n        units = normalizeUnits(units);\n        return this.isValid() ? this[units + 's']() : NaN;\n    }\n\n    function makeGetter(name) {\n        return function () {\n            return this.isValid() ? this._data[name] : NaN;\n        };\n    }\n\n    var milliseconds = makeGetter('milliseconds');\n    var seconds      = makeGetter('seconds');\n    var minutes      = makeGetter('minutes');\n    var hours        = makeGetter('hours');\n    var days         = makeGetter('days');\n    var months       = makeGetter('months');\n    var years        = makeGetter('years');\n\n    function weeks () {\n        return absFloor(this.days() / 7);\n    }\n\n    var round = Math.round;\n    var thresholds = {\n        ss: 44,         // a few seconds to seconds\n        s : 45,         // seconds to minute\n        m : 45,         // minutes to hour\n        h : 22,         // hours to day\n        d : 26,         // days to month\n        M : 11          // months to year\n    };\n\n    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n    }\n\n    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {\n        var duration = createDuration(posNegDuration).abs();\n        var seconds  = round(duration.as('s'));\n        var minutes  = round(duration.as('m'));\n        var hours    = round(duration.as('h'));\n        var days     = round(duration.as('d'));\n        var months   = round(duration.as('M'));\n        var years    = round(duration.as('y'));\n\n        var a = seconds <= thresholds.ss && ['s', seconds]  ||\n                seconds < thresholds.s   && ['ss', seconds] ||\n                minutes <= 1             && ['m']           ||\n                minutes < thresholds.m   && ['mm', minutes] ||\n                hours   <= 1             && ['h']           ||\n                hours   < thresholds.h   && ['hh', hours]   ||\n                days    <= 1             && ['d']           ||\n                days    < thresholds.d   && ['dd', days]    ||\n                months  <= 1             && ['M']           ||\n                months  < thresholds.M   && ['MM', months]  ||\n                years   <= 1             && ['y']           || ['yy', years];\n\n        a[2] = withoutSuffix;\n        a[3] = +posNegDuration > 0;\n        a[4] = locale;\n        return substituteTimeAgo.apply(null, a);\n    }\n\n    // This function allows you to set the rounding function for relative time strings\n    function getSetRelativeTimeRounding (roundingFunction) {\n        if (roundingFunction === undefined) {\n            return round;\n        }\n        if (typeof(roundingFunction) === 'function') {\n            round = roundingFunction;\n            return true;\n        }\n        return false;\n    }\n\n    // This function allows you to set a threshold for relative time strings\n    function getSetRelativeTimeThreshold (threshold, limit) {\n        if (thresholds[threshold] === undefined) {\n            return false;\n        }\n        if (limit === undefined) {\n            return thresholds[threshold];\n        }\n        thresholds[threshold] = limit;\n        if (threshold === 's') {\n            thresholds.ss = limit - 1;\n        }\n        return true;\n    }\n\n    function humanize (withSuffix) {\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n\n        var locale = this.localeData();\n        var output = relativeTime$1(this, !withSuffix, locale);\n\n        if (withSuffix) {\n            output = locale.pastFuture(+this, output);\n        }\n\n        return locale.postformat(output);\n    }\n\n    var abs$1 = Math.abs;\n\n    function sign(x) {\n        return ((x > 0) - (x < 0)) || +x;\n    }\n\n    function toISOString$1() {\n        // for ISO strings we do not use the normal bubbling rules:\n        //  * milliseconds bubble up until they become hours\n        //  * days do not bubble at all\n        //  * months bubble up until they become years\n        // This is because there is no context-free conversion between hours and days\n        // (think of clock changes)\n        // and also not between days and months (28-31 days per month)\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n\n        var seconds = abs$1(this._milliseconds) / 1000;\n        var days         = abs$1(this._days);\n        var months       = abs$1(this._months);\n        var minutes, hours, years;\n\n        // 3600 seconds -> 60 minutes -> 1 hour\n        minutes           = absFloor(seconds / 60);\n        hours             = absFloor(minutes / 60);\n        seconds %= 60;\n        minutes %= 60;\n\n        // 12 months -> 1 year\n        years  = absFloor(months / 12);\n        months %= 12;\n\n\n        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n        var Y = years;\n        var M = months;\n        var D = days;\n        var h = hours;\n        var m = minutes;\n        var s = seconds ? seconds.toFixed(3).replace(/\\.?0+$/, '') : '';\n        var total = this.asSeconds();\n\n        if (!total) {\n            // this is the same as C#'s (Noda) and python (isodate)...\n            // but not other JS (goog.date)\n            return 'P0D';\n        }\n\n        var totalSign = total < 0 ? '-' : '';\n        var ymSign = sign(this._months) !== sign(total) ? '-' : '';\n        var daysSign = sign(this._days) !== sign(total) ? '-' : '';\n        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';\n\n        return totalSign + 'P' +\n            (Y ? ymSign + Y + 'Y' : '') +\n            (M ? ymSign + M + 'M' : '') +\n            (D ? daysSign + D + 'D' : '') +\n            ((h || m || s) ? 'T' : '') +\n            (h ? hmsSign + h + 'H' : '') +\n            (m ? hmsSign + m + 'M' : '') +\n            (s ? hmsSign + s + 'S' : '');\n    }\n\n    var proto$2 = Duration.prototype;\n\n    proto$2.isValid        = isValid$1;\n    proto$2.abs            = abs;\n    proto$2.add            = add$1;\n    proto$2.subtract       = subtract$1;\n    proto$2.as             = as;\n    proto$2.asMilliseconds = asMilliseconds;\n    proto$2.asSeconds      = asSeconds;\n    proto$2.asMinutes      = asMinutes;\n    proto$2.asHours        = asHours;\n    proto$2.asDays         = asDays;\n    proto$2.asWeeks        = asWeeks;\n    proto$2.asMonths       = asMonths;\n    proto$2.asYears        = asYears;\n    proto$2.valueOf        = valueOf$1;\n    proto$2._bubble        = bubble;\n    proto$2.clone          = clone$1;\n    proto$2.get            = get$2;\n    proto$2.milliseconds   = milliseconds;\n    proto$2.seconds        = seconds;\n    proto$2.minutes        = minutes;\n    proto$2.hours          = hours;\n    proto$2.days           = days;\n    proto$2.weeks          = weeks;\n    proto$2.months         = months;\n    proto$2.years          = years;\n    proto$2.humanize       = humanize;\n    proto$2.toISOString    = toISOString$1;\n    proto$2.toString       = toISOString$1;\n    proto$2.toJSON         = toISOString$1;\n    proto$2.locale         = locale;\n    proto$2.localeData     = localeData;\n\n    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);\n    proto$2.lang = lang;\n\n    // Side effect imports\n\n    // FORMATTING\n\n    addFormatToken('X', 0, 0, 'unix');\n    addFormatToken('x', 0, 0, 'valueOf');\n\n    // PARSING\n\n    addRegexToken('x', matchSigned);\n    addRegexToken('X', matchTimestamp);\n    addParseToken('X', function (input, array, config) {\n        config._d = new Date(parseFloat(input, 10) * 1000);\n    });\n    addParseToken('x', function (input, array, config) {\n        config._d = new Date(toInt(input));\n    });\n\n    // Side effect imports\n\n\n    hooks.version = '2.22.2';\n\n    setHookCallback(createLocal);\n\n    hooks.fn                    = proto;\n    hooks.min                   = min;\n    hooks.max                   = max;\n    hooks.now                   = now;\n    hooks.utc                   = createUTC;\n    hooks.unix                  = createUnix;\n    hooks.months                = listMonths;\n    hooks.isDate                = isDate;\n    hooks.locale                = getSetGlobalLocale;\n    hooks.invalid               = createInvalid;\n    hooks.duration              = createDuration;\n    hooks.isMoment              = isMoment;\n    hooks.weekdays              = listWeekdays;\n    hooks.parseZone             = createInZone;\n    hooks.localeData            = getLocale;\n    hooks.isDuration            = isDuration;\n    hooks.monthsShort           = listMonthsShort;\n    hooks.weekdaysMin           = listWeekdaysMin;\n    hooks.defineLocale          = defineLocale;\n    hooks.updateLocale          = updateLocale;\n    hooks.locales               = listLocales;\n    hooks.weekdaysShort         = listWeekdaysShort;\n    hooks.normalizeUnits        = normalizeUnits;\n    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;\n    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\n    hooks.calendarFormat        = getCalendarFormat;\n    hooks.prototype             = proto;\n\n    // currently HTML5 input type only supports 24-hour formats\n    hooks.HTML5_FMT = {\n        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type=\"datetime-local\" />\n        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type=\"datetime-local\" step=\"1\" />\n        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type=\"datetime-local\" step=\"0.001\" />\n        DATE: 'YYYY-MM-DD',                             // <input type=\"date\" />\n        TIME: 'HH:mm',                                  // <input type=\"time\" />\n        TIME_SECONDS: 'HH:mm:ss',                       // <input type=\"time\" step=\"1\" />\n        TIME_MS: 'HH:mm:ss.SSS',                        // <input type=\"time\" step=\"0.001\" />\n        WEEK: 'YYYY-[W]WW',                             // <input type=\"week\" />\n        MONTH: 'YYYY-MM'                                // <input type=\"month\" />\n    };\n\n    return hooks;\n\n})));\n"]}